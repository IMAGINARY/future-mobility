{"version":3,"sources":["webpack://future-mobility/./node_modules/deepmerge/dist/cjs.js","webpack://future-mobility/./node_modules/events/events.js","webpack://future-mobility/./node_modules/js-yaml/index.js","webpack://future-mobility/./node_modules/js-yaml/lib/common.js","webpack://future-mobility/./node_modules/js-yaml/lib/dumper.js","webpack://future-mobility/./node_modules/js-yaml/lib/exception.js","webpack://future-mobility/./node_modules/js-yaml/lib/loader.js","webpack://future-mobility/./node_modules/js-yaml/lib/schema.js","webpack://future-mobility/./node_modules/js-yaml/lib/schema/core.js","webpack://future-mobility/./node_modules/js-yaml/lib/schema/default.js","webpack://future-mobility/./node_modules/js-yaml/lib/schema/failsafe.js","webpack://future-mobility/./node_modules/js-yaml/lib/schema/json.js","webpack://future-mobility/./node_modules/js-yaml/lib/snippet.js","webpack://future-mobility/./node_modules/js-yaml/lib/type.js","webpack://future-mobility/./node_modules/js-yaml/lib/type/binary.js","webpack://future-mobility/./node_modules/js-yaml/lib/type/bool.js","webpack://future-mobility/./node_modules/js-yaml/lib/type/float.js","webpack://future-mobility/./node_modules/js-yaml/lib/type/int.js","webpack://future-mobility/./node_modules/js-yaml/lib/type/map.js","webpack://future-mobility/./node_modules/js-yaml/lib/type/merge.js","webpack://future-mobility/./node_modules/js-yaml/lib/type/null.js","webpack://future-mobility/./node_modules/js-yaml/lib/type/omap.js","webpack://future-mobility/./node_modules/js-yaml/lib/type/pairs.js","webpack://future-mobility/./node_modules/js-yaml/lib/type/seq.js","webpack://future-mobility/./node_modules/js-yaml/lib/type/set.js","webpack://future-mobility/./node_modules/js-yaml/lib/type/str.js","webpack://future-mobility/./node_modules/js-yaml/lib/type/timestamp.js","webpack://future-mobility/./src/sass/default.scss?bcb6","webpack://future-mobility/./node_modules/vec2/vec2.js","webpack://future-mobility/./src/js/cars/ai-car-driver.js","webpack://future-mobility/./src/js/cars/car-driver.js","webpack://future-mobility/./src/js/cars/car-overlay.js","webpack://future-mobility/./src/js/cars/car-spawner.js","webpack://future-mobility/./src/js/cars/car.js","webpack://future-mobility/./src/js/cars/path-arc.js","webpack://future-mobility/./src/js/cars/path-straight.js","webpack://future-mobility/./src/js/cars/pulled-car-driver.js","webpack://future-mobility/./src/js/cars/road-map.js","webpack://future-mobility/./src/js/cars/road-tile.js","webpack://future-mobility/./src/js/cars/traffic-lights.js","webpack://future-mobility/./src/js/cfg-loader.js","webpack://future-mobility/./src/js/cfg-reader-fetch.js","webpack://future-mobility/./src/js/citizen-request-view-mgr.js","webpack://future-mobility/./src/js/citizen-request-view.js","webpack://future-mobility/./src/js/city.js","webpack://future-mobility/./src/js/data-inspector-view.js","webpack://future-mobility/./src/js/data-manager.js","webpack://future-mobility/./src/js/data-source.js","webpack://future-mobility/./src/js/data-sources/green-spaces-data.js","webpack://future-mobility/./src/js/data-sources/noise-data.js","webpack://future-mobility/./src/js/data-sources/pollution-data.js","webpack://future-mobility/./src/js/data-sources/road-safety-data.js","webpack://future-mobility/./src/js/data-sources/traffic-data.js","webpack://future-mobility/./src/js/data-sources/travel-times-data.js","webpack://future-mobility/./src/js/data-sources/zone-balance-data.js","webpack://future-mobility/./src/js/data-sources/zoning-data.js","webpack://future-mobility/./src/js/editor/city-browser.js","webpack://future-mobility/./src/js/editor/map-editor-palette.js","webpack://future-mobility/./src/js/editor/map-editor.js","webpack://future-mobility/./src/js/editor/modal-export.js","webpack://future-mobility/./src/js/editor/modal-import.js","webpack://future-mobility/./src/js/editor/modal-load.js","webpack://future-mobility/./src/js/editor/modal-save.js","webpack://future-mobility/./src/js/editor/object-store.js","webpack://future-mobility/./src/js/goal-debug-view.js","webpack://future-mobility/./src/js/grid.js","webpack://future-mobility/./src/js/index-list-view.js","webpack://future-mobility/./src/js/index-view.js","webpack://future-mobility/./src/js/lib/array-2d.js","webpack://future-mobility/./src/js/lib/cardinal-directions.js","webpack://future-mobility/./src/js/lib/config-helpers.js","webpack://future-mobility/./src/js/lib/distance.js","webpack://future-mobility/./src/js/lib/flatqueue.js","webpack://future-mobility/./src/js/lib/random.js","webpack://future-mobility/./src/js/lib/regions.js","webpack://future-mobility/./src/js/lib/show-fatal-error.js","webpack://future-mobility/./src/js/lib/sprite-fader.js","webpack://future-mobility/./src/js/lib/statistics.js","webpack://future-mobility/./src/js/lib/travel-times.js","webpack://future-mobility/./src/js/map-text-overlay.js","webpack://future-mobility/./src/js/map-view.js","webpack://future-mobility/./src/js/modal.js","webpack://future-mobility/./src/js/power-up-data-modifier.js","webpack://future-mobility/./src/js/power-up-inspector.js","webpack://future-mobility/./src/js/power-up-manager.js","webpack://future-mobility/./src/js/power-up-view-handler.js","webpack://future-mobility/./src/js/power-up-view-mgr.js","webpack://future-mobility/./src/js/power-ups/autonomous-vehicle-handler.js","webpack://future-mobility/./src/js/power-ups/autonomous-vehicle-lidar-handler.js","webpack://future-mobility/./src/js/power-ups/dense-city-handler.js","webpack://future-mobility/./src/js/power-ups/max-speed-handler.js","webpack://future-mobility/./src/js/power-ups/spawn-tram.js","webpack://future-mobility/./src/js/power-ups/traffic-handler.js","webpack://future-mobility/./src/js/power-ups/walkable-city-handler.js","webpack://future-mobility/./src/js/test/scenarios.js","webpack://future-mobility/./src/js/texture-loader.js","webpack://future-mobility/./src/js/tile-counter-view.js","webpack://future-mobility/./src/js/variable-map-overlay.js","webpack://future-mobility/./src/js/variable-map-view.js","webpack://future-mobility/./src/js/zone-balance-view.js","webpack://future-mobility/webpack/bootstrap","webpack://future-mobility/webpack/runtime/global","webpack://future-mobility/webpack/runtime/make namespace object","webpack://future-mobility/webpack/runtime/publicPath","webpack://future-mobility/./src/js/main-devtool.js"],"names":[],"mappings":";;;;;;;;;;AAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE,IAAI;AACN;;AAEA;;AAEA;;;;;;;;;;;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,QAAQ,yBAAyB;AACjC;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,6DAA6D,aAAa;AAC1E;AACA,6DAA6D,aAAa;AAC1E;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;;;;;;;;;;;AChfa;;;AAGb,aAAa,mBAAO,CAAC,0DAAc;AACnC,aAAa,mBAAO,CAAC,0DAAc;;;AAGnC;AACA;AACA;AACA;AACA;AACA;;;AAGA,iGAA0D;AAC1D,uGAA4D;AAC5D,kIAAqE;AACrE,sHAAiE;AACjE,sHAAiE;AACjE,+HAAoE;AACpE,mBAAmB;AACnB,sBAAsB;AACtB,mBAAmB;AACnB,oHAA+D;;AAE/D;AACA,uBAAuB;AACvB,0BAA0B;AAC1B,uBAAuB;;;;;;;;;;;;AC7BV;;;AAGb;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA,+CAA+C,gBAAgB;AAC/D;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA,wBAAwB;AACxB,uBAAuB;AACvB,sBAAsB;AACtB,qBAAqB;AACrB,6BAA6B;AAC7B,qBAAqB;;;;;;;;;;;;AC1DR;;AAEb;;AAEA,0BAA0B,mBAAO,CAAC,sDAAU;AAC5C,0BAA0B,mBAAO,CAAC,4DAAa;AAC/C,0BAA0B,mBAAO,CAAC,sEAAkB;;AAEpD;AACA;;AAEA;AACA,qCAAqC;AACrC,qCAAqC;AACrC,qCAAqC;AACrC,qCAAqC;AACrC,qCAAqC;AACrC,qCAAqC;AACrC,qCAAqC;AACrC,qCAAqC;AACrC,qCAAqC;AACrC,qCAAqC;AACrC,qCAAqC;AACrC,qCAAqC;AACrC,qCAAqC;AACrC,qCAAqC;AACrC,qCAAqC;AACrC,qCAAqC;AACrC,qCAAqC;AACrC,qCAAqC;AACrC,qCAAqC;AACrC,qCAAqC;AACrC,qCAAqC;AACrC,qCAAqC,KAAK;AAC1C,qCAAqC;AACrC,qCAAqC,KAAK;;AAE1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,uCAAuC,gBAAgB;AACvD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,sDAAsD,gBAAgB;AACtE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,MAAM;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,gBAAgB;AACzD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,gBAAgB;AACzD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,gBAAgB;;AAEhE;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe;AACf;;AAEA;;AAEA;;AAEA;AACA,eAAe;AACf;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA,gDAAgD,gBAAgB;AAChE;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe;AACf;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe;AACf;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,EAAE;AAC/B;;AAEA;AACA;;AAEA;;AAEA,2CAA2C,gBAAgB;AAC3D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oDAAoD,gBAAgB;AACpE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,+CAA+C,gBAAgB;AAC/D;AACA;AACA,OAAO;AACP;;AAEA,sDAAsD,gBAAgB;AACtE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,iCAAiC,YAAY;AAC7C;;AAEA;;AAEA;AACA;;AAEA,mBAAmB;;;;;;;;;;;;ACp8BnB;AACA;AACa;;;AAGb;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;;;;;;;;;;;;ACtDa;;AAEb;;AAEA,0BAA0B,mBAAO,CAAC,sDAAU;AAC5C,0BAA0B,mBAAO,CAAC,4DAAa;AAC/C,0BAA0B,mBAAO,CAAC,wDAAW;AAC7C,0BAA0B,mBAAO,CAAC,sEAAkB;;;AAGpD;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA,6CAA6C,EAAE;AAC/C;AACA,oDAAoD,EAAE,eAAe,EAAE,YAAY;;;AAGnF,sBAAsB,4CAA4C;;AAElE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,uBAAuB;AACvB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0BAA0B,UAAU;AACpC,0BAA0B,UAAU;AACpC,0BAA0B,UAAU;AACpC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA,eAAe,SAAS;AACxB;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAAmD,qBAAqB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6CAA6C;AAC7C;;AAEA;;AAEA,+CAA+C,kBAAkB;AACjE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C,kBAAkB;AAChE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kDAAkD,kBAAkB;AACpE;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA,KAAK;AACL;;AAEA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA,OAAO;AACP;AACA;;AAEA,cAAc,eAAe;AAC7B;;AAEA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA,KAAK;AACL;;AAEA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA,GAAG,yBAAyB;AAC5B,sBAAsB,IAAI;AAC1B;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,KAAK;AACL;AACA,4EAA4E;AAC5E,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA,QAAQ,+CAA+C;AACvD;;AAEA;AACA,UAAU,+CAA+C;AACzD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,6BAA6B;AAC7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA,OAAO;AACP,6BAA6B;AAC7B;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,OAAO;AACP;AACA;AACA;;AAEA,OAAO;AACP,4DAA4D,sBAAsB;AAClF;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT,mEAAmE;;AAEnE,SAAS;AACT;AACA;AACA,sBAAsB;AACtB;;AAEA,OAAO;AACP,8DAA8D;;AAE9D,OAAO;AACP;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;;AAEA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA,QAAQ,+CAA+C;AACvD;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA,GAAG;AACH;;AAEA,GAAG;AACH;;AAEA,GAAG;AACH;;AAEA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;;AAEA,kEAAkE,0BAA0B;AAC5F;;AAEA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,yDAAyD,0BAA0B;AACnF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6EAA6E;AAC7E;;AAEA,iDAAiD;AACjD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,YAAY,+CAA+C;AAC3D;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,gDAAgD,gBAAgB;AAChE;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;AAGA,sBAAsB;AACtB,mBAAmB;;;;;;;;;;;;AC9rDN;;AAEb;;AAEA,oBAAoB,mBAAO,CAAC,4DAAa;AACzC,oBAAoB,mBAAO,CAAC,kDAAQ;;;AAGpC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA,kBAAkB;AAClB,oBAAoB;AACpB,mBAAmB;AACnB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,4CAA4C,gBAAgB;AAC5D;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,GAAG;AACH;AACA;;AAEA,GAAG;AACH,sBAAsB,mEAAmE;AACzF;AACA;;AAEA,GAAG;AACH;AACA,gCAAgC,mCAAmC;AACnE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;;;;;;;;;;;;ACxHA;AACA;AACA;AACA;AACA;;;AAGa;;;AAGb,+FAAkC;;;;;;;;;;;;ACVlC;AACA;AACA;AACA;AACA;;;AAGa;;;AAGb,iBAAiB,qFAAwB;AACzC;AACA,IAAI,mBAAO,CAAC,uEAAmB;AAC/B,IAAI,mBAAO,CAAC,+DAAe;AAC3B;AACA;AACA,IAAI,mBAAO,CAAC,iEAAgB;AAC5B,IAAI,mBAAO,CAAC,6DAAc;AAC1B,IAAI,mBAAO,CAAC,+DAAe;AAC3B,IAAI,mBAAO,CAAC,2DAAa;AACzB;AACA,CAAC;;;;;;;;;;;;ACrBD;AACA;;;AAGa;;;AAGb,aAAa,mBAAO,CAAC,uDAAW;;;AAGhC;AACA;AACA,IAAI,mBAAO,CAAC,2DAAa;AACzB,IAAI,mBAAO,CAAC,2DAAa;AACzB,IAAI,mBAAO,CAAC,2DAAa;AACzB;AACA,CAAC;;;;;;;;;;;;AChBD;AACA;AACA;AACA;AACA;AACA;;;AAGa;;;AAGb,iBAAiB,6FAA4B;AAC7C;AACA,IAAI,mBAAO,CAAC,6DAAc;AAC1B,IAAI,mBAAO,CAAC,6DAAc;AAC1B,IAAI,mBAAO,CAAC,2DAAa;AACzB,IAAI,mBAAO,CAAC,+DAAe;AAC3B;AACA,CAAC;;;;;;;;;;;;AClBY;;;AAGb,aAAa,mBAAO,CAAC,sDAAU;;;AAG/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;;;;;;;;;;;ACpGa;;AAEb,oBAAoB,mBAAO,CAAC,4DAAa;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,gEAAgE,aAAa;AAC7E,oEAAoE,aAAa;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChEa;;AAEb;;;AAGA,WAAW,mBAAO,CAAC,mDAAS;;;AAG5B;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA,eAAe,WAAW;AAC1B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;AC5HY;;AAEb,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kCAAkC,EAAE;AACtE,kCAAkC,kCAAkC,EAAE;AACtE,kCAAkC,kCAAkC;AACpE,GAAG;AACH;AACA,CAAC;;;;;;;;;;;;AClCY;;AAEb,aAAa,mBAAO,CAAC,uDAAW;AAChC,aAAa,mBAAO,CAAC,mDAAS;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;AChGY;;AAEb,aAAa,mBAAO,CAAC,uDAAW;AAChC,aAAa,mBAAO,CAAC,mDAAS;;AAE9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,QAAQ,aAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6EAA6E,EAAE;AAChH,iCAAiC,+EAA+E,EAAE;AAClH,iCAAiC,yBAAyB,EAAE;AAC5D;AACA,iCAAiC,4GAA4G;AAC7I,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;AC3JY;;AAEb,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA;AACA,8BAA8B,kCAAkC;AAChE,CAAC;;;;;;;;;;;;ACPY;;AAEb,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;ACXY;;AAEb,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY,KAAK;AAC7C,4BAA4B,eAAe,EAAE;AAC7C,4BAA4B,eAAe,EAAE;AAC7C,4BAA4B,eAAe,EAAE;AAC7C,4BAA4B,WAAW;AACvC,GAAG;AACH;AACA,CAAC;;;;;;;;;;;;AClCY;;AAEb,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,yCAAyC,gBAAgB;AACzD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;AC3CY;;AAEb,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,yCAAyC,gBAAgB;AACzD;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,yCAAyC,gBAAgB;AACzD;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;ACpDY;;AAEb,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA;AACA,8BAA8B,kCAAkC;AAChE,CAAC;;;;;;;;;;;;ACPY;;AAEb,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;AC5BY;;AAEb,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA;AACA,8BAA8B,kCAAkC;AAChE,CAAC;;;;;;;;;;;;ACPY;;AAEb,WAAW,mBAAO,CAAC,mDAAS;;AAE5B;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,0BAA0B;AAC1B;;AAEA,kBAAkB;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACvFD;;;;;;;;;;;ACAA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,2CAA2C,MAAM;AACjD;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA,cAAc;AACd,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,qCAAqC,UAAU,EAAE;;AAEjD;AACA,QAAQ,KAA6B;AACrC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;ACxdD,kBAAkB,mBAAO,CAAC,iDAAc;AACxC,OAAO,YAAY,GAAG,mBAAO,CAAC,yCAAa;;AAE3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;ACzBA,YAAY,mBAAO,CAAC,uEAA4B;AAChD,iBAAiB,mBAAO,CAAC,+CAAa;AACtC,OAAO,aAAa,GAAG,mBAAO,CAAC,6CAAe;AAC9C,OAAO,YAAY,GAAG,mBAAO,CAAC,yCAAa;;AAE3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACrGA;AACA,gBAAgB,mBAAO,CAAC,iDAAiB;AACzC,sBAAsB,mBAAO,CAAC,yDAAkB;AAChD,OAAO,gBAAgB,GAAG,mBAAO,CAAC,6DAAuB;AACzD,gBAAgB,mBAAO,CAAC,6CAAY;;AAEpC;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;ACnGA,YAAY,mBAAO,CAAC,yCAAa;AACjC,iBAAiB,mBAAO,CAAC,qDAAmB;AAC5C,YAAY,mBAAO,CAAC,uEAA4B;AAChD,OAAO,iCAAiC,GAAG,mBAAO,CAAC,6CAAe;AAClE,kBAAkB,mBAAO,CAAC,iDAAc;;AAExC,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,GAAG,GAAG,QAAQ;AAC7E,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iEAAiE,QAAQ,GAAG,QAAQ;AACpF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACrKA;AACA,aAAa,mBAAO,CAAC,yCAAM;AAC3B,kBAAkB,mBAAO,CAAC,iDAAc;AACxC,YAAY,mBAAO,CAAC,uEAA4B;AAChD,iBAAiB,mBAAO,CAAC,+CAAa;AACtC,OAAO,YAAY,GAAG,mBAAO,CAAC,yCAAa;AAC3C,oBAAoB,mBAAO,CAAC,yDAAqB;AACjD,qBAAqB,mBAAO,CAAC,uDAAiB;AAC9C,gBAAgB,mBAAO,CAAC,6CAAY;AACpC,wBAAwB,mBAAO,CAAC,+DAAqB;;AAErD;AACA,iCAAiC;AACjC,iCAAiC;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACjOA,aAAa,mBAAO,CAAC,yCAAM;AAC3B,YAAY,mBAAO,CAAC,uEAA4B;AAChD,iBAAiB,mBAAO,CAAC,+CAAa;;AAEtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACnCA,aAAa,mBAAO,CAAC,yCAAM;AAC3B,iBAAiB,mBAAO,CAAC,+CAAa;AACtC,YAAY,mBAAO,CAAC,uEAA4B;AAChD,gBAAgB,mBAAO,CAAC,yCAAa;;AAErC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;AC5BA,kBAAkB,mBAAO,CAAC,iDAAc;;AAExC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,WAAW,aAAa;;AAExB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AClCA,YAAY,mBAAO,CAAC,uEAA4B;AAChD,gBAAgB,mBAAO,CAAC,iDAAiB;;AAEzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACvCA,aAAa,mBAAO,CAAC,yCAAM;AAC3B,OAAO,YAAY,GAAG,mBAAO,CAAC,yCAAa;;AAE3C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,KAAK;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,KAAK;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,oBAAoB;AAC5B,QAAQ,oBAAoB;AAC5B,QAAQ,oBAAoB;AAC5B,QAAQ,oBAAoB;AAC5B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,eAAe;AACvB,QAAQ,eAAe;AACvB,QAAQ,eAAe;AACvB,QAAQ,eAAe;AACvB;;AAEA;AACA;;AAEA;;AAEA;AACA,QAAQ,qCAAqC;AAC7C,QAAQ,mBAAmB;AAC3B,QAAQ,qCAAqC;AAC7C,QAAQ,mBAAmB;AAC3B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3GA,YAAY,mBAAO,CAAC,uEAA4B;;AAEhD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc,GAAG,aAAa;AACjE,aAAa,4BAA4B,GAAG,2BAA2B;AACvE,OAAO;AACP,mCAAmC,cAAc,GAAG,aAAa;AACjE,aAAa,aAAa,GAAG,cAAc;AAC3C;AACA;AACA,yCAAyC,cAAc,GAAG,aAAa;AACvE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;ACvEA,kBAAkB,mBAAO,CAAC,uDAAW;;AAErC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,KAAK;;AAEL,oFAAoF,6BAA6B;AACjH;AACA;;AAEA;;;;;;;;;;;AC7BA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;;AAEA;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACxJA,OAAO,aAAa,GAAG,mBAAO,CAAC,4CAAc;AAC7C,OAAO,cAAc,GAAG,mBAAO,CAAC,4DAAsB;;AAEtD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kCAAkC;AACzE,WAAW;AACX;AACA;AACA;AACA,qEAAqE,KAAK;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,4CAA4C,wDAAwD,0BAA0B,YAAY,UAAU;AAC/L,+DAA+D,0BAA0B,eAAe,EAAE,UAAU;AACpH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,wDAAwD;AAC/D;;AAEA;;AAEA;;;;;;;;;;;AC9EA,aAAa,mBAAO,CAAC,gCAAQ;AAC7B,gBAAgB,mBAAO,CAAC,gDAAgB;;AAExC;AACA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA,WAAW,gBAAgB;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACnCA;;AAEA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,oDAAkB;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,6DAA6D,gBAAgB;AAC7E;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO,qCAAqC;AAC5C,OAAO,yDAAyD;AAChE,OAAO,uDAAuD;AAC9D,OAAO,gEAAgE;AACvE,OAAO,6DAA6D;AACpE,OAAO,gEAAgE;AACvE;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,iBAAiB,IAAI,kBAAkB;AACtD;AACA;;AAEA;;;;;;;;;;;AC7EA,qBAAqB,mBAAO,CAAC,+CAAQ;;AAErC;AACA,8BAA8B;AAC9B,mCAAmC;AACnC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA,gCAAgC,4BAA4B;AAC5D;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,4BAA4B,2CAA2C,GAAG;AAC5G;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA,oDAAoD,WAAW;AAC/D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AChCA,mBAAmB,mBAAO,CAAC,+CAAgB;AAC3C,OAAO,yBAAyB,GAAG,mBAAO,CAAC,iDAAiB;AAC5D,OAAO,gBAAgB,GAAG,mBAAO,CAAC,6DAAuB;AACzD,OAAO,cAAc,GAAG,mBAAO,CAAC,+CAAgB;;AAEhD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;;;;;;;;;;AClIA,mBAAmB,mBAAO,CAAC,+CAAgB;AAC3C,gBAAgB,mBAAO,CAAC,iDAAiB;AACzC,OAAO,gBAAgB,GAAG,mBAAO,CAAC,6DAAuB;AACzD,OAAO,8CAA8C,GAAG,mBAAO,CAAC,qDAAmB;;AAEnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;AC5HA,mBAAmB,mBAAO,CAAC,+CAAgB;AAC3C,gBAAgB,mBAAO,CAAC,iDAAiB;AACzC,OAAO,gBAAgB,GAAG,mBAAO,CAAC,6DAAuB;AACzD,OAAO,4CAA4C,GAAG,mBAAO,CAAC,qDAAmB;;AAEjF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACrIA,mBAAmB,mBAAO,CAAC,+CAAgB;AAC3C,OAAO,gBAAgB,GAAG,mBAAO,CAAC,6DAAuB;AACzD,gBAAgB,mBAAO,CAAC,iDAAiB;;AAEzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;;;;;;;;;;AC7EA,mBAAmB,mBAAO,CAAC,+CAAgB;;AAE3C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;;;;;;;;;;AC9DA,mBAAmB,mBAAO,CAAC,+CAAgB;AAC3C,OAAO,gBAAgB,GAAG,mBAAO,CAAC,6DAAuB;AACzD,gBAAgB,mBAAO,CAAC,iDAAiB;AACzC,6BAA6B,mBAAO,CAAC,yDAAqB;AAC1D,OAAO,sBAAsB,GAAG,mBAAO,CAAC,qDAAmB;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;;;;;;;;;;ACjFA,mBAAmB,mBAAO,CAAC,+CAAgB;AAC3C,OAAO,gBAAgB,GAAG,mBAAO,CAAC,6DAAuB;;AAEzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAwD,KAAK;AAC7D,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,yCAAyC,KAAK;;AAE9C;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;;;;;;;;;;ACtIA,mBAAmB,mBAAO,CAAC,+CAAgB;AAC3C,gBAAgB,mBAAO,CAAC,iDAAiB;;AAEzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,yBAAyB,KAAK;AAC9B,KAAK;;AAEL;AACA;AACA,KAAK;AACL;;AAEA;AACA,wDAAwD,+BAA+B,EAAE;AACzF;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;ACrCA,aAAa,mBAAO,CAAC,iCAAS;;AAE9B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;;;;;;;;;;AChEA,qBAAqB,mBAAO,CAAC,+CAAQ;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,sCAAsC,GAAG;AACzC;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA,gCAAgC,UAAU;AAC1C,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA,gCAAgC,YAAY;AAC5C,OAAO;AACP;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;ACnIA,qBAAqB,mBAAO,CAAC,+CAAQ;AACrC,aAAa,mBAAO,CAAC,iCAAS;AAC9B,gBAAgB,mBAAO,CAAC,yCAAa;AACrC,yBAAyB,mBAAO,CAAC,mEAAsB;AACvD,kBAAkB,mBAAO,CAAC,mDAAc;AACxC,kBAAkB,mBAAO,CAAC,mDAAc;AACxC,oBAAoB,mBAAO,CAAC,uDAAgB;AAC5C,oBAAoB,mBAAO,CAAC,uDAAgB;AAC5C,oBAAoB,mBAAO,CAAC,uDAAgB;AAC5C,uBAAuB,mBAAO,CAAC,yDAAqB;AACpD,OAAO,gBAAgB,GAAG,mBAAO,CAAC,6DAAuB;AACzD,gBAAgB,mBAAO,CAAC,iDAAiB;AACzC,2BAA2B,mBAAO,CAAC,iEAAyB;AAC5D,6BAA6B,mBAAO,CAAC,yDAAqB;;AAE1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,uBAAuB;AACvB,qBAAqB;AACrB,wBAAwB;AACxB,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;;AAEA,SAAS;AACT;AACA;AACA;AACA;AACA,8CAA8C,yBAAyB;AACvE,gDAAgD,yBAAyB;AACzE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA,qCAAqC,OAAO,IAAI,OAAO;AACvD;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,wBAAwB;AACxB,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,wBAAwB;AACxB,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACpLA,cAAc,mBAAO,CAAC,mCAAU;;AAEhC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;;;;;;;;;;AC3BA,cAAc,mBAAO,CAAC,mCAAU;;AAEhC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACzCA,cAAc,mBAAO,CAAC,mCAAU;AAChC,oBAAoB,mBAAO,CAAC,uDAAgB;;AAE5C;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC3CA,cAAc,mBAAO,CAAC,mCAAU;AAChC,oBAAoB,mBAAO,CAAC,uDAAgB;;AAE5C;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC3CA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,EAAE;AACZ;AACA;AACA;;AAEA;AACA;AACA,UAAU,EAAE;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACrEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gCAAgC;AACzE;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;ACxCA,qBAAqB,mBAAO,CAAC,+CAAQ;AACrC,gBAAgB,mBAAO,CAAC,gDAAgB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,cAAc;AACd;AACA;AACA,WAAW,uBAAuB;AAClC;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA,8BAA8B,kBAAkB;AAChD;AACA;AACA;AACA,8BAA8B,kBAAkB;AAChD;AACA;AACA;AACA,8BAA8B,kBAAkB;AAChD;AACA;AACA;AACA,8BAA8B,kBAAkB;AAChD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;;;;;;;;;;AC9MA,kBAAkB,mBAAO,CAAC,4CAAc;;AAExC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA,uCAAuC,KAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;;AAEA;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB,OAAO;AAC3B,uBAAuB,IAAI;AAC3B,cAAc;AACd;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB,oBAAoB;AACpB,mBAAmB;AACnB;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,mBAAmB,cAAc;AACjC,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,kBAAkB;AAClB;AACA;AACA,mBAAmB,gBAAgB;AACnC,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf,mBAAmB;AACnB;AACA;AACA,mBAAmB,cAAc;AACjC,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA,mBAAmB,cAAc;AACjC,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA;AACA,eAAe;AACf,sBAAsB;AACtB;AACA;AACA,mBAAmB,cAAc;AACjC,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB,0BAA0B;AAC1B,eAAe;AACf,eAAe;AACf;AACA;AACA;AACA,eAAe;AACf,sBAAsB;AACtB,0BAA0B;AAC1B,cAAc;AACd;AACA;AACA;AACA,mBAAmB,cAAc;AACjC,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,cAAc;AACjC,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC5MA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC7CA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;;;;;ACVlB,gBAAgB,mBAAO,CAAC,4CAAY;;AAEpC;AACA;AACA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,QAAQ;AAC5C,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;AC9BA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;ACjCA,gBAAgB,mBAAO,CAAC,4CAAY;;AAEpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,wBAAwB,YAAY,EAAE;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;AC7EA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3HA,kBAAkB,mBAAO,CAAC,8CAAa;AACvC,gBAAgB,mBAAO,CAAC,4CAAY;AACpC,OAAO,gBAAgB,GAAG,mBAAO,CAAC,yDAAmB;;AAErD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACrEA;;AAEA,gBAAgB,mBAAO,CAAC,wCAAY;AACpC,gBAAgB,mBAAO,CAAC,gDAAgB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,2CAA2C,gBAAgB,EAAE;AAC7D;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACvEA;AACA,qBAAqB,mBAAO,CAAC,+CAAQ;AACrC,gBAAgB,mBAAO,CAAC,gDAAgB;AACxC,OAAO,gBAAgB,GAAG,mBAAO,CAAC,4DAAsB;AACxD,qBAAqB,mBAAO,CAAC,8EAAsC;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,6BAA6B,aAAa;AAC1C,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS,OAAO;AAChB;;AAEA;AACA;;AAEA;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA,uCAAuC,YAAY,OAAO;AAC1D;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qEAAqE,cAAc;AACnF;AACA;;AAEA;AACA;AACA,sEAAsE,cAAc;AACpF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8EAA8E,uBAAuB,EAAE,SAAS;AAChH;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,0CAA0C,yBAAyB;AACnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;ACnPA;AACA;AACA,aAAa,OAAO;AACpB;AACA,aAAa,OAAO;AACpB;AACA,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,aAAa;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;;;;;;;;;;ACrCA,qBAAqB,mBAAO,CAAC,+CAAQ;;AAErC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0CAA0C,GAAG;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACzCA,qBAAqB,mBAAO,CAAC,+CAAQ;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACxCA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;AC5DA,2BAA2B,mBAAO,CAAC,mEAA0B;AAC7D,oBAAoB,mBAAO,CAAC,6DAAuB;;AAEnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC1BA;AACA,2BAA2B,mBAAO,CAAC,mEAA0B;AAC7D,OAAO,aAAa,GAAG,mBAAO,CAAC,6CAAe;AAC9C;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACjNA,2BAA2B,mBAAO,CAAC,mEAA0B;AAC7D,gBAAgB,mBAAO,CAAC,yCAAa;AACrC,OAAO,gBAAgB,GAAG,mBAAO,CAAC,6DAAuB;;AAEzD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,kCAAkC;AAC/D;AACA,6BAA6B,iCAAiC;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,iCAAiC;AAC9D;AACA,6BAA6B,kCAAkC;AAC/D;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC1DA,2BAA2B,mBAAO,CAAC,mEAA0B;;AAE7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACvBA,2BAA2B,mBAAO,CAAC,mEAA0B;;AAE7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACjBA,2BAA2B,mBAAO,CAAC,mEAA0B;;AAE7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;;;;;;;;;;AC3BA,2BAA2B,mBAAO,CAAC,mEAA0B;;AAE7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;AC1BA;AACA,YAAY,mBAAO,CAAC,yCAAa;AACjC,iBAAiB,mBAAO,CAAC,qDAAmB;AAC5C,eAAe,mBAAO,CAAC,gDAAe;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3DA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,uBAAuB,WAAW,EAAE,QAAQ,EAAE;;AAEtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA,0BAA0B,YAAY,IAAI,aAAa;AACvD,KAAK;AACL;;AAEA;AACA,sCAAsC,KAAK;AAC3C;AACA,KAAK;AACL;;AAEA;AACA;AACA,6CAA6C,KAAK,GAAG,IAAI;AACzD;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;AC5DA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAI,GAAG,+BAA+B,OAAO,KAAK,GAAG,gCAAgC;AACzG,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6DAA6D;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,4CAA4C,KAAK;AACjD,8BAA8B,MAAM,IAAI,wCAAwC;AAChF,KAAK;;AAEL,qCAAqC,gBAAgB;AACrD;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AChGA,wBAAwB,mBAAO,CAAC,0DAAqB;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC3FA;AACA,gBAAgB,mBAAO,CAAC,gDAAgB;;AAExC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,+CAA+C,KAAK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc,kCAAkC,EAAE,gBAAgB;AAClE;;AAEA;AACA;AACA,qCAAqC,KAAK;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;;;;;;;;UCpDA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,EAAE;WACF;WACA;WACA,CAAC,I;;;;;WCPD;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;;WCNA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,kC;;;;;;;;;;ACfA;AACA,aAAa,mBAAO,CAAC,gDAAS;AAC9B,uBAAuB,mBAAO,CAAC,wDAAoB;AACnD,kBAAkB,mBAAO,CAAC,4CAAc;AACxC,aAAa,mBAAO,CAAC,gCAAQ;AAC7B,kBAAkB,mBAAO,CAAC,0DAAqB;AAC/C,wBAAwB,mBAAO,CAAC,0DAAqB;AACrD,mBAAmB,mBAAO,CAAC,wDAAoB;AAC/C,wBAAwB,mBAAO,CAAC,0DAAqB;AACrD,sBAAsB,mBAAO,CAAC,oDAAkB;AAChD,uBAAuB,mBAAO,CAAC,gEAAwB;AACvD,mBAAO,CAAC,qDAAsB;AAC9B,wBAAwB,mBAAO,CAAC,0DAAqB;AACrD,0BAA0B,mBAAO,CAAC,8DAAuB;AACzD,sBAAsB,mBAAO,CAAC,sDAAmB;AACjD,sBAAsB,mBAAO,CAAC,8EAA+B;AAC7D,kBAAkB,mBAAO,CAAC,sEAA2B;AACrD,wBAAwB,mBAAO,CAAC,oFAAkC;AAClE,wBAAwB,mBAAO,CAAC,oFAAkC;AAClE,mBAAmB,mBAAO,CAAC,wEAA4B;AACvD,wBAAwB,mBAAO,CAAC,oFAAkC;AAClE,sBAAsB,mBAAO,CAAC,sDAAmB;AACjD,oBAAoB,mBAAO,CAAC,gDAAgB;AAC5C,2BAA2B,mBAAO,CAAC,gEAAwB;AAC3D,8BAA8B,mBAAO,CAAC,wEAA4B;AAClE,sBAAsB,mBAAO,CAAC,oDAAkB;AAChD,mBAAmB,mBAAO,CAAC,wDAAoB;AAC/C,oBAAoB,mBAAO,CAAC,0EAA6B;AACzD,uBAAuB,mBAAO,CAAC,kFAAiC;AAChE,yBAAyB,mBAAO,CAAC,4DAAsB;AACvD,uBAAuB,mBAAO,CAAC,wDAAoB;AACnD,4BAA4B,mBAAO,CAAC,oEAA0B;AAC9D,uBAAuB,mBAAO,CAAC,0DAAqB;AACpD,uBAAuB,mBAAO,CAAC,0EAA6B;AAC5D,iCAAiC,mBAAO,CAAC,gGAAwC;AACjF,wBAAwB,mBAAO,CAAC,8EAA+B;AAC/D,yBAAyB,mBAAO,CAAC,gEAAwB;AACzD,4BAA4B,mBAAO,CAAC,sFAAmC;AACvE,yBAAyB,mBAAO,CAAC,gFAAgC;AACjE,sCAAsC,mBAAO,CAAC,4GAA8C;;AAE5F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP,GAAG","file":"devtool.f444e0f6bc5562b7cfc5.js","sourcesContent":["'use strict';\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","'use strict';\n\n\nvar loader = require('./lib/loader');\nvar dumper = require('./lib/dumper');\n\n\nfunction renamed(from, to) {\n  return function () {\n    throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' +\n      'Use yaml.' + to + ' instead, which is now safe by default.');\n  };\n}\n\n\nmodule.exports.Type                = require('./lib/type');\nmodule.exports.Schema              = require('./lib/schema');\nmodule.exports.FAILSAFE_SCHEMA     = require('./lib/schema/failsafe');\nmodule.exports.JSON_SCHEMA         = require('./lib/schema/json');\nmodule.exports.CORE_SCHEMA         = require('./lib/schema/core');\nmodule.exports.DEFAULT_SCHEMA      = require('./lib/schema/default');\nmodule.exports.load                = loader.load;\nmodule.exports.loadAll             = loader.loadAll;\nmodule.exports.dump                = dumper.dump;\nmodule.exports.YAMLException       = require('./lib/exception');\n\n// Removed functions from JS-YAML 3.0.x\nmodule.exports.safeLoad            = renamed('safeLoad', 'load');\nmodule.exports.safeLoadAll         = renamed('safeLoadAll', 'loadAll');\nmodule.exports.safeDump            = renamed('safeDump', 'dump');\n","'use strict';\n\n\nfunction isNothing(subject) {\n  return (typeof subject === 'undefined') || (subject === null);\n}\n\n\nfunction isObject(subject) {\n  return (typeof subject === 'object') && (subject !== null);\n}\n\n\nfunction toArray(sequence) {\n  if (Array.isArray(sequence)) return sequence;\n  else if (isNothing(sequence)) return [];\n\n  return [ sequence ];\n}\n\n\nfunction extend(target, source) {\n  var index, length, key, sourceKeys;\n\n  if (source) {\n    sourceKeys = Object.keys(source);\n\n    for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n      key = sourceKeys[index];\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n\nfunction repeat(string, count) {\n  var result = '', cycle;\n\n  for (cycle = 0; cycle < count; cycle += 1) {\n    result += string;\n  }\n\n  return result;\n}\n\n\nfunction isNegativeZero(number) {\n  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);\n}\n\n\nmodule.exports.isNothing      = isNothing;\nmodule.exports.isObject       = isObject;\nmodule.exports.toArray        = toArray;\nmodule.exports.repeat         = repeat;\nmodule.exports.isNegativeZero = isNegativeZero;\nmodule.exports.extend         = extend;\n","'use strict';\n\n/*eslint-disable no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar DEFAULT_SCHEMA      = require('./schema/default');\n\nvar _toString       = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar CHAR_BOM                  = 0xFEFF;\nvar CHAR_TAB                  = 0x09; /* Tab */\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\nvar CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\nvar CHAR_SPACE                = 0x20; /* Space */\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\nvar CHAR_SHARP                = 0x23; /* # */\nvar CHAR_PERCENT              = 0x25; /* % */\nvar CHAR_AMPERSAND            = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\nvar CHAR_ASTERISK             = 0x2A; /* * */\nvar CHAR_COMMA                = 0x2C; /* , */\nvar CHAR_MINUS                = 0x2D; /* - */\nvar CHAR_COLON                = 0x3A; /* : */\nvar CHAR_EQUALS               = 0x3D; /* = */\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\nvar CHAR_QUESTION             = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\n\nESCAPE_SEQUENCES[0x00]   = '\\\\0';\nESCAPE_SEQUENCES[0x07]   = '\\\\a';\nESCAPE_SEQUENCES[0x08]   = '\\\\b';\nESCAPE_SEQUENCES[0x09]   = '\\\\t';\nESCAPE_SEQUENCES[0x0A]   = '\\\\n';\nESCAPE_SEQUENCES[0x0B]   = '\\\\v';\nESCAPE_SEQUENCES[0x0C]   = '\\\\f';\nESCAPE_SEQUENCES[0x0D]   = '\\\\r';\nESCAPE_SEQUENCES[0x1B]   = '\\\\e';\nESCAPE_SEQUENCES[0x22]   = '\\\\\"';\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85]   = '\\\\N';\nESCAPE_SEQUENCES[0xA0]   = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n];\n\nvar DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n\n  if (map === null) return {};\n\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\n\nvar QUOTING_TYPE_SINGLE = 1,\n    QUOTING_TYPE_DOUBLE = 2;\n\nfunction State(options) {\n  this.schema        = options['schema'] || DEFAULT_SCHEMA;\n  this.indent        = Math.max(1, (options['indent'] || 2));\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid   = options['skipInvalid'] || false;\n  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys      = options['sortKeys'] || false;\n  this.lineWidth     = options['lineWidth'] || 80;\n  this.noRefs        = options['noRefs'] || false;\n  this.noCompatMode  = options['noCompatMode'] || false;\n  this.condenseFlow  = options['condenseFlow'] || false;\n  this.quotingType   = options['quotingType'] === '\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\n  this.forceQuotes   = options['forceQuotes'] || false;\n  this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n\n  this.tag = null;\n  this.result = '';\n\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n}\n\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isn’t mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n  return  (0x00020 <= c && c <= 0x00007E)\n      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)\n      ||  (0x10000 <= c && c <= 0x10FFFF);\n}\n\n// [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// Including s-white (for some reason, examples doesn't match specs in this aspect)\n// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark\nfunction isNsCharOrWhitespace(c) {\n  return isPrintable(c)\n    && c !== CHAR_BOM\n    // - b-char\n    && c !== CHAR_CARRIAGE_RETURN\n    && c !== CHAR_LINE_FEED;\n}\n\n// [127]  ns-plain-safe(c) ::= c = flow-out  ⇒ ns-plain-safe-out\n//                             c = flow-in   ⇒ ns-plain-safe-in\n//                             c = block-key ⇒ ns-plain-safe-out\n//                             c = flow-key  ⇒ ns-plain-safe-in\n// [128] ns-plain-safe-out ::= ns-char\n// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator\n// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - “:” - “#” )\n//                            | ( /* An ns-char preceding */ “#” )\n//                            | ( “:” /* Followed by an ns-plain-safe(c) */ )\nfunction isPlainSafe(c, prev, inblock) {\n  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\n  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\n  return (\n    // ns-plain-safe\n    inblock ? // c = flow-in\n      cIsNsCharOrWhitespace\n      : cIsNsCharOrWhitespace\n        // - c-flow-indicator\n        && c !== CHAR_COMMA\n        && c !== CHAR_LEFT_SQUARE_BRACKET\n        && c !== CHAR_RIGHT_SQUARE_BRACKET\n        && c !== CHAR_LEFT_CURLY_BRACKET\n        && c !== CHAR_RIGHT_CURLY_BRACKET\n  )\n    // ns-plain-char\n    && c !== CHAR_SHARP // false on '#'\n    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '\n    || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'\n    || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'\n}\n\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  // No support of ( ( “?” | “:” | “-” ) /* Followed by an ns-plain-safe(c)) */ ) part\n  return isPrintable(c) && c !== CHAR_BOM\n    && !isWhitespace(c) // - s-white\n    // - (c-indicator ::=\n    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”\n    && c !== CHAR_MINUS\n    && c !== CHAR_QUESTION\n    && c !== CHAR_COLON\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “\"”\n    && c !== CHAR_SHARP\n    && c !== CHAR_AMPERSAND\n    && c !== CHAR_ASTERISK\n    && c !== CHAR_EXCLAMATION\n    && c !== CHAR_VERTICAL_LINE\n    && c !== CHAR_EQUALS\n    && c !== CHAR_GREATER_THAN\n    && c !== CHAR_SINGLE_QUOTE\n    && c !== CHAR_DOUBLE_QUOTE\n    // | “%” | “@” | “`”)\n    && c !== CHAR_PERCENT\n    && c !== CHAR_COMMERCIAL_AT\n    && c !== CHAR_GRAVE_ACCENT;\n}\n\n// Simplified test for values allowed as the last character in plain style.\nfunction isPlainSafeLast(c) {\n  // just not whitespace or colon, it will be checked to be plain character later\n  return !isWhitespace(c) && c !== CHAR_COLON;\n}\n\n// Same as 'string'.codePointAt(pos), but works in older browsers.\nfunction codePointAt(string, pos) {\n  var first = string.charCodeAt(pos), second;\n  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {\n    second = string.charCodeAt(pos + 1);\n    if (second >= 0xDC00 && second <= 0xDFFF) {\n      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n    }\n  }\n  return first;\n}\n\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN   = 1,\n    STYLE_SINGLE  = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED  = 4,\n    STYLE_DOUBLE  = 5;\n\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,\n  testAmbiguousType, quotingType, forceQuotes, inblock) {\n\n  var i;\n  var char = 0;\n  var prevChar = null;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n  var plain = isPlainSafeFirst(codePointAt(string, 0))\n          && isPlainSafeLast(codePointAt(string, string.length - 1));\n\n  if (singleLineOnly || forceQuotes) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true;\n        // Check if any line can be folded.\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine ||\n            // Foldable line = too long, and not more-indented.\n            (i - previousLineBreak - 1 > lineWidth &&\n             string[previousLineBreak + 1] !== ' ');\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n    // in case the end is missing a \\n\n    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n      (i - previousLineBreak - 1 > lineWidth &&\n       string[previousLineBreak + 1] !== ' '));\n  }\n  // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    if (plain && !forceQuotes && !testAmbiguousType(string)) {\n      return STYLE_PLAIN;\n    }\n    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n  }\n  // Edge case: block indentation indicator can only have one digit.\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  }\n  // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n  if (!forceQuotes) {\n    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n  }\n  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n}\n\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//    • No ending newline => unaffected; already using strip \"-\" chomping.\n//    • Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey, inblock) {\n  state.dump = (function () {\n    if (string.length === 0) {\n      return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"\"' : \"''\";\n    }\n    if (!state.noCompatMode) {\n      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\n        return state.quotingType === QUOTING_TYPE_DOUBLE ? ('\"' + string + '\"') : (\"'\" + string + \"'\");\n      }\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n    var lineWidth = state.lineWidth === -1\n      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n    // Without knowing if keys are implicit/explicit, assume implicit for safety.\n    var singleLineOnly = iskey\n      // No block styles in flow mode.\n      || (state.flowLevel > -1 && level >= state.flowLevel);\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,\n      testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {\n\n      case STYLE_PLAIN:\n        return string;\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(string, indent));\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string, lineWidth) + '\"';\n      default:\n        throw new YAMLException('impossible error: invalid scalar style');\n    }\n  }());\n}\n\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n  // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n  var clip =          string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : (clip ? '' : '-');\n\n  return indentIndicator + chomp + '\\n';\n}\n\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n}\n\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g;\n\n  // first line (possibly an empty line)\n  var result = (function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }());\n  // If we haven't reached the first content line yet, don't add an extra \\n.\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented;\n\n  // rest of the lines\n  var match;\n  while ((match = lineRe.exec(string))) {\n    var prefix = match[1], line = match[2];\n    moreIndented = (line[0] === ' ');\n    result += prefix\n      + (!prevMoreIndented && !moreIndented && line !== ''\n        ? '\\n' : '')\n      + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n}\n\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line;\n\n  // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n  var match;\n  // start is an inclusive index. end, curr, and next are exclusive.\n  var start = 0, end, curr = 0, next = 0;\n  var result = '';\n\n  // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n  while ((match = breakRe.exec(line))) {\n    next = match.index;\n    // maintain invariant: curr - start <= width\n    if (next - start > width) {\n      end = (curr > start) ? curr : next; // derive end <= length-2\n      result += '\\n' + line.slice(start, end);\n      // skip the space that was output as \\n\n      start = end + 1;                    // derive start <= length-1\n    }\n    curr = next;\n  }\n\n  // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n  result += '\\n';\n  // Insert a break if the remainder is too long and there is a break available.\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n}\n\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n  var result = '';\n  var char = 0;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n    char = codePointAt(string, i);\n    escapeSeq = ESCAPE_SEQUENCES[char];\n\n    if (!escapeSeq && isPrintable(char)) {\n      result += string[i];\n      if (char >= 0x10000) result += string[i + 1];\n    } else {\n      result += escapeSeq || encodeHex(char);\n    }\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level, value, false, false) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level, null, false, false))) {\n\n      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level + 1, value, true, true, false, true) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level + 1, null, true, true, false, true))) {\n\n      if (!compact || _result !== '') {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n\n    pairBuffer = '';\n    if (_result !== '') pairBuffer += ', ';\n\n    if (state.condenseFlow) pairBuffer += '\"';\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new YAMLException('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || _result !== '') {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = (state.tag !== null && state.tag !== '?') ||\n                   (state.dump && state.dump.length > 1024);\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf  || type.predicate) &&\n        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n        (!type.predicate  || type.predicate(object))) {\n\n      if (explicit) {\n        if (type.multi && type.representName) {\n          state.tag = type.representName(object);\n        } else {\n          state.tag = type.tag;\n        }\n      } else {\n        state.tag = '?';\n      }\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey, isblockseq) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n  var inblock = block;\n  var tagStr;\n\n  if (block) {\n    block = (state.flowLevel < 0 || state.flowLevel > level);\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if (type === '[object Object]') {\n      if (block && (Object.keys(state.dump).length !== 0)) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      if (block && (state.dump.length !== 0)) {\n        if (state.noArrayIndent && !isblockseq && level > 0) {\n          writeBlockSequence(state, level - 1, state.dump, compact);\n        } else {\n          writeBlockSequence(state, level, state.dump, compact);\n        }\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey, inblock);\n      }\n    } else if (type === '[object Undefined]') {\n      return false;\n    } else {\n      if (state.skipInvalid) return false;\n      throw new YAMLException('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      // Need to encode all characters except those allowed by the spec:\n      //\n      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */\n      // [36] ns-hex-digit    ::=  ns-dec-digit\n      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */\n      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */\n      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | “-”\n      // [39] ns-uri-char     ::=  “%” ns-hex-digit ns-hex-digit | ns-word-char | “#”\n      //                         | “;” | “/” | “?” | “:” | “@” | “&” | “=” | “+” | “$” | “,”\n      //                         | “_” | “.” | “!” | “~” | “*” | “'” | “(” | “)” | “[” | “]”\n      //\n      // Also need to encode '!' because it has special meaning (end of tag prefix).\n      //\n      tagStr = encodeURI(\n        state.tag[0] === '!' ? state.tag.slice(1) : state.tag\n      ).replace(/!/g, '%21');\n\n      if (state.tag[0] === '!') {\n        tagStr = '!' + tagStr;\n      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {\n        tagStr = '!!' + tagStr.slice(18);\n      } else {\n        tagStr = '!<' + tagStr + '>';\n      }\n\n      state.dump = tagStr + ' ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList,\n      index,\n      length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump(input, options) {\n  options = options || {};\n\n  var state = new State(options);\n\n  if (!state.noRefs) getDuplicateReferences(input, state);\n\n  var value = input;\n\n  if (state.replacer) {\n    value = state.replacer.call({ '': value }, '', value);\n  }\n\n  if (writeNode(state, 0, value, true, true)) return state.dump + '\\n';\n\n  return '';\n}\n\nmodule.exports.dump = dump;\n","// YAML error class. http://stackoverflow.com/questions/8458984\n//\n'use strict';\n\n\nfunction formatError(exception, compact) {\n  var where = '', message = exception.reason || '(unknown reason)';\n\n  if (!exception.mark) return message;\n\n  if (exception.mark.name) {\n    where += 'in \"' + exception.mark.name + '\" ';\n  }\n\n  where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';\n\n  if (!compact && exception.mark.snippet) {\n    where += '\\n\\n' + exception.mark.snippet;\n  }\n\n  return message + ' ' + where;\n}\n\n\nfunction YAMLException(reason, mark) {\n  // Super constructor\n  Error.call(this);\n\n  this.name = 'YAMLException';\n  this.reason = reason;\n  this.mark = mark;\n  this.message = formatError(this, false);\n\n  // Include stack trace in error object\n  if (Error.captureStackTrace) {\n    // Chrome and NodeJS\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    // FF, IE 10+ and Safari 6+. Fallback for others\n    this.stack = (new Error()).stack || '';\n  }\n}\n\n\n// Inherit from Error\nYAMLException.prototype = Object.create(Error.prototype);\nYAMLException.prototype.constructor = YAMLException;\n\n\nYAMLException.prototype.toString = function toString(compact) {\n  return this.name + ': ' + formatError(this, compact);\n};\n\n\nmodule.exports = YAMLException;\n","'use strict';\n\n/*eslint-disable max-len,no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar makeSnippet         = require('./snippet');\nvar DEFAULT_SCHEMA      = require('./schema/default');\n\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\nvar CONTEXT_FLOW_IN   = 1;\nvar CONTEXT_FLOW_OUT  = 2;\nvar CONTEXT_BLOCK_IN  = 3;\nvar CONTEXT_BLOCK_OUT = 4;\n\n\nvar CHOMPING_CLIP  = 1;\nvar CHOMPING_STRIP = 2;\nvar CHOMPING_KEEP  = 3;\n\n\nvar PATTERN_NON_PRINTABLE         = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\nvar PATTERN_FLOW_INDICATORS       = /[,\\[\\]\\{\\}]/;\nvar PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\\-]+!)$/i;\nvar PATTERN_TAG_URI               = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\n\nfunction is_EOL(c) {\n  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);\n}\n\nfunction is_WHITE_SPACE(c) {\n  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);\n}\n\nfunction is_WS_OR_EOL(c) {\n  return (c === 0x09/* Tab */) ||\n         (c === 0x20/* Space */) ||\n         (c === 0x0A/* LF */) ||\n         (c === 0x0D/* CR */);\n}\n\nfunction is_FLOW_INDICATOR(c) {\n  return c === 0x2C/* , */ ||\n         c === 0x5B/* [ */ ||\n         c === 0x5D/* ] */ ||\n         c === 0x7B/* { */ ||\n         c === 0x7D/* } */;\n}\n\nfunction fromHexCode(c) {\n  var lc;\n\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  /*eslint-disable no-bitwise*/\n  lc = c | 0x20;\n\n  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {\n    return lc - 0x61 + 10;\n  }\n\n  return -1;\n}\n\nfunction escapedHexLen(c) {\n  if (c === 0x78/* x */) { return 2; }\n  if (c === 0x75/* u */) { return 4; }\n  if (c === 0x55/* U */) { return 8; }\n  return 0;\n}\n\nfunction fromDecimalCode(c) {\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  return -1;\n}\n\nfunction simpleEscapeSequence(c) {\n  /* eslint-disable indent */\n  return (c === 0x30/* 0 */) ? '\\x00' :\n        (c === 0x61/* a */) ? '\\x07' :\n        (c === 0x62/* b */) ? '\\x08' :\n        (c === 0x74/* t */) ? '\\x09' :\n        (c === 0x09/* Tab */) ? '\\x09' :\n        (c === 0x6E/* n */) ? '\\x0A' :\n        (c === 0x76/* v */) ? '\\x0B' :\n        (c === 0x66/* f */) ? '\\x0C' :\n        (c === 0x72/* r */) ? '\\x0D' :\n        (c === 0x65/* e */) ? '\\x1B' :\n        (c === 0x20/* Space */) ? ' ' :\n        (c === 0x22/* \" */) ? '\\x22' :\n        (c === 0x2F/* / */) ? '/' :\n        (c === 0x5C/* \\ */) ? '\\x5C' :\n        (c === 0x4E/* N */) ? '\\x85' :\n        (c === 0x5F/* _ */) ? '\\xA0' :\n        (c === 0x4C/* L */) ? '\\u2028' :\n        (c === 0x50/* P */) ? '\\u2029' : '';\n}\n\nfunction charFromCodepoint(c) {\n  if (c <= 0xFFFF) {\n    return String.fromCharCode(c);\n  }\n  // Encode UTF-16 surrogate pair\n  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n  return String.fromCharCode(\n    ((c - 0x010000) >> 10) + 0xD800,\n    ((c - 0x010000) & 0x03FF) + 0xDC00\n  );\n}\n\nvar simpleEscapeCheck = new Array(256); // integer, for fast access\nvar simpleEscapeMap = new Array(256);\nfor (var i = 0; i < 256; i++) {\n  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n  simpleEscapeMap[i] = simpleEscapeSequence(i);\n}\n\n\nfunction State(input, options) {\n  this.input = input;\n\n  this.filename  = options['filename']  || null;\n  this.schema    = options['schema']    || DEFAULT_SCHEMA;\n  this.onWarning = options['onWarning'] || null;\n  // (Hidden) Remove? makes the loader to expect YAML 1.1 documents\n  // if such documents have no explicit %YAML directive\n  this.legacy    = options['legacy']    || false;\n\n  this.json      = options['json']      || false;\n  this.listener  = options['listener']  || null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.typeMap       = this.schema.compiledTypeMap;\n\n  this.length     = input.length;\n  this.position   = 0;\n  this.line       = 0;\n  this.lineStart  = 0;\n  this.lineIndent = 0;\n\n  // position of first leading tab in the current line,\n  // used to make sure there are no tabs in the indentation\n  this.firstTabInLine = -1;\n\n  this.documents = [];\n\n  /*\n  this.version;\n  this.checkLineBreaks;\n  this.tagMap;\n  this.anchorMap;\n  this.tag;\n  this.anchor;\n  this.kind;\n  this.result;*/\n\n}\n\n\nfunction generateError(state, message) {\n  var mark = {\n    name:     state.filename,\n    buffer:   state.input.slice(0, -1), // omit trailing \\0\n    position: state.position,\n    line:     state.line,\n    column:   state.position - state.lineStart\n  };\n\n  mark.snippet = makeSnippet(mark);\n\n  return new YAMLException(message, mark);\n}\n\nfunction throwError(state, message) {\n  throw generateError(state, message);\n}\n\nfunction throwWarning(state, message) {\n  if (state.onWarning) {\n    state.onWarning.call(null, generateError(state, message));\n  }\n}\n\n\nvar directiveHandlers = {\n\n  YAML: function handleYamlDirective(state, name, args) {\n\n    var match, major, minor;\n\n    if (state.version !== null) {\n      throwError(state, 'duplication of %YAML directive');\n    }\n\n    if (args.length !== 1) {\n      throwError(state, 'YAML directive accepts exactly one argument');\n    }\n\n    match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n    if (match === null) {\n      throwError(state, 'ill-formed argument of the YAML directive');\n    }\n\n    major = parseInt(match[1], 10);\n    minor = parseInt(match[2], 10);\n\n    if (major !== 1) {\n      throwError(state, 'unacceptable YAML version of the document');\n    }\n\n    state.version = args[0];\n    state.checkLineBreaks = (minor < 2);\n\n    if (minor !== 1 && minor !== 2) {\n      throwWarning(state, 'unsupported YAML version of the document');\n    }\n  },\n\n  TAG: function handleTagDirective(state, name, args) {\n\n    var handle, prefix;\n\n    if (args.length !== 2) {\n      throwError(state, 'TAG directive accepts exactly two arguments');\n    }\n\n    handle = args[0];\n    prefix = args[1];\n\n    if (!PATTERN_TAG_HANDLE.test(handle)) {\n      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n    }\n\n    if (_hasOwnProperty.call(state.tagMap, handle)) {\n      throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n    }\n\n    if (!PATTERN_TAG_URI.test(prefix)) {\n      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n    }\n\n    try {\n      prefix = decodeURIComponent(prefix);\n    } catch (err) {\n      throwError(state, 'tag prefix is malformed: ' + prefix);\n    }\n\n    state.tagMap[handle] = prefix;\n  }\n};\n\n\nfunction captureSegment(state, start, end, checkJson) {\n  var _position, _length, _character, _result;\n\n  if (start < end) {\n    _result = state.input.slice(start, end);\n\n    if (checkJson) {\n      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n        _character = _result.charCodeAt(_position);\n        if (!(_character === 0x09 ||\n              (0x20 <= _character && _character <= 0x10FFFF))) {\n          throwError(state, 'expected valid JSON character');\n        }\n      }\n    } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n      throwError(state, 'the stream contains non-printable characters');\n    }\n\n    state.result += _result;\n  }\n}\n\nfunction mergeMappings(state, destination, source, overridableKeys) {\n  var sourceKeys, key, index, quantity;\n\n  if (!common.isObject(source)) {\n    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n  }\n\n  sourceKeys = Object.keys(source);\n\n  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n    key = sourceKeys[index];\n\n    if (!_hasOwnProperty.call(destination, key)) {\n      destination[key] = source[key];\n      overridableKeys[key] = true;\n    }\n  }\n}\n\nfunction storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,\n  startLine, startLineStart, startPos) {\n\n  var index, quantity;\n\n  // The output is a plain object here, so keys can only be strings.\n  // We need to convert keyNode to a string, but doing so can hang the process\n  // (deeply nested arrays that explode exponentially using aliases).\n  if (Array.isArray(keyNode)) {\n    keyNode = Array.prototype.slice.call(keyNode);\n\n    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n      if (Array.isArray(keyNode[index])) {\n        throwError(state, 'nested arrays are not supported inside keys');\n      }\n\n      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n        keyNode[index] = '[object Object]';\n      }\n    }\n  }\n\n  // Avoid code execution in load() via toString property\n  // (still use its own toString for arrays, timestamps,\n  // and whatever user schema extensions happen to have @@toStringTag)\n  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n    keyNode = '[object Object]';\n  }\n\n\n  keyNode = String(keyNode);\n\n  if (_result === null) {\n    _result = {};\n  }\n\n  if (keyTag === 'tag:yaml.org,2002:merge') {\n    if (Array.isArray(valueNode)) {\n      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n        mergeMappings(state, _result, valueNode[index], overridableKeys);\n      }\n    } else {\n      mergeMappings(state, _result, valueNode, overridableKeys);\n    }\n  } else {\n    if (!state.json &&\n        !_hasOwnProperty.call(overridableKeys, keyNode) &&\n        _hasOwnProperty.call(_result, keyNode)) {\n      state.line = startLine || state.line;\n      state.lineStart = startLineStart || state.lineStart;\n      state.position = startPos || state.position;\n      throwError(state, 'duplicated mapping key');\n    }\n\n    // used for this specific key only because Object.defineProperty is slow\n    if (keyNode === '__proto__') {\n      Object.defineProperty(_result, keyNode, {\n        configurable: true,\n        enumerable: true,\n        writable: true,\n        value: valueNode\n      });\n    } else {\n      _result[keyNode] = valueNode;\n    }\n    delete overridableKeys[keyNode];\n  }\n\n  return _result;\n}\n\nfunction readLineBreak(state) {\n  var ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x0A/* LF */) {\n    state.position++;\n  } else if (ch === 0x0D/* CR */) {\n    state.position++;\n    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {\n      state.position++;\n    }\n  } else {\n    throwError(state, 'a line break is expected');\n  }\n\n  state.line += 1;\n  state.lineStart = state.position;\n  state.firstTabInLine = -1;\n}\n\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\n  var lineBreaks = 0,\n      ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    while (is_WHITE_SPACE(ch)) {\n      if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {\n        state.firstTabInLine = state.position;\n      }\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (allowComments && ch === 0x23/* # */) {\n      do {\n        ch = state.input.charCodeAt(++state.position);\n      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);\n    }\n\n    if (is_EOL(ch)) {\n      readLineBreak(state);\n\n      ch = state.input.charCodeAt(state.position);\n      lineBreaks++;\n      state.lineIndent = 0;\n\n      while (ch === 0x20/* Space */) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n    throwWarning(state, 'deficient indentation');\n  }\n\n  return lineBreaks;\n}\n\nfunction testDocumentSeparator(state) {\n  var _position = state.position,\n      ch;\n\n  ch = state.input.charCodeAt(_position);\n\n  // Condition state.position === state.lineStart is tested\n  // in parent on each call, for efficiency. No needs to test here again.\n  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&\n      ch === state.input.charCodeAt(_position + 1) &&\n      ch === state.input.charCodeAt(_position + 2)) {\n\n    _position += 3;\n\n    ch = state.input.charCodeAt(_position);\n\n    if (ch === 0 || is_WS_OR_EOL(ch)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction writeFoldedLines(state, count) {\n  if (count === 1) {\n    state.result += ' ';\n  } else if (count > 1) {\n    state.result += common.repeat('\\n', count - 1);\n  }\n}\n\n\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\n  var preceding,\n      following,\n      captureStart,\n      captureEnd,\n      hasPendingContent,\n      _line,\n      _lineStart,\n      _lineIndent,\n      _kind = state.kind,\n      _result = state.result,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (is_WS_OR_EOL(ch)      ||\n      is_FLOW_INDICATOR(ch) ||\n      ch === 0x23/* # */    ||\n      ch === 0x26/* & */    ||\n      ch === 0x2A/* * */    ||\n      ch === 0x21/* ! */    ||\n      ch === 0x7C/* | */    ||\n      ch === 0x3E/* > */    ||\n      ch === 0x27/* ' */    ||\n      ch === 0x22/* \" */    ||\n      ch === 0x25/* % */    ||\n      ch === 0x40/* @ */    ||\n      ch === 0x60/* ` */) {\n    return false;\n  }\n\n  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (is_WS_OR_EOL(following) ||\n        withinFlowCollection && is_FLOW_INDICATOR(following)) {\n      return false;\n    }\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  captureStart = captureEnd = state.position;\n  hasPendingContent = false;\n\n  while (ch !== 0) {\n    if (ch === 0x3A/* : */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following) ||\n          withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        break;\n      }\n\n    } else if (ch === 0x23/* # */) {\n      preceding = state.input.charCodeAt(state.position - 1);\n\n      if (is_WS_OR_EOL(preceding)) {\n        break;\n      }\n\n    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||\n               withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n      break;\n\n    } else if (is_EOL(ch)) {\n      _line = state.line;\n      _lineStart = state.lineStart;\n      _lineIndent = state.lineIndent;\n      skipSeparationSpace(state, false, -1);\n\n      if (state.lineIndent >= nodeIndent) {\n        hasPendingContent = true;\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      } else {\n        state.position = captureEnd;\n        state.line = _line;\n        state.lineStart = _lineStart;\n        state.lineIndent = _lineIndent;\n        break;\n      }\n    }\n\n    if (hasPendingContent) {\n      captureSegment(state, captureStart, captureEnd, false);\n      writeFoldedLines(state, state.line - _line);\n      captureStart = captureEnd = state.position;\n      hasPendingContent = false;\n    }\n\n    if (!is_WHITE_SPACE(ch)) {\n      captureEnd = state.position + 1;\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  captureSegment(state, captureStart, captureEnd, false);\n\n  if (state.result) {\n    return true;\n  }\n\n  state.kind = _kind;\n  state.result = _result;\n  return false;\n}\n\nfunction readSingleQuotedScalar(state, nodeIndent) {\n  var ch,\n      captureStart, captureEnd;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x27/* ' */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x27/* ' */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (ch === 0x27/* ' */) {\n        captureStart = state.position;\n        state.position++;\n        captureEnd = state.position;\n      } else {\n        return true;\n      }\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a single quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a single quoted scalar');\n}\n\nfunction readDoubleQuotedScalar(state, nodeIndent) {\n  var captureStart,\n      captureEnd,\n      hexLength,\n      hexResult,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x22/* \" */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x22/* \" */) {\n      captureSegment(state, captureStart, state.position, true);\n      state.position++;\n      return true;\n\n    } else if (ch === 0x5C/* \\ */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (is_EOL(ch)) {\n        skipSeparationSpace(state, false, nodeIndent);\n\n        // TODO: rework to inline fn with no type cast?\n      } else if (ch < 256 && simpleEscapeCheck[ch]) {\n        state.result += simpleEscapeMap[ch];\n        state.position++;\n\n      } else if ((tmp = escapedHexLen(ch)) > 0) {\n        hexLength = tmp;\n        hexResult = 0;\n\n        for (; hexLength > 0; hexLength--) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if ((tmp = fromHexCode(ch)) >= 0) {\n            hexResult = (hexResult << 4) + tmp;\n\n          } else {\n            throwError(state, 'expected hexadecimal character');\n          }\n        }\n\n        state.result += charFromCodepoint(hexResult);\n\n        state.position++;\n\n      } else {\n        throwError(state, 'unknown escape sequence');\n      }\n\n      captureStart = captureEnd = state.position;\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a double quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a double quoted scalar');\n}\n\nfunction readFlowCollection(state, nodeIndent) {\n  var readNext = true,\n      _line,\n      _lineStart,\n      _pos,\n      _tag     = state.tag,\n      _result,\n      _anchor  = state.anchor,\n      following,\n      terminator,\n      isPair,\n      isExplicitPair,\n      isMapping,\n      overridableKeys = Object.create(null),\n      keyNode,\n      keyTag,\n      valueNode,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x5B/* [ */) {\n    terminator = 0x5D;/* ] */\n    isMapping = false;\n    _result = [];\n  } else if (ch === 0x7B/* { */) {\n    terminator = 0x7D;/* } */\n    isMapping = true;\n    _result = {};\n  } else {\n    return false;\n  }\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  while (ch !== 0) {\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === terminator) {\n      state.position++;\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = isMapping ? 'mapping' : 'sequence';\n      state.result = _result;\n      return true;\n    } else if (!readNext) {\n      throwError(state, 'missed comma between flow collection entries');\n    } else if (ch === 0x2C/* , */) {\n      // \"flow collection entries can never be completely empty\", as per YAML 1.2, section 7.4\n      throwError(state, \"expected the node content, but found ','\");\n    }\n\n    keyTag = keyNode = valueNode = null;\n    isPair = isExplicitPair = false;\n\n    if (ch === 0x3F/* ? */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following)) {\n        isPair = isExplicitPair = true;\n        state.position++;\n        skipSeparationSpace(state, true, nodeIndent);\n      }\n    }\n\n    _line = state.line; // Save the current line.\n    _lineStart = state.lineStart;\n    _pos = state.position;\n    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n    keyTag = state.tag;\n    keyNode = state.result;\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {\n      isPair = true;\n      ch = state.input.charCodeAt(++state.position);\n      skipSeparationSpace(state, true, nodeIndent);\n      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n      valueNode = state.result;\n    }\n\n    if (isMapping) {\n      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);\n    } else if (isPair) {\n      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));\n    } else {\n      _result.push(keyNode);\n    }\n\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x2C/* , */) {\n      readNext = true;\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      readNext = false;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a flow collection');\n}\n\nfunction readBlockScalar(state, nodeIndent) {\n  var captureStart,\n      folding,\n      chomping       = CHOMPING_CLIP,\n      didReadContent = false,\n      detectedIndent = false,\n      textIndent     = nodeIndent,\n      emptyLines     = 0,\n      atMoreIndented = false,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x7C/* | */) {\n    folding = false;\n  } else if (ch === 0x3E/* > */) {\n    folding = true;\n  } else {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n\n  while (ch !== 0) {\n    ch = state.input.charCodeAt(++state.position);\n\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      if (CHOMPING_CLIP === chomping) {\n        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;\n      } else {\n        throwError(state, 'repeat of a chomping mode identifier');\n      }\n\n    } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n      if (tmp === 0) {\n        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n      } else if (!detectedIndent) {\n        textIndent = nodeIndent + tmp - 1;\n        detectedIndent = true;\n      } else {\n        throwError(state, 'repeat of an indentation width identifier');\n      }\n\n    } else {\n      break;\n    }\n  }\n\n  if (is_WHITE_SPACE(ch)) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (is_WHITE_SPACE(ch));\n\n    if (ch === 0x23/* # */) {\n      do { ch = state.input.charCodeAt(++state.position); }\n      while (!is_EOL(ch) && (ch !== 0));\n    }\n  }\n\n  while (ch !== 0) {\n    readLineBreak(state);\n    state.lineIndent = 0;\n\n    ch = state.input.charCodeAt(state.position);\n\n    while ((!detectedIndent || state.lineIndent < textIndent) &&\n           (ch === 0x20/* Space */)) {\n      state.lineIndent++;\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (!detectedIndent && state.lineIndent > textIndent) {\n      textIndent = state.lineIndent;\n    }\n\n    if (is_EOL(ch)) {\n      emptyLines++;\n      continue;\n    }\n\n    // End of the scalar.\n    if (state.lineIndent < textIndent) {\n\n      // Perform the chomping.\n      if (chomping === CHOMPING_KEEP) {\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n      } else if (chomping === CHOMPING_CLIP) {\n        if (didReadContent) { // i.e. only if the scalar is not empty.\n          state.result += '\\n';\n        }\n      }\n\n      // Break this `while` cycle and go to the funciton's epilogue.\n      break;\n    }\n\n    // Folded style: use fancy rules to handle line breaks.\n    if (folding) {\n\n      // Lines starting with white space characters (more-indented lines) are not folded.\n      if (is_WHITE_SPACE(ch)) {\n        atMoreIndented = true;\n        // except for the first content line (cf. Example 8.1)\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n\n      // End of more-indented block.\n      } else if (atMoreIndented) {\n        atMoreIndented = false;\n        state.result += common.repeat('\\n', emptyLines + 1);\n\n      // Just one line break - perceive as the same line.\n      } else if (emptyLines === 0) {\n        if (didReadContent) { // i.e. only if we have already read some scalar content.\n          state.result += ' ';\n        }\n\n      // Several line breaks - perceive as different lines.\n      } else {\n        state.result += common.repeat('\\n', emptyLines);\n      }\n\n    // Literal style: just add exact number of line breaks between content lines.\n    } else {\n      // Keep all line breaks except the header line break.\n      state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n    }\n\n    didReadContent = true;\n    detectedIndent = true;\n    emptyLines = 0;\n    captureStart = state.position;\n\n    while (!is_EOL(ch) && (ch !== 0)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    captureSegment(state, captureStart, state.position, false);\n  }\n\n  return true;\n}\n\nfunction readBlockSequence(state, nodeIndent) {\n  var _line,\n      _tag      = state.tag,\n      _anchor   = state.anchor,\n      _result   = [],\n      following,\n      detected  = false,\n      ch;\n\n  // there is a leading tab before this token, so it can't be a block sequence/mapping;\n  // it can still be flow sequence/mapping or a scalar\n  if (state.firstTabInLine !== -1) return false;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, 'tab characters must not be used in indentation');\n    }\n\n    if (ch !== 0x2D/* - */) {\n      break;\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (!is_WS_OR_EOL(following)) {\n      break;\n    }\n\n    detected = true;\n    state.position++;\n\n    if (skipSeparationSpace(state, true, -1)) {\n      if (state.lineIndent <= nodeIndent) {\n        _result.push(null);\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n    _result.push(state.result);\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a sequence entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'sequence';\n    state.result = _result;\n    return true;\n  }\n  return false;\n}\n\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\n  var following,\n      allowCompact,\n      _line,\n      _keyLine,\n      _keyLineStart,\n      _keyPos,\n      _tag          = state.tag,\n      _anchor       = state.anchor,\n      _result       = {},\n      overridableKeys = Object.create(null),\n      keyTag        = null,\n      keyNode       = null,\n      valueNode     = null,\n      atExplicitKey = false,\n      detected      = false,\n      ch;\n\n  // there is a leading tab before this token, so it can't be a block sequence/mapping;\n  // it can still be flow sequence/mapping or a scalar\n  if (state.firstTabInLine !== -1) return false;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (!atExplicitKey && state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, 'tab characters must not be used in indentation');\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n    _line = state.line; // Save the current line.\n\n    //\n    // Explicit notation case. There are two separate blocks:\n    // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n    //\n    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {\n\n      if (ch === 0x3F/* ? */) {\n        if (atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n          keyTag = keyNode = valueNode = null;\n        }\n\n        detected = true;\n        atExplicitKey = true;\n        allowCompact = true;\n\n      } else if (atExplicitKey) {\n        // i.e. 0x3A/* : */ === character after the explicit key.\n        atExplicitKey = false;\n        allowCompact = true;\n\n      } else {\n        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n      }\n\n      state.position += 1;\n      ch = following;\n\n    //\n    // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n    //\n    } else {\n      _keyLine = state.line;\n      _keyLineStart = state.lineStart;\n      _keyPos = state.position;\n\n      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n        // Neither implicit nor explicit notation.\n        // Reading is done. Go to the epilogue.\n        break;\n      }\n\n      if (state.line === _line) {\n        ch = state.input.charCodeAt(state.position);\n\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (ch === 0x3A/* : */) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if (!is_WS_OR_EOL(ch)) {\n            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n          }\n\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n            keyTag = keyNode = valueNode = null;\n          }\n\n          detected = true;\n          atExplicitKey = false;\n          allowCompact = false;\n          keyTag = state.tag;\n          keyNode = state.result;\n\n        } else if (detected) {\n          throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true; // Keep the result of `composeNode`.\n        }\n\n      } else if (detected) {\n        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n\n      } else {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        return true; // Keep the result of `composeNode`.\n      }\n    }\n\n    //\n    // Common reading code for both explicit and implicit notations.\n    //\n    if (state.line === _line || state.lineIndent > nodeIndent) {\n      if (atExplicitKey) {\n        _keyLine = state.line;\n        _keyLineStart = state.lineStart;\n        _keyPos = state.position;\n      }\n\n      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n        if (atExplicitKey) {\n          keyNode = state.result;\n        } else {\n          valueNode = state.result;\n        }\n      }\n\n      if (!atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);\n        keyTag = keyNode = valueNode = null;\n      }\n\n      skipSeparationSpace(state, true, -1);\n      ch = state.input.charCodeAt(state.position);\n    }\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a mapping entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  //\n  // Epilogue.\n  //\n\n  // Special case: last mapping's node contains only the key in explicit notation.\n  if (atExplicitKey) {\n    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n  }\n\n  // Expose the resulting mapping.\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'mapping';\n    state.result = _result;\n  }\n\n  return detected;\n}\n\nfunction readTagProperty(state) {\n  var _position,\n      isVerbatim = false,\n      isNamed    = false,\n      tagHandle,\n      tagName,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x21/* ! */) return false;\n\n  if (state.tag !== null) {\n    throwError(state, 'duplication of a tag property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  if (ch === 0x3C/* < */) {\n    isVerbatim = true;\n    ch = state.input.charCodeAt(++state.position);\n\n  } else if (ch === 0x21/* ! */) {\n    isNamed = true;\n    tagHandle = '!!';\n    ch = state.input.charCodeAt(++state.position);\n\n  } else {\n    tagHandle = '!';\n  }\n\n  _position = state.position;\n\n  if (isVerbatim) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (ch !== 0 && ch !== 0x3E/* > */);\n\n    if (state.position < state.length) {\n      tagName = state.input.slice(_position, state.position);\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      throwError(state, 'unexpected end of the stream within a verbatim tag');\n    }\n  } else {\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n\n      if (ch === 0x21/* ! */) {\n        if (!isNamed) {\n          tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n            throwError(state, 'named tag handle cannot contain such characters');\n          }\n\n          isNamed = true;\n          _position = state.position + 1;\n        } else {\n          throwError(state, 'tag suffix cannot contain exclamation marks');\n        }\n      }\n\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    tagName = state.input.slice(_position, state.position);\n\n    if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n      throwError(state, 'tag suffix cannot contain flow indicator characters');\n    }\n  }\n\n  if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n    throwError(state, 'tag name cannot contain such characters: ' + tagName);\n  }\n\n  try {\n    tagName = decodeURIComponent(tagName);\n  } catch (err) {\n    throwError(state, 'tag name is malformed: ' + tagName);\n  }\n\n  if (isVerbatim) {\n    state.tag = tagName;\n\n  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {\n    state.tag = state.tagMap[tagHandle] + tagName;\n\n  } else if (tagHandle === '!') {\n    state.tag = '!' + tagName;\n\n  } else if (tagHandle === '!!') {\n    state.tag = 'tag:yaml.org,2002:' + tagName;\n\n  } else {\n    throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n  }\n\n  return true;\n}\n\nfunction readAnchorProperty(state) {\n  var _position,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x26/* & */) return false;\n\n  if (state.anchor !== null) {\n    throwError(state, 'duplication of an anchor property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an anchor node must contain at least one character');\n  }\n\n  state.anchor = state.input.slice(_position, state.position);\n  return true;\n}\n\nfunction readAlias(state) {\n  var _position, alias,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x2A/* * */) return false;\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an alias node must contain at least one character');\n  }\n\n  alias = state.input.slice(_position, state.position);\n\n  if (!_hasOwnProperty.call(state.anchorMap, alias)) {\n    throwError(state, 'unidentified alias \"' + alias + '\"');\n  }\n\n  state.result = state.anchorMap[alias];\n  skipSeparationSpace(state, true, -1);\n  return true;\n}\n\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n  var allowBlockStyles,\n      allowBlockScalars,\n      allowBlockCollections,\n      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent\n      atNewLine  = false,\n      hasContent = false,\n      typeIndex,\n      typeQuantity,\n      typeList,\n      type,\n      flowIndent,\n      blockIndent;\n\n  if (state.listener !== null) {\n    state.listener('open', state);\n  }\n\n  state.tag    = null;\n  state.anchor = null;\n  state.kind   = null;\n  state.result = null;\n\n  allowBlockStyles = allowBlockScalars = allowBlockCollections =\n    CONTEXT_BLOCK_OUT === nodeContext ||\n    CONTEXT_BLOCK_IN  === nodeContext;\n\n  if (allowToSeek) {\n    if (skipSeparationSpace(state, true, -1)) {\n      atNewLine = true;\n\n      if (state.lineIndent > parentIndent) {\n        indentStatus = 1;\n      } else if (state.lineIndent === parentIndent) {\n        indentStatus = 0;\n      } else if (state.lineIndent < parentIndent) {\n        indentStatus = -1;\n      }\n    }\n  }\n\n  if (indentStatus === 1) {\n    while (readTagProperty(state) || readAnchorProperty(state)) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n        allowBlockCollections = allowBlockStyles;\n\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      } else {\n        allowBlockCollections = false;\n      }\n    }\n  }\n\n  if (allowBlockCollections) {\n    allowBlockCollections = atNewLine || allowCompact;\n  }\n\n  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n      flowIndent = parentIndent;\n    } else {\n      flowIndent = parentIndent + 1;\n    }\n\n    blockIndent = state.position - state.lineStart;\n\n    if (indentStatus === 1) {\n      if (allowBlockCollections &&\n          (readBlockSequence(state, blockIndent) ||\n           readBlockMapping(state, blockIndent, flowIndent)) ||\n          readFlowCollection(state, flowIndent)) {\n        hasContent = true;\n      } else {\n        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||\n            readSingleQuotedScalar(state, flowIndent) ||\n            readDoubleQuotedScalar(state, flowIndent)) {\n          hasContent = true;\n\n        } else if (readAlias(state)) {\n          hasContent = true;\n\n          if (state.tag !== null || state.anchor !== null) {\n            throwError(state, 'alias node should not have any properties');\n          }\n\n        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n          hasContent = true;\n\n          if (state.tag === null) {\n            state.tag = '?';\n          }\n        }\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else if (indentStatus === 0) {\n      // Special case: block sequences are allowed to have same indentation level as the parent.\n      // http://www.yaml.org/spec/1.2/spec.html#id2799784\n      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n    }\n  }\n\n  if (state.tag === null) {\n    if (state.anchor !== null) {\n      state.anchorMap[state.anchor] = state.result;\n    }\n\n  } else if (state.tag === '?') {\n    // Implicit resolving is not allowed for non-scalar types, and '?'\n    // non-specific tag is only automatically assigned to plain scalars.\n    //\n    // We only need to check kind conformity in case user explicitly assigns '?'\n    // tag, for example like this: \"!<?> [0]\"\n    //\n    if (state.result !== null && state.kind !== 'scalar') {\n      throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n    }\n\n    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n      type = state.implicitTypes[typeIndex];\n\n      if (type.resolve(state.result)) { // `state.result` updated in resolver if matched\n        state.result = type.construct(state.result);\n        state.tag = type.tag;\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n        break;\n      }\n    }\n  } else if (state.tag !== '!') {\n    if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n      type = state.typeMap[state.kind || 'fallback'][state.tag];\n    } else {\n      // looking for multi type\n      type = null;\n      typeList = state.typeMap.multi[state.kind || 'fallback'];\n\n      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {\n        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {\n          type = typeList[typeIndex];\n          break;\n        }\n      }\n    }\n\n    if (!type) {\n      throwError(state, 'unknown tag !<' + state.tag + '>');\n    }\n\n    if (state.result !== null && type.kind !== state.kind) {\n      throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n    }\n\n    if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched\n      throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n    } else {\n      state.result = type.construct(state.result, state.tag);\n      if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = state.result;\n      }\n    }\n  }\n\n  if (state.listener !== null) {\n    state.listener('close', state);\n  }\n  return state.tag !== null ||  state.anchor !== null || hasContent;\n}\n\nfunction readDocument(state) {\n  var documentStart = state.position,\n      _position,\n      directiveName,\n      directiveArgs,\n      hasDirectives = false,\n      ch;\n\n  state.version = null;\n  state.checkLineBreaks = state.legacy;\n  state.tagMap = Object.create(null);\n  state.anchorMap = Object.create(null);\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (state.lineIndent > 0 || ch !== 0x25/* % */) {\n      break;\n    }\n\n    hasDirectives = true;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    directiveName = state.input.slice(_position, state.position);\n    directiveArgs = [];\n\n    if (directiveName.length < 1) {\n      throwError(state, 'directive name must not be less than one character in length');\n    }\n\n    while (ch !== 0) {\n      while (is_WHITE_SPACE(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (ch === 0x23/* # */) {\n        do { ch = state.input.charCodeAt(++state.position); }\n        while (ch !== 0 && !is_EOL(ch));\n        break;\n      }\n\n      if (is_EOL(ch)) break;\n\n      _position = state.position;\n\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      directiveArgs.push(state.input.slice(_position, state.position));\n    }\n\n    if (ch !== 0) readLineBreak(state);\n\n    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {\n      directiveHandlers[directiveName](state, directiveName, directiveArgs);\n    } else {\n      throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n    }\n  }\n\n  skipSeparationSpace(state, true, -1);\n\n  if (state.lineIndent === 0 &&\n      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {\n    state.position += 3;\n    skipSeparationSpace(state, true, -1);\n\n  } else if (hasDirectives) {\n    throwError(state, 'directives end mark is expected');\n  }\n\n  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n  skipSeparationSpace(state, true, -1);\n\n  if (state.checkLineBreaks &&\n      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n    throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n  }\n\n  state.documents.push(state.result);\n\n  if (state.position === state.lineStart && testDocumentSeparator(state)) {\n\n    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n    }\n    return;\n  }\n\n  if (state.position < (state.length - 1)) {\n    throwError(state, 'end of the stream or a document separator is expected');\n  } else {\n    return;\n  }\n}\n\n\nfunction loadDocuments(input, options) {\n  input = String(input);\n  options = options || {};\n\n  if (input.length !== 0) {\n\n    // Add tailing `\\n` if not exists\n    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&\n        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {\n      input += '\\n';\n    }\n\n    // Strip BOM\n    if (input.charCodeAt(0) === 0xFEFF) {\n      input = input.slice(1);\n    }\n  }\n\n  var state = new State(input, options);\n\n  var nullpos = input.indexOf('\\0');\n\n  if (nullpos !== -1) {\n    state.position = nullpos;\n    throwError(state, 'null byte is not allowed in input');\n  }\n\n  // Use 0 as string terminator. That significantly simplifies bounds check.\n  state.input += '\\0';\n\n  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {\n    state.lineIndent += 1;\n    state.position += 1;\n  }\n\n  while (state.position < (state.length - 1)) {\n    readDocument(state);\n  }\n\n  return state.documents;\n}\n\n\nfunction loadAll(input, iterator, options) {\n  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  var documents = loadDocuments(input, options);\n\n  if (typeof iterator !== 'function') {\n    return documents;\n  }\n\n  for (var index = 0, length = documents.length; index < length; index += 1) {\n    iterator(documents[index]);\n  }\n}\n\n\nfunction load(input, options) {\n  var documents = loadDocuments(input, options);\n\n  if (documents.length === 0) {\n    /*eslint-disable no-undefined*/\n    return undefined;\n  } else if (documents.length === 1) {\n    return documents[0];\n  }\n  throw new YAMLException('expected a single document in the stream, but found more');\n}\n\n\nmodule.exports.loadAll = loadAll;\nmodule.exports.load    = load;\n","'use strict';\n\n/*eslint-disable max-len*/\n\nvar YAMLException = require('./exception');\nvar Type          = require('./type');\n\n\nfunction compileList(schema, name, result) {\n  var exclude = [];\n\n  schema[name].forEach(function (currentType) {\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag &&\n          previousType.kind === currentType.kind &&\n          previousType.multi === currentType.multi) {\n\n        exclude.push(previousIndex);\n      }\n    });\n\n    result.push(currentType);\n  });\n\n  return result.filter(function (type, index) {\n    return exclude.indexOf(index) === -1;\n  });\n}\n\n\nfunction compileMap(/* lists... */) {\n  var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {},\n        multi: {\n          scalar: [],\n          sequence: [],\n          mapping: [],\n          fallback: []\n        }\n      }, index, length;\n\n  function collectType(type) {\n    if (type.multi) {\n      result.multi[type.kind].push(type);\n      result.multi['fallback'].push(type);\n    } else {\n      result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n    }\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n  return result;\n}\n\n\nfunction Schema(definition) {\n  return this.extend(definition);\n}\n\n\nSchema.prototype.extend = function extend(definition) {\n  var implicit = [];\n  var explicit = [];\n\n  if (definition instanceof Type) {\n    // Schema.extend(type)\n    explicit.push(definition);\n\n  } else if (Array.isArray(definition)) {\n    // Schema.extend([ type1, type2, ... ])\n    explicit = explicit.concat(definition);\n\n  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {\n    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })\n    if (definition.implicit) implicit = implicit.concat(definition.implicit);\n    if (definition.explicit) explicit = explicit.concat(definition.explicit);\n\n  } else {\n    throw new YAMLException('Schema.extend argument should be a Type, [ Type ], ' +\n      'or a schema definition ({ implicit: [...], explicit: [...] })');\n  }\n\n  implicit.forEach(function (type) {\n    if (!(type instanceof Type)) {\n      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n\n    if (type.loadKind && type.loadKind !== 'scalar') {\n      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n\n    if (type.multi) {\n      throw new YAMLException('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');\n    }\n  });\n\n  explicit.forEach(function (type) {\n    if (!(type instanceof Type)) {\n      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n  });\n\n  var result = Object.create(Schema.prototype);\n\n  result.implicit = (this.implicit || []).concat(implicit);\n  result.explicit = (this.explicit || []).concat(explicit);\n\n  result.compiledImplicit = compileList(result, 'implicit', []);\n  result.compiledExplicit = compileList(result, 'explicit', []);\n  result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);\n\n  return result;\n};\n\n\nmodule.exports = Schema;\n","// Standard YAML's Core schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2804923\n//\n// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n// So, Core schema has no distinctions from JSON schema is JS-YAML.\n\n\n'use strict';\n\n\nmodule.exports = require('./json');\n","// JS-YAML's default schema for `safeLoad` function.\n// It is not described in the YAML specification.\n//\n// This schema is based on standard YAML's Core schema and includes most of\n// extra types described at YAML tag repository. (http://yaml.org/type/)\n\n\n'use strict';\n\n\nmodule.exports = require('./core').extend({\n  implicit: [\n    require('../type/timestamp'),\n    require('../type/merge')\n  ],\n  explicit: [\n    require('../type/binary'),\n    require('../type/omap'),\n    require('../type/pairs'),\n    require('../type/set')\n  ]\n});\n","// Standard YAML's Failsafe schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2802346\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  explicit: [\n    require('../type/str'),\n    require('../type/seq'),\n    require('../type/map')\n  ]\n});\n","// Standard YAML's JSON schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2803231\n//\n// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n// So, this schema is not such strict as defined in the YAML specification.\n// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.\n\n\n'use strict';\n\n\nmodule.exports = require('./failsafe').extend({\n  implicit: [\n    require('../type/null'),\n    require('../type/bool'),\n    require('../type/int'),\n    require('../type/float')\n  ]\n});\n","'use strict';\n\n\nvar common = require('./common');\n\n\n// get snippet for a single line, respecting maxLength\nfunction getLine(buffer, lineStart, lineEnd, position, maxLineLength) {\n  var head = '';\n  var tail = '';\n  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;\n\n  if (position - lineStart > maxHalfLength) {\n    head = ' ... ';\n    lineStart = position - maxHalfLength + head.length;\n  }\n\n  if (lineEnd - position > maxHalfLength) {\n    tail = ' ...';\n    lineEnd = position + maxHalfLength - tail.length;\n  }\n\n  return {\n    str: head + buffer.slice(lineStart, lineEnd).replace(/\\t/g, '→') + tail,\n    pos: position - lineStart + head.length // relative position\n  };\n}\n\n\nfunction padStart(string, max) {\n  return common.repeat(' ', max - string.length) + string;\n}\n\n\nfunction makeSnippet(mark, options) {\n  options = Object.create(options || null);\n\n  if (!mark.buffer) return null;\n\n  if (!options.maxLength) options.maxLength = 79;\n  if (typeof options.indent      !== 'number') options.indent      = 1;\n  if (typeof options.linesBefore !== 'number') options.linesBefore = 3;\n  if (typeof options.linesAfter  !== 'number') options.linesAfter  = 2;\n\n  var re = /\\r?\\n|\\r|\\0/g;\n  var lineStarts = [ 0 ];\n  var lineEnds = [];\n  var match;\n  var foundLineNo = -1;\n\n  while ((match = re.exec(mark.buffer))) {\n    lineEnds.push(match.index);\n    lineStarts.push(match.index + match[0].length);\n\n    if (mark.position <= match.index && foundLineNo < 0) {\n      foundLineNo = lineStarts.length - 2;\n    }\n  }\n\n  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;\n\n  var result = '', i, line;\n  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;\n  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);\n\n  for (i = 1; i <= options.linesBefore; i++) {\n    if (foundLineNo - i < 0) break;\n    line = getLine(\n      mark.buffer,\n      lineStarts[foundLineNo - i],\n      lineEnds[foundLineNo - i],\n      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),\n      maxLineLength\n    );\n    result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +\n      ' | ' + line.str + '\\n' + result;\n  }\n\n  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);\n  result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +\n    ' | ' + line.str + '\\n';\n  result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\\n';\n\n  for (i = 1; i <= options.linesAfter; i++) {\n    if (foundLineNo + i >= lineEnds.length) break;\n    line = getLine(\n      mark.buffer,\n      lineStarts[foundLineNo + i],\n      lineEnds[foundLineNo + i],\n      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),\n      maxLineLength\n    );\n    result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +\n      ' | ' + line.str + '\\n';\n  }\n\n  return result.replace(/\\n$/, '');\n}\n\n\nmodule.exports = makeSnippet;\n","'use strict';\n\nvar YAMLException = require('./exception');\n\nvar TYPE_CONSTRUCTOR_OPTIONS = [\n  'kind',\n  'multi',\n  'resolve',\n  'construct',\n  'instanceOf',\n  'predicate',\n  'represent',\n  'representName',\n  'defaultStyle',\n  'styleAliases'\n];\n\nvar YAML_NODE_KINDS = [\n  'scalar',\n  'sequence',\n  'mapping'\n];\n\nfunction compileStyleAliases(map) {\n  var result = {};\n\n  if (map !== null) {\n    Object.keys(map).forEach(function (style) {\n      map[style].forEach(function (alias) {\n        result[String(alias)] = style;\n      });\n    });\n  }\n\n  return result;\n}\n\nfunction Type(tag, options) {\n  options = options || {};\n\n  Object.keys(options).forEach(function (name) {\n    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n      throw new YAMLException('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n    }\n  });\n\n  // TODO: Add tag format check.\n  this.tag           = tag;\n  this.kind          = options['kind']          || null;\n  this.resolve       = options['resolve']       || function () { return true; };\n  this.construct     = options['construct']     || function (data) { return data; };\n  this.instanceOf    = options['instanceOf']    || null;\n  this.predicate     = options['predicate']     || null;\n  this.represent     = options['represent']     || null;\n  this.representName = options['representName'] || null;\n  this.defaultStyle  = options['defaultStyle']  || null;\n  this.multi         = options['multi']         || false;\n  this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);\n\n  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n    throw new YAMLException('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n  }\n}\n\nmodule.exports = Type;\n","'use strict';\n\n/*eslint-disable no-bitwise*/\n\n\nvar Type = require('../type');\n\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n\n  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) continue;\n\n    // Fail on illegal characters\n    if (code < 0) return false;\n\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return (bitlen % 8) === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx, tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      result.push((bits >> 16) & 0xFF);\n      result.push((bits >> 8) & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = (bits << 6) | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    result.push((bits >> 16) & 0xFF);\n    result.push((bits >> 8) & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push((bits >> 10) & 0xFF);\n    result.push((bits >> 2) & 0xFF);\n  } else if (tailbits === 12) {\n    result.push((bits >> 4) & 0xFF);\n  }\n\n  return new Uint8Array(result);\n}\n\nfunction representYamlBinary(object /*, style*/) {\n  var result = '', bits = 0, idx, tail,\n      max = object.length,\n      map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 3 === 0) && idx) {\n      result += map[(bits >> 18) & 0x3F];\n      result += map[(bits >> 12) & 0x3F];\n      result += map[(bits >> 6) & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[(bits >> 18) & 0x3F];\n    result += map[(bits >> 12) & 0x3F];\n    result += map[(bits >> 6) & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[(bits >> 10) & 0x3F];\n    result += map[(bits >> 4) & 0x3F];\n    result += map[(bits << 2) & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[(bits >> 2) & 0x3F];\n    result += map[(bits << 4) & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(obj) {\n  return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\n","'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlBoolean(data) {\n  if (data === null) return false;\n\n  var max = data.length;\n\n  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||\n         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));\n}\n\nfunction constructYamlBoolean(data) {\n  return data === 'true' ||\n         data === 'True' ||\n         data === 'TRUE';\n}\n\nfunction isBoolean(object) {\n  return Object.prototype.toString.call(object) === '[object Boolean]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:bool', {\n  kind: 'scalar',\n  resolve: resolveYamlBoolean,\n  construct: constructYamlBoolean,\n  predicate: isBoolean,\n  represent: {\n    lowercase: function (object) { return object ? 'true' : 'false'; },\n    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },\n    camelcase: function (object) { return object ? 'True' : 'False'; }\n  },\n  defaultStyle: 'lowercase'\n});\n","'use strict';\n\nvar common = require('../common');\nvar Type   = require('../type');\n\nvar YAML_FLOAT_PATTERN = new RegExp(\n  // 2.5e4, 2.5 and integers\n  '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\n  // .2e4, .2\n  // special case, seems not from spec\n  '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\n  // .inf\n  '|[-+]?\\\\.(?:inf|Inf|INF)' +\n  // .nan\n  '|\\\\.(?:nan|NaN|NAN))$');\n\nfunction resolveYamlFloat(data) {\n  if (data === null) return false;\n\n  if (!YAML_FLOAT_PATTERN.test(data) ||\n      // Quick hack to not allow integers end with `_`\n      // Probably should update regexp & check speed\n      data[data.length - 1] === '_') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlFloat(data) {\n  var value, sign;\n\n  value  = data.replace(/_/g, '').toLowerCase();\n  sign   = value[0] === '-' ? -1 : 1;\n\n  if ('+-'.indexOf(value[0]) >= 0) {\n    value = value.slice(1);\n  }\n\n  if (value === '.inf') {\n    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n  } else if (value === '.nan') {\n    return NaN;\n  }\n  return sign * parseFloat(value, 10);\n}\n\n\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\nfunction representYamlFloat(object, style) {\n  var res;\n\n  if (isNaN(object)) {\n    switch (style) {\n      case 'lowercase': return '.nan';\n      case 'uppercase': return '.NAN';\n      case 'camelcase': return '.NaN';\n    }\n  } else if (Number.POSITIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '.inf';\n      case 'uppercase': return '.INF';\n      case 'camelcase': return '.Inf';\n    }\n  } else if (Number.NEGATIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '-.inf';\n      case 'uppercase': return '-.INF';\n      case 'camelcase': return '-.Inf';\n    }\n  } else if (common.isNegativeZero(object)) {\n    return '-0.0';\n  }\n\n  res = object.toString(10);\n\n  // JS stringifier can build scientific format without dots: 5e-100,\n  // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n}\n\nfunction isFloat(object) {\n  return (Object.prototype.toString.call(object) === '[object Number]') &&\n         (object % 1 !== 0 || common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:float', {\n  kind: 'scalar',\n  resolve: resolveYamlFloat,\n  construct: constructYamlFloat,\n  predicate: isFloat,\n  represent: representYamlFloat,\n  defaultStyle: 'lowercase'\n});\n","'use strict';\n\nvar common = require('../common');\nvar Type   = require('../type');\n\nfunction isHexCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||\n         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||\n         ((0x61/* a */ <= c) && (c <= 0x66/* f */));\n}\n\nfunction isOctCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));\n}\n\nfunction isDecCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));\n}\n\nfunction resolveYamlInteger(data) {\n  if (data === null) return false;\n\n  var max = data.length,\n      index = 0,\n      hasDigits = false,\n      ch;\n\n  if (!max) return false;\n\n  ch = data[index];\n\n  // sign\n  if (ch === '-' || ch === '+') {\n    ch = data[++index];\n  }\n\n  if (ch === '0') {\n    // 0\n    if (index + 1 === max) return true;\n    ch = data[++index];\n\n    // base 2, base 8, base 16\n\n    if (ch === 'b') {\n      // base 2\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (ch !== '0' && ch !== '1') return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'x') {\n      // base 16\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isHexCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'o') {\n      // base 8\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isOctCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n  }\n\n  // base 10 (except 0)\n\n  // value should not start with `_`;\n  if (ch === '_') return false;\n\n  for (; index < max; index++) {\n    ch = data[index];\n    if (ch === '_') continue;\n    if (!isDecCode(data.charCodeAt(index))) {\n      return false;\n    }\n    hasDigits = true;\n  }\n\n  // Should have digits and should not end with `_`\n  if (!hasDigits || ch === '_') return false;\n\n  return true;\n}\n\nfunction constructYamlInteger(data) {\n  var value = data, sign = 1, ch;\n\n  if (value.indexOf('_') !== -1) {\n    value = value.replace(/_/g, '');\n  }\n\n  ch = value[0];\n\n  if (ch === '-' || ch === '+') {\n    if (ch === '-') sign = -1;\n    value = value.slice(1);\n    ch = value[0];\n  }\n\n  if (value === '0') return 0;\n\n  if (ch === '0') {\n    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n    if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);\n    if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);\n  }\n\n  return sign * parseInt(value, 10);\n}\n\nfunction isInteger(object) {\n  return (Object.prototype.toString.call(object)) === '[object Number]' &&\n         (object % 1 === 0 && !common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:int', {\n  kind: 'scalar',\n  resolve: resolveYamlInteger,\n  construct: constructYamlInteger,\n  predicate: isInteger,\n  represent: {\n    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },\n    octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },\n    decimal:     function (obj) { return obj.toString(10); },\n    /* eslint-disable max-len */\n    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }\n  },\n  defaultStyle: 'decimal',\n  styleAliases: {\n    binary:      [ 2,  'bin' ],\n    octal:       [ 8,  'oct' ],\n    decimal:     [ 10, 'dec' ],\n    hexadecimal: [ 16, 'hex' ]\n  }\n});\n","'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:map', {\n  kind: 'mapping',\n  construct: function (data) { return data !== null ? data : {}; }\n});\n","'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlMerge(data) {\n  return data === '<<' || data === null;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:merge', {\n  kind: 'scalar',\n  resolve: resolveYamlMerge\n});\n","'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlNull(data) {\n  if (data === null) return true;\n\n  var max = data.length;\n\n  return (max === 1 && data === '~') ||\n         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));\n}\n\nfunction constructYamlNull() {\n  return null;\n}\n\nfunction isNull(object) {\n  return object === null;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:null', {\n  kind: 'scalar',\n  resolve: resolveYamlNull,\n  construct: constructYamlNull,\n  predicate: isNull,\n  represent: {\n    canonical: function () { return '~';    },\n    lowercase: function () { return 'null'; },\n    uppercase: function () { return 'NULL'; },\n    camelcase: function () { return 'Null'; },\n    empty:     function () { return '';     }\n  },\n  defaultStyle: 'lowercase'\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar _toString       = Object.prototype.toString;\n\nfunction resolveYamlOmap(data) {\n  if (data === null) return true;\n\n  var objectKeys = [], index, length, pair, pairKey, pairHasKey,\n      object = data;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    pairHasKey = false;\n\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    for (pairKey in pair) {\n      if (_hasOwnProperty.call(pair, pairKey)) {\n        if (!pairHasKey) pairHasKey = true;\n        else return false;\n      }\n    }\n\n    if (!pairHasKey) return false;\n\n    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n    else return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlOmap(data) {\n  return data !== null ? data : [];\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:omap', {\n  kind: 'sequence',\n  resolve: resolveYamlOmap,\n  construct: constructYamlOmap\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar _toString = Object.prototype.toString;\n\nfunction resolveYamlPairs(data) {\n  if (data === null) return true;\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    keys = Object.keys(pair);\n\n    if (keys.length !== 1) return false;\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return true;\n}\n\nfunction constructYamlPairs(data) {\n  if (data === null) return [];\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    keys = Object.keys(pair);\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return result;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:pairs', {\n  kind: 'sequence',\n  resolve: resolveYamlPairs,\n  construct: constructYamlPairs\n});\n","'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:seq', {\n  kind: 'sequence',\n  construct: function (data) { return data !== null ? data : []; }\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction resolveYamlSet(data) {\n  if (data === null) return true;\n\n  var key, object = data;\n\n  for (key in object) {\n    if (_hasOwnProperty.call(object, key)) {\n      if (object[key] !== null) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constructYamlSet(data) {\n  return data !== null ? data : {};\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:set', {\n  kind: 'mapping',\n  resolve: resolveYamlSet,\n  construct: constructYamlSet\n});\n","'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:str', {\n  kind: 'scalar',\n  construct: function (data) { return data !== null ? data : ''; }\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar YAML_DATE_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9])'                    + // [2] month\n  '-([0-9][0-9])$');                   // [3] day\n\nvar YAML_TIMESTAMP_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9]?)'                   + // [2] month\n  '-([0-9][0-9]?)'                   + // [3] day\n  '(?:[Tt]|[ \\\\t]+)'                 + // ...\n  '([0-9][0-9]?)'                    + // [4] hour\n  ':([0-9][0-9])'                    + // [5] minute\n  ':([0-9][0-9])'                    + // [6] second\n  '(?:\\\\.([0-9]*))?'                 + // [7] fraction\n  '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute\n\nfunction resolveYamlTimestamp(data) {\n  if (data === null) return false;\n  if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n  return false;\n}\n\nfunction constructYamlTimestamp(data) {\n  var match, year, month, day, hour, minute, second, fraction = 0,\n      delta = null, tz_hour, tz_minute, date;\n\n  match = YAML_DATE_REGEXP.exec(data);\n  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n\n  if (match === null) throw new Error('Date resolve error');\n\n  // match: [1] year [2] month [3] day\n\n  year = +(match[1]);\n  month = +(match[2]) - 1; // JS month starts with 0\n  day = +(match[3]);\n\n  if (!match[4]) { // no hour\n    return new Date(Date.UTC(year, month, day));\n  }\n\n  // match: [4] hour [5] minute [6] second [7] fraction\n\n  hour = +(match[4]);\n  minute = +(match[5]);\n  second = +(match[6]);\n\n  if (match[7]) {\n    fraction = match[7].slice(0, 3);\n    while (fraction.length < 3) { // milli-seconds\n      fraction += '0';\n    }\n    fraction = +fraction;\n  }\n\n  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n  if (match[9]) {\n    tz_hour = +(match[10]);\n    tz_minute = +(match[11] || 0);\n    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n    if (match[9] === '-') delta = -delta;\n  }\n\n  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n\n  if (delta) date.setTime(date.getTime() - delta);\n\n  return date;\n}\n\nfunction representYamlTimestamp(object /*, style*/) {\n  return object.toISOString();\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:timestamp', {\n  kind: 'scalar',\n  resolve: resolveYamlTimestamp,\n  construct: constructYamlTimestamp,\n  instanceOf: Date,\n  represent: representYamlTimestamp\n});\n","// extracted by mini-css-extract-plugin\nexport {};",";(function inject(clean, precision, undef) {\n\n  var isArray = function (a) {\n    return Object.prototype.toString.call(a) === \"[object Array]\";\n  };\n\n  var defined = function(a) {\n    return a !== undef;\n  };\n\n  function Vec2(x, y) {\n    if (!(this instanceof Vec2)) {\n      return new Vec2(x, y);\n    }\n\n    if (isArray(x)) {\n      y = x[1];\n      x = x[0];\n    } else if('object' === typeof x && x) {\n      y = x.y;\n      x = x.x;\n    }\n\n    this.x = Vec2.clean(x || 0);\n    this.y = Vec2.clean(y || 0);\n  }\n\n  Vec2.prototype = {\n    change : function(fn) {\n      if (typeof fn === 'function') {\n        if (this.observers) {\n          this.observers.push(fn);\n        } else {\n          this.observers = [fn];\n        }\n      } else if (this.observers && this.observers.length) {\n        for (var i=this.observers.length-1; i>=0; i--) {\n          this.observers[i](this, fn);\n        }\n      }\n\n      return this;\n    },\n\n    ignore : function(fn) {\n      if (this.observers) {\n        if (!fn) {\n          this.observers = [];\n        } else {\n          var o = this.observers, l = o.length;\n          while(l--) {\n            o[l] === fn && o.splice(l, 1);\n          }\n        }\n      }\n      return this;\n    },\n\n    // set x and y\n    set: function(x, y, notify) {\n      if('number' != typeof x) {\n        notify = y;\n        y = x.y;\n        x = x.x;\n      }\n\n      if(this.x === x && this.y === y) {\n        return this;\n      }\n\n      var orig = null;\n      if (notify !== false && this.observers && this.observers.length) {\n        orig = this.clone();\n      }\n\n      this.x = Vec2.clean(x);\n      this.y = Vec2.clean(y);\n\n      if(notify !== false) {\n        return this.change(orig);\n      }\n    },\n\n    // reset x and y to zero\n    zero : function() {\n      return this.set(0, 0);\n    },\n\n    // return a new vector with the same component values\n    // as this one\n    clone : function() {\n      return new (this.constructor)(this.x, this.y);\n    },\n\n    // negate the values of this vector\n    negate : function(returnNew) {\n      if (returnNew) {\n        return new (this.constructor)(-this.x, -this.y);\n      } else {\n        return this.set(-this.x, -this.y);\n      }\n    },\n\n    // Add the incoming `vec2` vector to this vector\n    add : function(x, y, returnNew) {\n\n      if (typeof x != 'number') {\n        returnNew = y;\n        if (isArray(x)) {\n          y = x[1];\n          x = x[0];\n        } else {\n          y = x.y;\n          x = x.x;\n        }\n      }\n\n      x += this.x;\n      y += this.y;\n\n\n      if (!returnNew) {\n        return this.set(x, y);\n      } else {\n        // Return a new vector if `returnNew` is truthy\n        return new (this.constructor)(x, y);\n      }\n    },\n\n    // Subtract the incoming `vec2` from this vector\n    subtract : function(x, y, returnNew) {\n      if (typeof x != 'number') {\n        returnNew = y;\n        if (isArray(x)) {\n          y = x[1];\n          x = x[0];\n        } else {\n          y = x.y;\n          x = x.x;\n        }\n      }\n\n      x = this.x - x;\n      y = this.y - y;\n\n      if (!returnNew) {\n        return this.set(x, y);\n      } else {\n        // Return a new vector if `returnNew` is truthy\n        return new (this.constructor)(x, y);\n      }\n    },\n\n    // Multiply this vector by the incoming `vec2`\n    multiply : function(x, y, returnNew) {\n      if (typeof x != 'number') {\n        returnNew = y;\n        if (isArray(x)) {\n          y = x[1];\n          x = x[0];\n        } else {\n          y = x.y;\n          x = x.x;\n        }\n      } else if (typeof y != 'number') {\n        returnNew = y;\n        y = x;\n      }\n\n      x *= this.x;\n      y *= this.y;\n\n      if (!returnNew) {\n        return this.set(x, y);\n      } else {\n        return new (this.constructor)(x, y);\n      }\n    },\n\n    // Rotate this vector. Accepts a `Rotation` or angle in radians.\n    //\n    // Passing a truthy `inverse` will cause the rotation to\n    // be reversed.\n    //\n    // If `returnNew` is truthy, a new\n    // `Vec2` will be created with the values resulting from\n    // the rotation. Otherwise the rotation will be applied\n    // to this vector directly, and this vector will be returned.\n    rotate : function(r, inverse, returnNew) {\n      var\n      x = this.x,\n      y = this.y,\n      cos = Math.cos(r),\n      sin = Math.sin(r),\n      rx, ry;\n\n      inverse = (inverse) ? -1 : 1;\n\n      rx = cos * x - (inverse * sin) * y;\n      ry = (inverse * sin) * x + cos * y;\n\n      if (returnNew) {\n        return new (this.constructor)(rx, ry);\n      } else {\n        return this.set(rx, ry);\n      }\n    },\n\n    // Calculate the length of this vector\n    length : function() {\n      var x = this.x, y = this.y;\n      return Math.sqrt(x * x + y * y);\n    },\n\n    // Get the length squared. For performance, use this instead of `Vec2#length` (if possible).\n    lengthSquared : function() {\n      var x = this.x, y = this.y;\n      return x*x+y*y;\n    },\n\n    // Return the distance betwen this `Vec2` and the incoming vec2 vector\n    // and return a scalar\n    distance : function(vec2) {\n      var x = this.x - vec2.x;\n      var y = this.y - vec2.y;\n      return Math.sqrt(x*x + y*y);\n    },\n\n    // Given Array of Vec2, find closest to this Vec2.\n    nearest : function(others) {\n      var\n      shortestDistance = Number.MAX_VALUE,\n      nearest = null,\n      currentDistance;\n\n      for (var i = others.length - 1; i >= 0; i--) {\n        currentDistance = this.distance(others[i]);\n        if (currentDistance <= shortestDistance) {\n          shortestDistance = currentDistance;\n          nearest = others[i];\n        }\n      }\n\n      return nearest;\n    },\n\n    // Convert this vector into a unit vector.\n    // Returns the length.\n    normalize : function(returnNew) {\n      var length = this.length();\n\n      // Collect a ratio to shrink the x and y coords\n      var invertedLength = (length < Number.MIN_VALUE) ? 0 : 1/length;\n\n      if (!returnNew) {\n        // Convert the coords to be greater than zero\n        // but smaller than or equal to 1.0\n        return this.set(this.x * invertedLength, this.y * invertedLength);\n      } else {\n        return new (this.constructor)(this.x * invertedLength, this.y * invertedLength);\n      }\n    },\n\n    // Determine if another `Vec2`'s components match this one's\n    // also accepts 2 scalars\n    equal : function(v, w) {\n      if (typeof v != 'number') {\n        if (isArray(v)) {\n          w = v[1];\n          v = v[0];\n        } else {\n          w = v.y;\n          v = v.x;\n        }\n      }\n\n      return (Vec2.clean(v) === this.x && Vec2.clean(w) === this.y);\n    },\n\n    // Return a new `Vec2` that contains the absolute value of\n    // each of this vector's parts\n    abs : function(returnNew) {\n      var x = Math.abs(this.x), y = Math.abs(this.y);\n\n      if (returnNew) {\n        return new (this.constructor)(x, y);\n      } else {\n        return this.set(x, y);\n      }\n    },\n\n    // Return a new `Vec2` consisting of the smallest values\n    // from this vector and the incoming\n    //\n    // When returnNew is truthy, a new `Vec2` will be returned\n    // otherwise the minimum values in either this or `v` will\n    // be applied to this vector.\n    min : function(v, returnNew) {\n      var\n      tx = this.x,\n      ty = this.y,\n      vx = v.x,\n      vy = v.y,\n      x = tx < vx ? tx : vx,\n      y = ty < vy ? ty : vy;\n\n      if (returnNew) {\n        return new (this.constructor)(x, y);\n      } else {\n        return this.set(x, y);\n      }\n    },\n\n    // Return a new `Vec2` consisting of the largest values\n    // from this vector and the incoming\n    //\n    // When returnNew is truthy, a new `Vec2` will be returned\n    // otherwise the minimum values in either this or `v` will\n    // be applied to this vector.\n    max : function(v, returnNew) {\n      var\n      tx = this.x,\n      ty = this.y,\n      vx = v.x,\n      vy = v.y,\n      x = tx > vx ? tx : vx,\n      y = ty > vy ? ty : vy;\n\n      if (returnNew) {\n        return new (this.constructor)(x, y);\n      } else {\n        return this.set(x, y);\n      }\n    },\n\n    // Clamp values into a range.\n    // If this vector's values are lower than the `low`'s\n    // values, then raise them.  If they are higher than\n    // `high`'s then lower them.\n    //\n    // Passing returnNew as true will cause a new Vec2 to be\n    // returned.  Otherwise, this vector's values will be clamped\n    clamp : function(low, high, returnNew) {\n      var ret = this.min(high, true).max(low);\n      if (returnNew) {\n        return ret;\n      } else {\n        return this.set(ret.x, ret.y);\n      }\n    },\n\n    // Perform linear interpolation between two vectors\n    // amount is a decimal between 0 and 1\n    lerp : function(vec, amount, returnNew) {\n      return this.add(vec.subtract(this, true).multiply(amount), returnNew);\n    },\n\n    // Get the skew vector such that dot(skew_vec, other) == cross(vec, other)\n    skew : function(returnNew) {\n      if (!returnNew) {\n        return this.set(-this.y, this.x)\n      } else {\n        return new (this.constructor)(-this.y, this.x);\n      }\n    },\n\n    // calculate the dot product between\n    // this vector and the incoming\n    dot : function(b) {\n      return Vec2.clean(this.x * b.x + b.y * this.y);\n    },\n\n    // calculate the perpendicular dot product between\n    // this vector and the incoming\n    perpDot : function(b) {\n      return Vec2.clean(this.x * b.y - this.y * b.x);\n    },\n\n    // Determine the angle between two vec2s\n    angleTo : function(vec) {\n      return Math.atan2(this.perpDot(vec), this.dot(vec));\n    },\n\n    // Divide this vector's components by a scalar\n    divide : function(x, y, returnNew) {\n      if (typeof x != 'number') {\n        returnNew = y;\n        if (isArray(x)) {\n          y = x[1];\n          x = x[0];\n        } else {\n          y = x.y;\n          x = x.x;\n        }\n      } else if (typeof y != 'number') {\n        returnNew = y;\n        y = x;\n      }\n\n      if (x === 0 || y === 0) {\n        throw new Error('division by zero')\n      }\n\n      if (isNaN(x) || isNaN(y)) {\n        throw new Error('NaN detected');\n      }\n\n      if (returnNew) {\n        return new (this.constructor)(this.x / x, this.y / y);\n      }\n\n      return this.set(this.x / x, this.y / y);\n    },\n\n    isPointOnLine : function(start, end) {\n      return (start.y - this.y) * (start.x - end.x) ===\n             (start.y - end.y) * (start.x - this.x);\n    },\n\n    toArray: function() {\n      return [this.x, this.y];\n    },\n\n    fromArray: function(array) {\n      return this.set(array[0], array[1]);\n    },\n    toJSON: function () {\n      return {x: this.x, y: this.y};\n    },\n    toString: function() {\n      return '(' + this.x + ', ' + this.y + ')';\n    },\n    constructor : Vec2\n  };\n\n  Vec2.fromArray = function(array, ctor) {\n    return new (ctor || Vec2)(array[0], array[1]);\n  };\n\n  // Floating point stability\n  Vec2.precision = precision || 8;\n  var p = Math.pow(10, Vec2.precision);\n\n  Vec2.clean = clean || function(val) {\n    if (isNaN(val)) {\n      throw new Error('NaN detected');\n    }\n\n    if (!isFinite(val)) {\n      throw new Error('Infinity detected');\n    }\n\n    if(Math.round(val) === val) {\n      return val;\n    }\n\n    return Math.round(val * p)/p;\n  };\n\n  Vec2.inject = inject;\n\n  if(!clean) {\n    Vec2.fast = inject(function (k) { return k; });\n\n    // Expose, but also allow creating a fresh Vec2 subclass.\n    if (typeof module !== 'undefined' && typeof module.exports == 'object') {\n      module.exports = Vec2;\n    } else {\n      window.Vec2 = window.Vec2 || Vec2;\n    }\n  }\n  return Vec2;\n})();\n","const CarDriver = require('./car-driver');\nconst { TILE_SIZE } = require('../map-view');\n\nconst LIGHT_CHANGE_DELAY = 500;\n// The closest a car can get to another\nconst SAFE_DISTANCE = TILE_SIZE / 36;\n// Distance at which a car begins to slow down when there's another in front\nconst SLOWDOWN_DISTANCE = TILE_SIZE / 18;\n\nclass AiCarDriver extends CarDriver {\n  constructor(car) {\n    super(car);\n    this.safeDistance = SAFE_DISTANCE;\n    this.slowdownDistance = SLOWDOWN_DISTANCE;\n    this.carSpeedDeviation = 0;\n    this.isAutonomous = true;\n  }\n\n  onGreenLight() {\n    setTimeout(() => {\n      this.inRedLight = false;\n    }, LIGHT_CHANGE_DELAY);\n  }\n}\n\nmodule.exports = AiCarDriver;\n","const Dir = require('../lib/cardinal-directions');\nconst RoadTile = require('./road-tile');\nconst { randomItem } = require('../lib/random');\nconst { TILE_SIZE } = require('../map-view');\n\nconst LIGHT_CHANGE_DELAY = [300, 800];\n// The closest a car can get to another\nconst SAFE_DISTANCE = TILE_SIZE / 20;\n// Distance at which a car begins to slow down when there's another in front\nconst SLOWDOWN_DISTANCE = TILE_SIZE / 3;\n\nclass CarDriver {\n  constructor(car) {\n    this.car = car;\n    this.carDistanceFactor = 1 + Math.random() * 0.6;\n    this.carSpeedDeviation = Math.random() * 0.2 - 0.1;\n    this.carSpeedFactor = 1 + (Math.random() * 0.3 - 0.15);\n    this.safeDistance = SAFE_DISTANCE * this.carDistanceFactor;\n    this.slowdownDistance = SLOWDOWN_DISTANCE * this.carDistanceFactor;\n    this.inRedLight = false;\n  }\n\n  getMaxSpeed() {\n    const base = Math.min(this.car.maxSpeed, this.car.overlay.cityMaxSpeed);\n    return (this.car.lane === RoadTile.OUTER_LANE)\n      ? base * 0.8 * this.carSpeedFactor\n      : base * this.carSpeedFactor;\n  }\n\n  chooseExitSide(tileX, tileY, entrySide) {\n    // Select the direction based on road availability\n    const options = [];\n\n    // If it's possible to go forward, add the option\n    if (this.car.overlay.roads.hasAdjRoad(tileX, tileY, Dir.opposite(entrySide))) {\n      // Add it three times to make it more likely than turning\n      options.push(Dir.opposite(entrySide));\n      options.push(Dir.opposite(entrySide));\n      options.push(Dir.opposite(entrySide));\n    }\n    // If it's possible to turn right, add the option\n    if ((options.length === 0 || this.car.lane === RoadTile.OUTER_LANE)\n      && this.car.overlay.roads.hasAdjRoad(tileX, tileY, Dir.ccw(entrySide))) {\n      options.push(Dir.ccw(entrySide));\n    }\n    // If it's not possible to go forward or turn right,\n    // turn left if possible.\n    if (options.length === 0\n      && this.car.overlay.roads.hasAdjRoad(tileX, tileY, Dir.cw(entrySide))) {\n      options.push(Dir.cw(entrySide));\n    }\n\n    // Randomly select one of the possible directions\n    // return null if there's no way to go\n    return randomItem(options) || null;\n  }\n\n  onGreenLight() {\n    const [minDelay, maxDelay] = LIGHT_CHANGE_DELAY;\n    setTimeout(() => {\n      this.inRedLight = false;\n    }, minDelay + Math.random() * (maxDelay - minDelay));\n  }\n\n  onRedLight() {\n    this.inRedLight = true;\n  }\n\n  adjustCarSpeed() {\n    const position = this.car.getSpritePosition();\n    const carInFront = this.car.overlay.getCarInFront(this.car);\n    const maxSpeed = this.getMaxSpeed();\n    if (carInFront) {\n      const overlapDistance = this.car.sprite.height / 2 + carInFront.sprite.height / 2;\n      const distanceToCarInFront = carInFront\n        .getSpritePosition()\n        .distance(position) - overlapDistance;\n      if (distanceToCarInFront <= this.safeDistance) {\n        this.car.speed = 0;\n      } else if (distanceToCarInFront <= this.slowdownDistance) {\n        // Decelerate to maintain the safe distance\n        this.car.speed = maxSpeed * (1 - this.safeDistance / distanceToCarInFront);\n      } else if (this.car.speed < maxSpeed) {\n        // Accelerate up to the maxSpeed\n        this.car.speed = Math.min(this.car.speed + maxSpeed / 5, maxSpeed);\n      }\n    } else if (this.car.speed < maxSpeed) {\n      // Accelerate up to the maxSpeed\n      this.car.speed = Math.min(this.car.speed + maxSpeed / 5, maxSpeed);\n    }\n\n    if (this.car.speed > maxSpeed) {\n      this.car.speed = this.car.speed * 0.9;\n    }\n\n    if (this.inRedLight && this.car.speed > 0) {\n      this.car.speed = 0;\n    }\n  }\n}\n\nmodule.exports = CarDriver;\n","/* globals PIXI */\nconst Array2D = require('../lib/array-2d');\nconst TrafficLights = require('./traffic-lights');\nconst { getTileTypeId } = require('../lib/config-helpers');\nconst RoadMap = require('./road-map');\n\nclass CarOverlay {\n  constructor(mapView, config, textures, options = {}) {\n    this.mapView = mapView;\n    this.config = config;\n    this.textures = textures;\n    this.city = this.mapView.city;\n    this.roads = new RoadMap(this.city.map, getTileTypeId(config, 'road'));\n    this.cityMaxSpeed = 0.7;\n\n    this.options = Object.assign({}, CarOverlay.defaultOptions, options);\n\n    this.displayObject = new PIXI.Container();\n    this.displayObject.width = this.mapView.width;\n    this.displayObject.height = this.mapView.height;\n    this.displayObject.x = 0;\n    this.displayObject.y = 0;\n    this.displayObject.zIndex = 100;\n    this.mapView.addOverlay(this.displayObject);\n\n    this.roadTileId = getTileTypeId(config, 'road');\n\n    this.cars = [];\n    this.carsByTile = Array2D.create(this.city.map.width, this.city.map.height, null);\n    Array2D.fill(this.carsByTile, () => []);\n\n    this.trafficLights = Array2D.create(this.city.map.width, this.city.map.height, null);\n    Array2D.fill(this.trafficLights, () => new TrafficLights());\n  }\n\n  addCar(aCar) {\n    this.cars.push(aCar);\n    this.displayObject.addChild(aCar.sprite);\n  }\n\n  destroyCar(aCar) {\n    this.cars.splice(this.cars.indexOf(aCar), 1);\n    this.displayObject.removeChild(aCar);\n    aCar.destroy();\n  }\n\n  onCarEnterTile(car, tileX, tileY) {\n    this.carsByTile[tileY][tileX].push(car);\n    this.trafficLights[tileY][tileX].onCarEnter(car);\n  }\n\n  onCarExitTile(car, tileX, tileY) {\n    this.carsByTile[tileY][tileX].splice(this.carsByTile[tileY][tileX].indexOf(car), 1);\n    this.trafficLights[tileY][tileX].onCarExit(car);\n  }\n\n  onCarExitMap(aCar) {\n    this.destroyCar(aCar);\n  }\n\n  animate(time) {\n    this.cars.forEach(car => car.animate(time));\n  }\n\n  getCarsInTile(x, y) {\n    return this.city.map.isValidCoords(x, y) ? this.carsByTile[y][x] : [];\n  }\n\n  getCarsAround(car) {\n    const tiles = [[car.tile.x, car.tile.y]].concat(\n      this.city.map.adjacentCells(car.tile.x, car.tile.y)\n    );\n    return [].concat(...tiles.map(([x, y]) => this.getCarsInTile(x, y)))\n      .filter(other => car !== other);\n  }\n\n  getCarInFront(car) {\n    // The car in front can be a car on the same tile,\n    // with the same lane and entrySide,\n    // but the minimum *larger* progress...\n    return this.getCarsInTile(car.tile.x, car.tile.y)\n      .filter(other => car !== other && other.lane === car.lane\n        && other.entrySide === car.entrySide && other.path.progress > car.path.progress)\n      .sort((a, b) => a.path.progress - b.path.progress)\n      .shift()\n    // ... or a car in the next tile, with the same lane and\n    // entry side, and the minimum progress\n      || this.getCarsInTile(...car.getNextTile())\n        .filter(other => car !== other && other.lane === car.lane\n          && other.entrySide === car.getNextEntry())\n        .sort((a, b) => a.path.progress - b.path.progress)\n        .shift();\n  }\n}\n\nCarOverlay.defaultOptions = {\n  maxLifetime: true, // If true cars will be killed after some time\n};\n\nmodule.exports = CarOverlay;\n","const Car = require('../cars/car');\nconst RoadTile = require('../cars/road-tile');\nconst Dir = require('../lib/cardinal-directions');\nconst { randomItem, weightedRandomizer } = require('../lib/random');\nconst CarDriver = require('./car-driver');\n\nconst THROTTLE_TIME = 57; // Number of frames it waits before running the maybeSpawn function\nconst SPAWN_PROBABILITY = 0.5;\nconst CARS_PER_ROAD = 0.5;\n\nclass CarSpawner {\n  constructor(carOverlay, config) {\n    this.overlay = carOverlay;\n    this.config = config;\n    this.city = carOverlay.city;\n\n    this.throttleTimer = Math.random() * THROTTLE_TIME;\n    this.setModeDistribution(this.config.traffic['traffic-mode-rates']);\n\n    this.DefaultDriver = CarDriver;\n  }\n\n  /**\n   * Returns of all the texture ids of the cars in the config file\n   */\n  static allTextureIds(config) {\n    const textures = {};\n    Object.entries(config.carTypes).forEach(([id, props]) => {\n      if (props.variants) {\n        Object.assign(textures,\n          Object.fromEntries(props.variants.map(variant => [`${id}-${variant}`, true])));\n      } else {\n        textures[id] = true;\n      }\n\n      if (props.wagons) {\n        Object.assign(textures,\n          Object.fromEntries(props.wagons.flat().map(wagonId => [wagonId, true])));\n      }\n    });\n\n    return Object.keys(textures);\n  }\n\n  setModeDistribution(modeDistribution, tags = []) {\n    this.modeDistribution = modeDistribution;\n    this.modeRandomizer = weightedRandomizer(Object.entries(modeDistribution));\n    this.carRandomizers = Object.fromEntries(Object.keys(modeDistribution).map(mode => [\n      mode, weightedRandomizer(\n        Object.entries(this.config.carTypes)\n          .filter(([, props]) => props.mode === mode)\n          .filter(([, props]) => (\n            (props.include === undefined || props.include.some(tag => tags.includes(tag)))\n            && (props.exclude === undefined || !props.exclude.some(tag => tags.includes(tag)))\n          ))\n          .map(([id, props]) => [id, props.frequency || 1])\n      )]));\n  }\n\n  maybeSpawn() {\n    const maxCars = this.overlay.roads.roadCount() * CARS_PER_ROAD;\n    if (this.overlay.cars.length < maxCars) {\n      if (Math.random() < SPAWN_PROBABILITY) {\n        this.spawn();\n      }\n    }\n  }\n\n  getRandomCarType() {\n    return this.carRandomizers[this.modeRandomizer()]();\n  }\n\n  getRandomTile() {\n    const roadTiles = this.overlay.roads.connectedRoadTiles();\n    if (roadTiles.length === 0) {\n      return null;\n    }\n    const [x, y] = roadTiles[Math.floor(Math.random() * roadTiles.length)];\n    return { x, y };\n  }\n\n  getPreferredDirections(tileX, tileY) {\n    const maxY = (this.city.map.height - 1);\n    const maxX = (this.city.map.width - 1);\n    const distanceFromBorder = [\n      ['N', tileY / maxY],\n      ['E', (maxX - tileX) / maxX],\n      ['S', (maxY - tileY) / maxY],\n      ['W', tileX / maxX],\n    ];\n    return distanceFromBorder\n      .sort((a, b) => a[1] - b[1])\n      .map(a => a[0]);\n  }\n\n  getRandomEntrySide(tileX, tileY) {\n    const validDirections = this.overlay.roads.adjRoadDirs(tileX, tileY);\n    return validDirections.length === 1\n      ? Dir.opposite(validDirections[0])\n      : this.getPreferredDirections(tileX, tileY).find(d => validDirections.includes(d));\n  }\n\n  getRandomLane(carType) {\n    const options = (this.config.carTypes[carType].lanes || 'inner, outer')\n      .split(',')\n      .map(s => RoadTile.laneNames[s.trim().toLowerCase()]);\n\n    return options.length === 1 ? options[0] : randomItem(options);\n  }\n\n  getRandomTexture(carType) {\n    const options = (this.config.carTypes[carType].variants\n      ? this.config.carTypes[carType].variants.map(variant => `${carType}-${variant}`)\n      : [carType]);\n\n    return this.overlay.textures.cars[randomItem(options)];\n  }\n\n  getRandomWagonTextures(carType) {\n    return this.config.carTypes[carType].wagons.map(wagonDef => (\n      Array.isArray(wagonDef) ? randomItem(wagonDef) : wagonDef\n    ));\n  }\n\n  spawn(explicitCarType) {\n    const tile = this.getRandomTile();\n    if (tile) {\n      const entrySide = this.getRandomEntrySide(tile.x, tile.y);\n      const carType = explicitCarType || this.getRandomCarType();\n      const texture = this.getRandomTexture(carType);\n      const lane = this.getRandomLane(carType);\n      // const maxSpeed = this.getRandomMaxSpeed(carType, lane);\n      const maxSpeed = this.config.carTypes[carType].maxSpeed || 1;\n      const isBike = this.config.carTypes[carType].mode === 'bike';\n\n      const car = new Car(\n        this.overlay, texture, tile.x, tile.y, entrySide, lane, maxSpeed,\n        isBike ? CarDriver : this.DefaultDriver\n      );\n      this.overlay.addCar(car);\n\n      if (this.config.carTypes[carType].wagons) {\n        let lastWagon = car;\n        this.getRandomWagonTextures(carType).forEach((wagonTextureId) => {\n          const wagonTexture = this.overlay.textures.cars[wagonTextureId];\n          const wagon = new Car(\n            this.overlay, wagonTexture, tile.x, tile.y, entrySide, lane, maxSpeed\n          );\n          lastWagon.addWagon(wagon);\n          this.overlay.addCar(wagon);\n          lastWagon = wagon;\n        });\n      }\n    }\n  }\n\n  animate(time) {\n    this.throttleTimer += time;\n    if (this.throttleTimer > THROTTLE_TIME) {\n      this.throttleTimer %= THROTTLE_TIME;\n      this.maybeSpawn();\n    }\n  }\n}\n\nmodule.exports = CarSpawner;\n","/* globals PIXI */\nconst Vec2 = require('vec2');\nconst CarDriver = require('./car-driver');\nconst Dir = require('../lib/cardinal-directions');\nconst RoadTile = require('./road-tile');\nconst { TILE_SIZE } = require('../map-view');\nconst SpriteFader = require('../lib/sprite-fader');\nconst PathStraight = require('./path-straight');\nconst PathArc = require('./path-arc');\nconst PulledCarDriver = require('./pulled-car-driver');\n\n// Max lifetime of cars\nconst MAX_LIFETIME = 2 * 60 * 60; // Approx. 2 minutes\nconst MAX_TIME_STOPPED = 60 * 60; // Approx. 1 minute\n\nconst SPRITE_ANCHOR_X = 0.5;\nconst SPRITE_ANCHOR_Y = 0.75;\n\nclass Car {\n  constructor(carOverlay, texture, tileX, tileY, entrySide, lane, maxSpeed = 1, DriverClass = CarDriver) {\n    this.overlay = carOverlay;\n    this.lane = lane;\n    this.maxSpeed = maxSpeed;\n    this.speed = maxSpeed;\n    this.lifetime = 0;\n    this.timeStopped = 0;\n    this.isSpawning = true;\n    this.isDespawning = false;\n    this.frontWagon = null;\n    this.backWagon = null;\n    this.path = null;\n    this.DriverClass = DriverClass;\n\n    this.driver = new this.DriverClass(this);\n\n    this.sprite = Car.createSprite(texture);\n    this.fader = new SpriteFader(this.sprite);\n    this.setTile(tileX, tileY, entrySide);\n    this.setSpritePosition(this.tilePosition().add(RoadTile.entryPoint(this.lane, this.entrySide)));\n    this.sprite.rotation = Dir.asAngle(Dir.opposite(this.entrySide));\n  }\n\n  static createSprite(texture) {\n    const sprite = new PIXI.Sprite();\n    sprite.texture = texture;\n    sprite.width = texture.width;\n    sprite.height = texture.height;\n    // sprite.roundPixels = true;\n    sprite.anchor.set(SPRITE_ANCHOR_X, SPRITE_ANCHOR_Y);\n    sprite.visible = true;\n    sprite.alpha = 0;\n\n    return sprite;\n  }\n\n  destroy() {\n    if (this.backWagon) {\n      this.backWagon.removeFrontWagon();\n    }\n    this.sprite.destroy();\n    this.sprite = null;\n    this.overlay = null;\n  }\n\n  despawn() {\n    if (!this.isDespawning) {\n      this.isDespawning = true;\n      this.fader.fadeOut(() => {\n        this.overlay.onCarExitTile(this, this.tile.x, this.tile.y);\n        this.overlay.onCarExitMap(this);\n      });\n    }\n  }\n\n  despawnWagons() {\n    let nextWagon = this.backWagon;\n    while (nextWagon) {\n      nextWagon.despawn();\n      nextWagon = nextWagon.backWagon;\n    }\n  }\n\n  isVisible() {\n    return this.fader.visible;\n  }\n\n  addWagon(car) {\n    this.backWagon = car;\n    car.frontWagon = this;\n    car.driver = new PulledCarDriver(car);\n  }\n\n  removeFrontWagon() {\n    this.frontWagon = null;\n    this.driver = new this.DriverClass(this);\n  }\n\n  isPulling(car) {\n    let eachCar = this;\n    while (eachCar.backWagon) {\n      if (car === eachCar.backWagon) {\n        return true;\n      }\n      eachCar = eachCar.backWagon;\n    }\n    return false;\n  }\n\n  setTile(x, y, entrySide) {\n    // Check if the coordinates are valid\n    if (!this.overlay.city.map.isValidCoords(x, y)) {\n      this.despawn();\n      return;\n    }\n\n    // Check if the tile has an exit\n    const exitSide = this.driver.chooseExitSide(x, y, entrySide);\n    if (exitSide === null) {\n      this.despawn();\n      return;\n    }\n\n    this.tile = { x, y };\n    this.entrySide = entrySide;\n    this.exitSide = exitSide;\n\n    const remainder = this.path !== null ? this.path.remainder : 0;\n    this.path = this.exitSide === Dir.opposite(this.entrySide)\n      ? new PathStraight(this.lane, this.entrySide)\n      : new PathArc(this.lane, this.entrySide, this.exitSide);\n    this.path.advance(remainder);\n\n    this.onEnterTile();\n  }\n\n  getNextTile() {\n    return Dir.adjCoords(this.tile.x, this.tile.y, this.exitSide);\n  }\n\n  getNextEntry() {\n    return Dir.opposite(this.exitSide);\n  }\n\n  tilePosition() {\n    return Vec2(this.tile.x * TILE_SIZE, this.tile.y * TILE_SIZE);\n  }\n\n  setSpritePosition(v) {\n    this.sprite.x = v.x;\n    this.sprite.y = v.y;\n  }\n\n  getSpritePosition() {\n    return Vec2(this.sprite.x, this.sprite.y);\n  }\n\n  onEnterTile() {\n    this.overlay.onCarEnterTile(this, this.tile.x, this.tile.y);\n  }\n\n  onGreenLight() {\n    this.driver.onGreenLight();\n  }\n\n  onRedLight() {\n    this.driver.onRedLight();\n  }\n\n  onExitTile() {\n    this.overlay.onCarExitTile(this, this.tile.x, this.tile.y);\n\n    // Transfer the car to the next tile\n    this.setTile(...this.getNextTile(), this.getNextEntry());\n  }\n\n  hasCarsOverlapping() {\n    const cheapDistance = (v1, v2) => Math.max(Math.abs(v1.x - v2.x), Math.abs(v1.y - v2.y));\n    const position = this.getSpritePosition();\n    return this.overlay.getCarsAround(this).some((carAround) => {\n      const overlapDistance = this.sprite.height / 2 + carAround.sprite.height / 2;\n      return cheapDistance(carAround.getSpritePosition(), position) < overlapDistance\n        && !this.isPulling(carAround) && !carAround.isPulling(this);\n    });\n  }\n\n  animate(time) {\n    this.driver.adjustCarSpeed();\n\n    if (this.isSpawning && !this.hasCarsOverlapping()\n      && (!this.frontWagon || this.speed > 0)) {\n      this.isSpawning = false;\n    }\n\n    if (this.speed > 0) {\n      this.timeStopped = 0;\n      this.path.advance(this.speed * time);\n      this.setSpritePosition(this.tilePosition().add(this.path.position));\n      this.sprite.rotation = this.path.rotation;\n      if (this.path.progress === 1) {\n        this.onExitTile();\n      }\n    } else {\n      this.timeStopped += time;\n    }\n\n    this.lifetime += time;\n    if (!this.frontWagon) {\n      if ((this.lifetime > MAX_LIFETIME || this.timeStopped > MAX_TIME_STOPPED)\n        && this.overlay.options.maxLifetime) {\n        this.despawn();\n        this.despawnWagons();\n      }\n    }\n\n    if (this.isDespawning\n      || this.isSpawning\n      || !this.overlay.roads.isRoad(this.tile.x, this.tile.y)) {\n      this.fader.fadeOut();\n    } else {\n      this.fader.fadeIn();\n    }\n    this.fader.animate(time);\n  }\n}\n\nmodule.exports = Car;\n","const Vec2 = require('vec2');\nconst Dir = require('../lib/cardinal-directions');\nconst RoadTile = require('./road-tile');\n\nclass PathArc {\n  constructor(lane, entrySide, exitSide) {\n    this.arcRotation = RoadTile.curveRotation(entrySide, exitSide);\n\n    const rotationDir = RoadTile.curveRotDir(entrySide, exitSide);\n    this.rotationSign = rotationDir === 'cw' ? 1 : -1;\n    this.arcRadius = RoadTile.curveRadius[rotationDir][lane];\n    this.arcLength = Math.PI * this.arcRadius / 2;\n    this.rotCenter = RoadTile.curveCenter(entrySide, exitSide);\n\n    this.distance = 0;\n    this.progress = 0;\n    this.remainder = 0;\n    this.position = RoadTile.entryPoint(lane, entrySide);\n  }\n\n  advance(distance) {\n    this.distance += distance;\n    if (this.distance > this.arcLength) {\n      this.remainder = this.distance - this.arcLength;\n      this.distance = this.arcLength;\n    }\n    this.progress = this.distance / this.arcLength;\n    const angle = this.arcRotation + this.progress * (Math.PI / 2) * this.rotationSign;\n    this.position = Vec2(0, this.arcRadius)\n      .rotate(angle)\n      .add(this.rotCenter);\n    this.rotation = angle + Math.PI / 2 * this.rotationSign;\n  }\n}\n\nmodule.exports = PathArc;\n","const Vec2 = require('vec2');\nconst RoadTile = require('./road-tile');\nconst Dir = require('../lib/cardinal-directions');\nconst MapView = require('../map-view');\n\nclass PathStraight {\n  constructor(lane, entrySide) {\n    this.entryPoint = RoadTile.entryPoint(lane, entrySide);\n    this.rotation = Dir.asAngle(Dir.opposite(entrySide));\n\n    this.distance = 0;\n    this.progress = 0;\n    this.remainder = 0;\n    this.position = this.entryPoint;\n  }\n\n  advance(distance) {\n    this.distance += distance;\n    if (this.distance > MapView.TILE_SIZE) {\n      this.remainder = this.distance - MapView.TILE_SIZE;\n      this.distance = MapView.TILE_SIZE;\n    }\n    this.progress = this.distance / MapView.TILE_SIZE;\n\n    this.position = Vec2(0, this.distance).rotate(this.rotation).add(this.entryPoint);\n  }\n}\n\nmodule.exports = PathStraight;\n","const CarDriver = require('./car-driver');\n\nclass PulledCarDriver extends CarDriver {\n  chooseExitSide() {\n    return this.car.frontWagon.exitSide;\n  }\n\n  onGreenLight() {\n\n  }\n\n  onRedLight() {\n\n  }\n\n  adjustCarSpeed() {\n    const position = this.car.getSpritePosition();\n    const { frontWagon } = this.car;\n\n    const overlapDistance = this.car.sprite.height * (1 - this.car.sprite.anchor.y)\n      + (frontWagon.sprite.height * this.car.sprite.anchor.y);\n\n    const distanceToCarInFront = frontWagon\n      .getSpritePosition()\n      .distance(position);\n    if (distanceToCarInFront < overlapDistance - 2) {\n      this.car.speed = 0;\n    } else {\n      // Deaccelerate to maintain the safe distance\n      this.car.speed = frontWagon.speed;\n    }\n  }\n}\n\nmodule.exports = PulledCarDriver;\n","const Dir = require('../lib/cardinal-directions');\nconst Array2D = require('../lib/array-2d');\n\nclass RoadMap {\n  constructor(map, roadTileId) {\n    this.map = map;\n    this.roadTileId = roadTileId;\n  }\n\n  isRoad(x, y) {\n    return !this.map.isValidCoords(x, y)\n      || this.map.get(x, y) === this.roadTileId;\n  }\n\n  hasAdjRoad(x, y, direction) {\n    return this.isRoad(...Dir.adjCoords(x, y, direction));\n  }\n\n  adjRoadDirs(x, y) {\n    return Dir.all.filter(d => this.hasAdjRoad(x, y, d));\n  }\n\n  roadCount() {\n    return Array2D.reduce(this.map.cells,\n      (total, cell) => total + (cell === this.roadTileId ? 1 : 0), 0);\n  }\n\n  roadTiles() {\n    return Array2D.items(this.map.cells).filter(([x, y]) => this.map.get(x, y) === this.roadTileId);\n  }\n\n  connectedRoadTiles() {\n    return this.roadTiles().filter(([x, y]) => this.hasAdjRoad(x, y, 'N')\n      || this.hasAdjRoad(x, y, 'E')\n      || this.hasAdjRoad(x, y, 'S')\n      || this.hasAdjRoad(x, y, 'W'));\n  }\n}\n\nmodule.exports = RoadMap;\n","const Vec2 = require('vec2');\nconst { TILE_SIZE } = require('../map-view');\n\nconst LANE_WIDTH = TILE_SIZE / 6;\n\nconst INNER_LANE = 2;\nconst OUTER_LANE = 1;\nconst BIKE_LANE = 0;\n\nconst laneNames = {\n  inner: INNER_LANE,\n  outer: OUTER_LANE,\n  bike: BIKE_LANE,\n};\n\nfunction entryPoint(lane, side) {\n  switch (side) {\n    case 'W':\n      return Vec2(0, TILE_SIZE - (LANE_WIDTH * (lane + 0.5)));\n    case 'E':\n      return Vec2(TILE_SIZE, LANE_WIDTH * (lane + 0.5));\n    case 'S':\n      return Vec2(TILE_SIZE - (LANE_WIDTH * (lane + 0.5)), TILE_SIZE);\n    case 'N':\n      return Vec2(LANE_WIDTH * (lane + 0.5), 0);\n    default:\n      throw new Error(`Invalid direction ${side}`);\n  }\n}\n\nfunction exitPoint(lane, side) {\n  switch (side) {\n    case 'W':\n      return Vec2(0, LANE_WIDTH * (lane + 0.5));\n    case 'E':\n      return Vec2(TILE_SIZE, TILE_SIZE - (LANE_WIDTH * (lane + 0.5)));\n    case 'S':\n      return Vec2(LANE_WIDTH * (lane + 0.5), TILE_SIZE);\n    case 'N':\n      return Vec2(TILE_SIZE - (LANE_WIDTH * (lane + 0.5)), 0);\n    default:\n      throw new Error(`Invalid direction ${side}`);\n  }\n}\n\nconst curveRadius = {\n  cw: [],\n  ccw: [],\n};\ncurveRadius.cw[BIKE_LANE] = LANE_WIDTH * 0.5;\ncurveRadius.cw[OUTER_LANE] = LANE_WIDTH * 1.5;\ncurveRadius.cw[INNER_LANE] = LANE_WIDTH * 2.5;\ncurveRadius.ccw[INNER_LANE] = LANE_WIDTH * 3.5;\ncurveRadius.ccw[OUTER_LANE] = LANE_WIDTH * 4.5;\ncurveRadius.ccw[BIKE_LANE] = LANE_WIDTH * 5.5;\n\nfunction curveRotDir(entryDir, exitDir) {\n  const table = {\n    N: { W: 'cw', E: 'ccw' },\n    E: { N: 'cw', S: 'ccw' },\n    S: { E: 'cw', W: 'ccw' },\n    W: { S: 'cw', N: 'ccw' },\n  };\n\n  return table[entryDir][exitDir];\n}\n\nfunction curveCenter(entryDir, exitDir) {\n  const ne = Vec2(TILE_SIZE, 0);\n  const se = Vec2(TILE_SIZE, TILE_SIZE);\n  const sw = Vec2(0, TILE_SIZE);\n  const nw = Vec2(0, 0);\n\n  const table = {\n    N: { W: nw, E: ne },\n    E: { N: ne, S: se },\n    S: { E: se, W: sw },\n    W: { S: sw, N: nw },\n  };\n\n  return table[entryDir][exitDir];\n}\n\nfunction curveRotation(entryDir, exitDir) {\n\n  const table = {\n    N: { W: Math.PI * 1.5, E: Math.PI * 0.5 },\n    E: { N: 0, S: Math.PI },\n    S: { E: Math.PI * 0.5, W: Math.PI * 1.5 },\n    W: { S: Math.PI, N: 0 },\n  };\n\n  return table[entryDir][exitDir];\n}\n\nmodule.exports = {\n  BIKE_LANE,\n  OUTER_LANE,\n  INNER_LANE,\n  LANE_WIDTH,\n  laneNames,\n  entryPoint,\n  exitPoint,\n  curveRadius,\n  curveRotDir,\n  curveCenter,\n  curveRotation,\n};\n","const Dir = require('../lib/cardinal-directions');\n\nconst MIN_LIGHT_CHANGE_DELAY = 500;\nconst MAX_LIGHT_CHANGE_DELAY = 1200;\n\nclass TrafficLights {\n  constructor() {\n    this.carsCrossing = [];\n    this.carsWaiting = [];\n    this.greenDirections = [];\n    this.lightsChanging = false;\n  }\n\n  onCarRequestToCross(car) {\n    if (!this.lightsChanging && this.greenDirections.length === 0) {\n      // This criteria to turn on green lights could be different\n      // or more complex. It could be based on the number of\n      // connections the tile has to roads, and the allowed\n      // directions of turns. But maybe this will be enough for now...\n      if (Dir.opposite(car.entrySide) === car.exitSide) {\n        this.greenDirections = [`${car.entrySide}-${car.exitSide}`,\n          `${Dir.opposite(car.entrySide)}-${Dir.opposite(car.exitSide)}`];\n      } else {\n        this.greenDirections = [`${car.entrySide}-${car.exitSide}`,\n          `${car.exitSide}-${car.entrySide}`];\n      }\n    }\n    if (this.greenDirections.includes(`${car.entrySide}-${car.exitSide}`)) {\n      return true;\n    }\n    return false;\n  }\n\n  onCarEnter(car) {\n    if (this.onCarRequestToCross(car)) {\n      this.carsCrossing.push(car);\n    } else {\n      this.carsWaiting.push(car);\n      car.onRedLight();\n    }\n  }\n\n  onCarExit(car) {\n    this.carsCrossing = this.carsCrossing.filter(c => c !== car);\n    this.carsWaiting = this.carsWaiting.filter(c => c !== car);\n    if (this.carsCrossing.length === 0) {\n      this.switchLights();\n    }\n  }\n\n  getRandomLightChangeDelay() {\n    return MIN_LIGHT_CHANGE_DELAY\n      + Math.random() * (MAX_LIGHT_CHANGE_DELAY - MIN_LIGHT_CHANGE_DELAY);\n  }\n\n  switchLights() {\n    this.lightsChanging = true;\n    setTimeout(() => {\n      this.lightsChanging = false;\n      this.greenDirections = [];\n      this.carsWaiting.forEach((car) => {\n        if (this.onCarRequestToCross(car)) {\n          this.carsWaiting = this.carsWaiting.filter(c => c !== car);\n          this.carsCrossing.push(car);\n          car.onGreenLight();\n        }\n      });\n    }, this.getRandomLightChangeDelay());\n  }\n}\n\nmodule.exports = TrafficLights;\n","const deepmerge = require('deepmerge');\n\nconst overwriteMerge = (destinationArray, sourceArray) => sourceArray;\n\nclass CfgLoader {\n  constructor(cfgReader, cfgParser) {\n    this.reader = cfgReader;\n    this.parser = cfgParser;\n  }\n\n  async load(files) {\n    const segments = [];\n    const promises = [];\n\n    files.forEach((file, i) => {\n      promises.push(\n        this.reader(file)\n          .then(cfgText => this.parser(cfgText))\n          .then((cfgSegment) => {\n            // We keep the segments in order\n            segments[i] = cfgSegment;\n          })\n      );\n    });\n\n    return Promise.all(promises).then(() => deepmerge.all(segments.filter(s => s), { arrayMerge: overwriteMerge }));\n  }\n}\n\nmodule.exports = CfgLoader;\n","function CfgReaderFetch(filename) {\n  return fetch(filename, { cache: 'no-store' })\n    .then(response => response.text());\n}\n\nmodule.exports = CfgReaderFetch;\n","class CitizenRequestViewMgr {\n  constructor(citizenRequestView, requestCount = 2) {\n    this.view = citizenRequestView;\n    this.requestCount = requestCount;\n    this.config = this.view.config;\n    this.groups = this.getGroups();\n\n    this.shownRequests = {};\n    this.lastShowTime = {};\n\n    this.minTime = (this.config.citizenRequestView.minTime || 30) * 1000;\n    this.maxTime = (this.config.citizenRequestView.maxTime || 90) * 1000;\n    this.cooldownTime = (this.config.citizenRequestView.cooldownTime || 90) * 1000;\n\n    this.inTestMode = false;\n    window.testCitizenRequestView = () => this.enterTestMode();\n  }\n\n  displayRequest(goalId) {\n    if (this.shownRequests[goalId] === undefined) {\n      this.shownRequests[goalId] = true;\n      this.lastShowTime[goalId] = Date.now();\n      this.view.displayRequest(goalId);\n    }\n  }\n\n  removeRequest(goalId) {\n    if (this.shownRequests[goalId] !== undefined) {\n      delete this.shownRequests[goalId];\n      this.view.removeRequest(goalId);\n    }\n  }\n\n  handleUpdate(goals) {\n    if (this.inTestMode) {\n      return;\n    }\n    const selectedGoals = this.selectElegibleGoals(goals)\n      .slice(0, this.requestCount);\n\n    // Remove goals that are not selected\n    Object.keys(this.shownRequests).forEach((goalId) => {\n      if (!selectedGoals.find(goal => goal.id === goalId)) {\n        this.removeRequest(goalId);\n      }\n    });\n\n    // Add selected goals\n    selectedGoals.forEach((goal) => {\n      this.displayRequest(goal.id);\n    });\n  }\n\n  getGroups() {\n    const answer = {};\n    let id = 0;\n    Object.values(this.config.citizenRequests).forEach((request) => {\n      if (answer[request.group] === undefined) {\n        answer[request.group] = id;\n        id += 1;\n      }\n    });\n    // Add a catch-all group\n    if (answer.others === undefined) {\n      answer.others = id;\n    }\n    return answer;\n  }\n\n  getVisibilityGroup(goal, now) {\n    if (this.lastShowTime[goal.id] === undefined) {\n      return CitizenRequestViewMgr.Timing.NORMAL;\n    }\n\n    const timeSinceShow = now - this.lastShowTime[goal.id];\n    const cooldownEnter = this.maxTime;\n    const cooldownExit = cooldownEnter + this.cooldownTime;\n    if (timeSinceShow < this.minTime) {\n      return CitizenRequestViewMgr.Timing.UNDER_MIN_TIME;\n    }\n    if ((timeSinceShow > cooldownEnter) && (timeSinceShow < cooldownExit)) {\n      return CitizenRequestViewMgr.Timing.IN_COOLDOWN;\n    }\n    return CitizenRequestViewMgr.Timing.NORMAL;\n  }\n\n  selectElegibleGoals(goals) {\n    const interleavedOrder = {};\n    const visibilityGroup = {};\n    const goalsPerGroup = Object.fromEntries(Object.keys(this.groups).map(group => [group, 0]));\n    const now = Date.now();\n\n    const unmetGoals = goals.filter(goal => goal.condition === false);\n\n    unmetGoals.sort((a, b) => (\n      // Sort by \"priority, progress DESC\"\n      (a.priority - b.priority) || (b.progress - a.progress)\n    )).forEach((goal) => {\n      // Assign each goal a visibility group based on the last time it was shown\n      visibilityGroup[goal.id] = this.getVisibilityGroup(goal, now);\n\n      // Assign each goal an order so they are interleaved per group\n      // (cat1, cat2, cat3, cat1, cat2, cat3, etc..) keeping the same\n      // order they had within each category.\n      const group = (this.config.citizenRequests[goal.id]\n        && this.config.citizenRequests[goal.id].group) || 'others';\n      interleavedOrder[goal.id] = this.groups[group] + goalsPerGroup[group] * this.groups.length;\n      goalsPerGroup[group] += 1;\n    });\n\n    return unmetGoals\n      .sort((a, b) => (\n        // Sort by visible time, then interleaved order\n        (visibilityGroup[a.id] - visibilityGroup[b.id])\n        || (interleavedOrder[a.id] - interleavedOrder[b.id])\n      ));\n  }\n\n  enterTestMode() {\n    this.inTestMode = true;\n    const allRequests = Object.keys(this.config.citizenRequests);\n    let i = 0;\n    const showOne = (index) => {\n      Object.keys(this.shownRequests).forEach((goalId) => {\n        this.removeRequest(goalId);\n      });\n      this.displayRequest(allRequests[index]);\n    };\n\n    showOne(0);\n    $(window).on('keydown', (ev) => {\n      if (ev.key === 'ArrowLeft') {\n        if (i > 0) {\n          i -= 1;\n        }\n        showOne(i);\n      } else if (ev.key === 'ArrowRight') {\n        if (i < (allRequests.length - 1)) {\n          i += 1;\n          showOne(i);\n        }\n      }\n    });\n  }\n}\n\nCitizenRequestViewMgr.Timing = {\n  UNDER_MIN_TIME: 0,\n  NORMAL: 1,\n  IN_COOLDOWN: 2,\n};\n\nmodule.exports = CitizenRequestViewMgr;\n","const { randomItem } = require('./lib/random');\nconst { getTileType } = require('./lib/config-helpers');\n\nclass CitizenRequestView {\n  constructor(config) {\n    this.config = config;\n    this.languages = this.config.dashboard.languages;\n    this.mainLanguage = this.languages[0];\n\n    this.$element = $('<div></div>')\n      .addClass('citizen-requests');\n\n    this.requests = {};\n\n    this.tileColors = Object.fromEntries(\n      Object.entries(CitizenRequestView.tileReferences)\n        .map(([key, type]) => [key, getTileType(this.config, type).color])\n    );\n  }\n\n  displayRequest(goalId) {\n    if (this.requests[goalId] === undefined && this.config.citizenRequests[goalId] !== undefined) {\n      this.requests[goalId] = $('<div></div>')\n        .addClass('request')\n        .append($('<div></div>').addClass('request-person')\n          .css({\n            'background-image': `url(${this.getRandomCitizenIcon(goalId)})`,\n          }))\n        .append($('<div></div>').addClass('request-balloon')\n          .append(\n            this.languages.map(lang => (\n              $('<div></div>').addClass(`request-text request-text-${lang}`)\n                .addClass(lang === this.mainLanguage ? 'request-text-main' : 'request-text-translation')\n                .html(this.formatRequestText(this.config.citizenRequests[goalId][lang]))\n            ))\n          )\n        )\n        .appendTo(this.$element);\n    }\n  }\n\n  removeRequest(goalId) {\n    if (this.requests[goalId] !== undefined) {\n      this.requests[goalId].remove();\n      delete this.requests[goalId];\n    }\n  }\n\n  getRandomCitizenIcon(goalId) {\n    const urgent = this.config.citizenRequests[goalId].urgent || false;\n    const icons = urgent ? this.config.citizenIcons.urgent : this.config.citizenIcons.regular;\n    return randomItem(icons);\n  }\n\n  formatRequestText(text) {\n    return text\n      .replaceAll(CitizenRequestView.tileRefRegexp, (match, tileSpec, innerText) => (\n        // `<span class=\"tileref tileref-${CitizenRequestView.tileReferences[tileSpec]}\"><span class=\"tileref-stub\" style=\"background-color: ${this.tileColors[tileSpec]}\"></span> ${innerText}</span>`\n        `<span class=\"tileref-stub\" style=\"background-color: ${this.tileColors[tileSpec]}\"></span>&nbsp;${innerText}`\n      ))\n      .replaceAll(CitizenRequestView.largeTextRegexp, '<span class=\"large\">$1</span>');\n  }\n}\n\nCitizenRequestView.tileReferences = {\n  W: 'water',\n  P: 'park',\n  R: 'residential',\n  C: 'commercial',\n  I: 'industrial',\n  X: 'road',\n};\nCitizenRequestView.tileRefRegexp = new RegExp(\n  `([${Object.keys(CitizenRequestView.tileReferences).join('')}])\\\\[([^\\\\]]+)\\\\]`, 'g'\n);\n\nCitizenRequestView.largeTextRegexp = /\\*([^*]+)\\*/g;\n\nmodule.exports = CitizenRequestView;\n","const Grid = require('./grid');\nconst Array2D = require('./lib/array-2d');\n\nclass City {\n  constructor(width, height, cells = null) {\n    this.map = new Grid(width, height, cells);\n  }\n\n  toJSON() {\n    const { map } = this;\n    return {\n      map: map.toJSON(),\n    };\n  }\n\n  static fromJSON(jsonObject) {\n    const { map } = jsonObject;\n    if (Array.isArray(map)) {\n      // Support old serialization format\n      return new City(16, 16, Array2D.fromFlat(16, 16, map.map(v => Number(v))));\n    }\n    const { width, height } = map;\n\n    // Support old serialization format\n    const cells = Array2D.isValid(map.cells)\n      ? Array2D.clone(map.cells)\n      : Array2D.fromFlat(width, height, map.cells.map(v => Number(v)));\n    return new City(width, height, cells);\n  }\n\n  copy(city) {\n    this.map.copy(city.map);\n  }\n}\n\nmodule.exports = City;\n","/* globals Chart */\n\nconst {\n  average, sortedMedian, sortedFirstQuartile, sortedThirdQuartile,\n} = require('./lib/statistics');\n\nclass DataInspectorView {\n  constructor() {\n    this.$element = $('<div></div>')\n      .addClass('data-inspector');\n    this.$canvas = $('<canvas></canvas>').appendTo(this.$element);\n    this.$infoPane = $('<div></div>')\n      .addClass('data-inspector-info')\n      .appendTo(this.$element);\n    this.chart = new Chart(this.$canvas, {\n      type: 'bar',\n    });\n  }\n\n  display(data) {\n    const distribution = DataInspectorView.asFrequencyDistribution(data.values, data.fractional);\n    this.chart.data = {\n      labels: Object.keys(distribution),\n      datasets: [{\n        label: data.title,\n        data: Object.values(distribution),\n      }],\n    };\n    this.chart.update();\n\n    const info = DataInspectorView.distributionInfo(data.values);\n    this.$infoPane.empty()\n      .append(info.map(indicator => $('<div></div>').addClass('indicator')\n        .append($('<span></span>').addClass('label').text(`${indicator.title}: `))\n        .append($('<span></span>').addClass('value').text(indicator.value))));\n  }\n\n  static asFrequencyDistribution(values, fractional) {\n    const data = {};\n\n    if (fractional) {\n      for (let i = 0; i <= 1; i += 0.1) {\n        data[i.toFixed(1)] = 0;\n      }\n      values.forEach((v) => {\n        data[v.toFixed(1)] = (data[v.toFixed(1)] || 0) + 1;\n      });\n    } else {\n      values.forEach((v) => {\n        data[Math.floor(v)] = (data[Math.floor(v)] || 0) + 1;\n      });\n    }\n    return data;\n  }\n\n  static distributionInfo(data) {\n    const formatNumber = n => (n !== undefined ? n.toFixed(2) : '-');\n\n    const sorted = data.sort((a, b) => a - b);\n    return [\n      { title: 'Count', value: data.length },\n      { title: 'Range', value: DataInspectorView.range(sorted) },\n      { title: 'Average', value: formatNumber(average(data)) },\n      { title: 'Q1', value: formatNumber(sortedFirstQuartile(sorted)) },\n      { title: 'Median', value: formatNumber(sortedMedian(sorted)) },\n      { title: 'Q3', value: formatNumber(sortedThirdQuartile(sorted)) },\n    ];\n  }\n\n  static range(sortedData) {\n    if (sortedData.length === 0) {\n      return '[]';\n    }\n    return `[${sortedData.at(0)}, ${sortedData.at(-1)}]`;\n  }\n}\n\nmodule.exports = DataInspectorView;\n","const EventEmitter = require('events');\n\nclass DataManager {\n  constructor(userOptions = {}) {\n    this.options = Object.assign({}, DataManager.DefaultOptions, userOptions);\n    this.sources = [];\n    this.variables = {};\n    this.events = new EventEmitter();\n\n    this.calculationPending = false;\n    this.cooldownTimer = null;\n\n    this.dataModifiers = [];\n  }\n\n  /**\n   * Add a new data source to the data manager.\n   *\n   * @param {DataSource} dataSource\n   */\n  registerSource(dataSource) {\n    if (this.sources.includes(dataSource)) {\n      throw new Error(`Source ${dataSource.constructor.name} already registered.`);\n    }\n    this.sources.push(dataSource);\n    dataSource.dataManager = this;\n\n    Object.entries(dataSource.getVariables()).forEach(([id, callback]) => {\n      if (this.variables[id] !== undefined) {\n        throw new Error(`Source ${dataSource.constructor.name} registering already registered variable ${id}.`);\n      }\n      this.variables[id] = callback;\n    });\n  }\n\n  registerModifier(modifier) {\n    this.dataModifiers.push(modifier);\n  }\n\n  /**\n   * Get the value of a variable.\n   *\n   * @param {string} variableId\n   * @return {*}\n   */\n  get(variableId) {\n    if (this.variables[variableId] === undefined) {\n      throw new Error(`Requested unknown variable ${variableId}.`);\n    }\n\n    return this.variables[variableId]();\n  }\n\n  throttledCalculateAll() {\n    this.calculationPending = true;\n    if (this.cooldownTimer === null) {\n      this.cooldownTimer = setTimeout(() => {\n        this.cooldownTimer = null;\n        if (this.calculationPending) {\n          this.throttledCalculateAll();\n        }\n      }, this.options.throttleTime);\n      this.calculateAll();\n      this.calculationPending = false;\n    }\n  }\n\n  calculateAll() {\n    this.sources.forEach((source) => {\n      source.calculate();\n    });\n    this.events.emit('update');\n  }\n\n  getGoals() {\n    return this.sources.reduce((acc, source) => acc.concat(source.getGoals()), []);\n  }\n\n  getModifiers(id) {\n    return this.dataModifiers.reduce((acc, modifier) => acc.concat(modifier.getModifiers(id)), []);\n  }\n}\n\nDataManager.DefaultOptions = {\n  throttleTime: 1000,\n};\n\nmodule.exports = DataManager;\n","class DataSource {\n  /**\n   * Get the list of variables provided by this data source.\n   *\n   * Provides a map of callbacks that return the data of the variable.\n   *\n   * @return {Object.<string, function>}\n   */\n  // eslint-disable-next-line class-methods-use-this\n  getVariables() {\n    return {};\n  }\n\n  /**\n   * Computes the values of all variables provided by this source.\n   */\n  calculate() {\n  }\n\n  /**\n   * Gets the list of goals provided by this data source.\n   * @return {*[]}\n   */\n  getGoals() {\n    return [];\n  }\n\n  goalProgress(currValue, goal) {\n    return Math.max(0, Math.min(1, (currValue / goal) || 0));\n  }\n}\n\nmodule.exports = DataSource;\n","const DataSource = require('../data-source');\nconst { allDistancesToTileType } = require('../lib/distance');\nconst { getTileTypeId } = require('../lib/config-helpers');\nconst { regionAreas } = require('../lib/regions');\n\nclass GreenSpacesData extends DataSource {\n  constructor(city, config) {\n    super();\n    this.city = city;\n    this.config = config;\n\n    this.areas = [];\n    this.proximities = [];\n\n    this.numGreenSpaces = 0;\n    this.numGreenSpacesGoal = this.config.goals['green-spaces'].num || 20;\n\n    this.largeAreasSum = 0;\n    this.largeAreaThreshold = this.config.goals['green-spaces']['large-spaces-threshold'] || 3;\n    this.largeAreaSumGoal = this.config.goals['green-spaces']['large-spaces-area'] || 16;\n\n    this.medProximity = this.config.goals['green-spaces']['proximity-med'] || 5;\n    this.nearProximity = this.config.goals['green-spaces']['proximity-near'] || 3;\n    this.proximityGoalPercentage = this.config.goals['green-spaces']['proximity-goal-percentage'] || 0.75;\n\n    this.proximityThreshold = 0;\n    this.numMedProximity = 0;\n    this.numNearProximity = 0;\n\n    this.index = 1;\n  }\n\n  getVariables() {\n    return {\n      'green-spaces-areas': () => this.areas,\n      'green-spaces-proximity': () => this.proximities,\n      'green-spaces-index': () => this.index,\n    };\n  }\n\n  calculate() {\n    this.calculateAreas();\n    this.calculateProximities();\n    this.calculateIndex();\n  }\n\n  calculateAreas() {\n    const parkTileId = getTileTypeId(this.config, 'park');\n    const waterTileId = getTileTypeId(this.config, 'water');\n\n    this.areas = regionAreas(this.city.map, [parkTileId, waterTileId]);\n  }\n\n  calculateProximities() {\n    const residentialId = getTileTypeId(this.config, 'residential');\n    const parkTileId = getTileTypeId(this.config, 'park');\n    const waterTileId = getTileTypeId(this.config, 'water');\n    const allDistances = allDistancesToTileType(this.city.map, [parkTileId, waterTileId]);\n\n    this.proximities = [];\n    this.city.map.allCells().forEach(([x, y, tile]) => {\n      if (tile === residentialId) {\n        this.proximities.push(allDistances[y][x]);\n      }\n    });\n  }\n\n  calculateIndex() {\n    const parkTileId = getTileTypeId(this.config, 'park');\n    const waterTileId = getTileTypeId(this.config, 'water');\n\n    // Sum of the areas of green spaces with area of 3 or more\n    this.largeAreasSum = this.areas\n      .filter(area => area >= this.largeAreaThreshold)\n      .reduce((total, area) => total + area, 0);\n\n    const tileTypeCount = this.city.map.frequencyDistribution();\n    this.numGreenSpaces = (tileTypeCount[parkTileId] || 0)\n      + (tileTypeCount[waterTileId] || 0);\n\n    // Check how many green spaces are within 5 and 3 tiles distance\n    // from residential areas\n    this.numMedProximity = 0;\n    this.numNearProximity = 0;\n    this.proximities.forEach((distance) => {\n      if (distance <= this.medProximity) {\n        this.numMedProximity += 1;\n      }\n      if (distance <= this.nearProximity) {\n        this.numNearProximity += 1;\n      }\n    });\n\n    this.proximityThreshold = Math.floor(this.proximities.length * this.proximityGoalPercentage);\n    this.index = 1\n      + (this.largeAreasSum > this.largeAreaSumGoal ? 1 : 0)\n      + (this.numGreenSpaces > this.numGreenSpacesGoal ? 1 : 0)\n      + ((this.numGreenSpaces > this.numGreenSpacesGoal\n        && this.numMedProximity >= this.proximityThreshold) ? 1 : 0)\n      + ((this.numGreenSpaces > this.numGreenSpacesGoal\n        && this.numNearProximity >= this.proximityThreshold) ? 1 : 0);\n  }\n\n  getGoals() {\n    return [\n      {\n        id: 'green-spaces-count',\n        category: 'green-spaces',\n        priority: 1,\n        condition: this.numGreenSpaces > this.numGreenSpacesGoal,\n        progress: this.goalProgress(this.numGreenSpaces, this.numGreenSpacesGoal),\n      },\n      {\n        id: 'green-spaces-large-spaces-area',\n        category: 'green-spaces',\n        priority: 2,\n        condition: this.largeAreasSum > this.largeAreaSumGoal,\n        progress: this.goalProgress(this.largeAreasSum, this.largeAreaSumGoal),\n      },\n      {\n        id: 'green-spaces-proximity',\n        category: 'green-spaces',\n        priority: 3,\n        condition: this.numNearProximity >= this.proximityThreshold,\n        progress: this.goalProgress(this.numNearProximity, this.proximityThreshold),\n      },\n    ];\n  }\n}\n\nmodule.exports = GreenSpacesData;\n","const DataSource = require('../data-source');\nconst Array2D = require('../lib/array-2d');\nconst { getTileTypeId } = require('../lib/config-helpers');\nconst { percentageEqualValue, percentageOverEqValue } = require('../lib/statistics');\n\nclass NoiseData extends DataSource {\n  constructor(city, config) {\n    super();\n    this.city = city;\n    this.config = config;\n    this.noiseMap = Array2D.create(this.city.map.width, this.city.map.height);\n    this.noise = [];\n    this.residentialNoise = [];\n\n    this.maxLevel = this.config.goals.noise['max-noise-level'] || 1;\n    this.highLevel = this.config.goals.noise['high-noise-level'] || 0.5;\n    this.medLevel = this.config.goals.noise['med-noise-level'] || 0.25;\n\n    this.maxNoiseGoalPct = this.config.goals.noise['max-noise-goal-percentage'] || 0.05;\n    this.highNoiseGoalPct = this.config.goals.noise['high-noise-goal-percentage'] || 0.5;\n    this.residentialHighNoiseGoalPct = this.config.goals\n      .noise['residential-high-noise-goal-percentage'] || 0.5;\n    this.residentialMedNoiseGoalPct = this.config.goals\n      .noise['residential-med-noise-goal-percentage'] || 0.5;\n\n    this.maxNoisePct = 0;\n    this.highNoisePct = 0;\n    this.highNoiseResidentialPct = 0;\n    this.medNoiseResidentialPct = 0;\n  }\n\n  getVariables() {\n    return {\n      noise: () => this.noise,\n      'noise-residential': () => this.residentialNoise,\n      'noise-map': () => this.noiseMap,\n      'noise-index': () => this.getNoiseIndex(),\n    };\n  }\n\n  calculate() {\n    const noiseFactors = this.dataManager.getModifiers('noise-factors');\n    const noisePerTileType = Object.fromEntries(\n      Object.entries(this.config.tileTypes)\n        .map(([id, def]) => [id,\n          noiseFactors.reduce(\n            (acc, factors) => acc * (factors[this.config.tileTypes[id].type] || 1),\n            def.noise || 0\n          ),\n        ])\n    );\n    Array2D.setAll(this.noiseMap, 0);\n    Array2D.forEach(this.city.map.cells, (v, x, y) => {\n      const noise = noisePerTileType[v] || 0;\n      if (noise !== 0) {\n        this.noiseMap[y][x] += noise;\n        this.city.map.nearbyCoords(x, y, 1).forEach(([nx, ny]) => {\n          this.noiseMap[ny][nx] += noise * 0.5;\n        });\n      }\n    });\n    Array2D.forEach(this.noiseMap, (v, x, y) => {\n      this.noiseMap[y][x] = Math.min(NoiseData.MaxValue, Math.max(NoiseData.MinValue, v));\n    });\n\n    this.noise = Array2D.flatten(this.noiseMap);\n\n    this.residentialNoise = [];\n    const residentialTileId = getTileTypeId(this.config, 'residential');\n    Array2D.zip(this.city.map.cells, this.noiseMap, (tile, value) => {\n      if (tile === residentialTileId) {\n        this.residentialNoise.push(value);\n      }\n    });\n\n    this.maxNoisePct = percentageEqualValue(this.noise, this.maxLevel);\n    this.highNoisePct = percentageOverEqValue(this.noise, this.highLevel);\n    this.highNoiseResidentialPct = percentageOverEqValue(this.residentialNoise, this.highLevel);\n    this.medNoiseResidentialPct = percentageOverEqValue(this.residentialNoise, this.medLevel);\n  }\n\n  getNoiseIndex() {\n    return 1\n      // percentage of tiles with max noise under 5%\n      + (this.maxNoisePct < this.maxNoiseGoalPct ? 1 : 0)\n      // percentage of tiles with noise 0.5 or more under 50%\n      + (this.highNoisePct < this.highNoiseGoalPct ? 1 : 0)\n      // percentage of residential tiles with noise 0.5 or more under 50%\n      + (this.highNoiseResidentialPct < this.residentialHighNoiseGoalPct ? 1 : 0)\n      // percentage of residential tiles with noise 0.25 or more under 50%\n      + (this.medNoiseResidentialPct < this.residentialMedNoiseGoalPct ? 1 : 0);\n  }\n\n  getGoals() {\n    return [\n      {\n        id: 'noise-city',\n        category: 'noise',\n        priority: 1,\n        condition: this.highNoisePct < this.highNoiseGoalPct,\n        progress: this.goalProgress(1 - this.highNoisePct, 1 - this.highNoiseGoalPct),\n      },\n      {\n        id: 'noise-residential',\n        category: 'noise',\n        priority: 2,\n        condition: this.medNoiseResidentialPct < this.residentialMedNoiseGoalPct,\n        progress: this.goalProgress(1 - this.medNoiseResidentialPct,\n          1 - this.residentialMedNoiseGoalPct),\n      },\n      {\n        id: 'noise-max',\n        category: 'noise',\n        priority: 3,\n        condition: this.maxNoisePct < this.maxNoiseGoalPct,\n        progress: this.goalProgress(1 - this.maxNoisePct, 1 - this.maxNoiseGoalPct),\n      },\n    ];\n  }\n}\n\nNoiseData.MinValue = 0;\nNoiseData.MaxValue = 1;\n\nmodule.exports = NoiseData;\n","const DataSource = require('../data-source');\nconst Array2D = require('../lib/array-2d');\nconst { getTileTypeId } = require('../lib/config-helpers');\nconst { percentageEqualValue, percentageOverValue } = require('../lib/statistics');\n\nclass PollutionData extends DataSource {\n  constructor(city, config) {\n    super();\n    this.city = city;\n    this.config = config;\n\n    this.pollutionMap = Array2D.create(this.city.map.width, this.city.map.height);\n    this.pollution = [];\n    this.residentialPollution = [];\n\n    this.maxLevel = this.config.goals.pollution['max-pollution-level'] || 1;\n    this.highLevel = this.config.goals.pollution['high-pollution-level'] || 0.3;\n    this.highResidentialLevel = this.config.goals.pollution['high-residential-pollution-level'] || 0.2;\n    this.medResidentialLevel = this.config.goals.pollution['med-residential-pollution-level'] || 0.1;\n\n    this.maxPollutionGoalPct = this.config.goals.pollution['max-pollution-goal-percentage'] || 0.05;\n    this.highPollutionGoalPct = this.config.goals.pollution['high-pollution-goal-percentage'] || 0.5;\n    this.residentialHighPollutionGoalPct = this.config.goals\n      .pollution['residential-high-pollution-goal-percentage'] || 0.5;\n    this.residentialMedPollutionGoalPct = this.config.goals\n      .pollution['residential-med-pollution-goal-percentage'] || 0.5;\n\n    this.maxPollutionPct = 0;\n    this.highPollutionPct = 0;\n    this.residentialHighPollutionPct = 0;\n    this.residentialMedPollutionPct = 0;\n  }\n\n  getVariables() {\n    return {\n      pollution: () => this.pollution,\n      'pollution-residential': () => this.residentialPollution,\n      'pollution-map': () => this.pollutionMap,\n      'pollution-index': () => this.getPollutionIndex(),\n    };\n  }\n\n  calculate() {\n    const emissionFactors = this.dataManager.getModifiers('emissions-factors');\n    const emissionsPerTileType = Object.fromEntries(\n      Object.entries(this.config.tileTypes)\n        .map(([id, def]) => [id,\n          emissionFactors.reduce(\n            (acc, factors) => acc * (factors[this.config.tileTypes[id].type] || 1),\n            def.emissions || 0\n          ),\n        ])\n    );\n\n    Array2D.setAll(this.pollutionMap, 0);\n    Array2D.forEach(this.city.map.cells, (v, x, y) => {\n      const emissions = emissionsPerTileType[v] || 0;\n      if (emissions !== 0) {\n        this.pollutionMap[y][x] += emissions;\n        this.city.map.nearbyCoords(x, y, 1).forEach(([nx, ny]) => {\n          this.pollutionMap[ny][nx] += emissions * 0.5;\n        });\n        this.city.map.nearbyCoords(x, y, 2).forEach(([nx, ny]) => {\n          this.pollutionMap[ny][nx] += emissions * 0.25;\n        });\n      }\n    });\n    Array2D.forEach(this.pollutionMap, (v, x, y) => {\n      this.pollutionMap[y][x] = Math.min(PollutionData.MaxValue,\n        Math.max(PollutionData.MinValue, v));\n    });\n\n    this.pollution = Array2D.flatten(this.pollutionMap);\n\n    this.residentialPollution = [];\n    const residentialTileId = getTileTypeId(this.config, 'residential');\n    Array2D.zip(this.city.map.cells, this.pollutionMap, (tile, value) => {\n      if (tile === residentialTileId) {\n        this.residentialPollution.push(value);\n      }\n    });\n\n    this.maxPollutionPct = percentageEqualValue(this.pollution, this.maxLevel);\n    this.highPollutionPct = percentageOverValue(this.pollution, this.highLevel);\n    this.residentialHighPollutionPct = percentageOverValue(this.residentialPollution,\n      this.highResidentialLevel);\n    this.residentialMedPollutionPct = percentageOverValue(this.residentialPollution,\n      this.medResidentialLevel);\n  }\n\n  getPollutionIndex() {\n    return 1\n      // percentage of tiles with max pollution under 5%\n      + (this.maxPollutionPct < this.maxPollutionGoalPct ? 1 : 0)\n      // percentage of tiles with pollution 0.3 or more under 50%\n      + (this.highPollutionPct < this.highPollutionGoalPct ? 1 : 0)\n      // percentage of residential tiles with pollution 0.2 or more under 50%\n      + (this.residentialHighPollutionPct < this.residentialHighPollutionGoalPct ? 1 : 0)\n      // percentage of residential tiles with pollution 0.1 or more under 50%\n      + (this.residentialMedPollutionPct < this.residentialMedPollutionGoalPct ? 1 : 0);\n  }\n\n  getGoals() {\n    return [\n      {\n        id: 'pollution-city',\n        category: 'pollution',\n        priority: 1,\n        condition: this.highPollutionPct < this.highPollutionGoalPct,\n        progress: this.goalProgress(1 - this.highPollutionPct, 1 - this.highPollutionGoalPct),\n      },\n      {\n        id: 'pollution-residential',\n        category: 'pollution',\n        priority: 2,\n        condition: this.residentialMedPollutionPct < this.residentialMedPollutionGoalPct,\n        progress: this.goalProgress(1 - this.residentialMedPollutionPct,\n          1 - this.residentialMedPollutionGoalPct),\n      },\n      {\n        id: 'pollution-max',\n        category: 'pollution',\n        priority: 3,\n        condition: this.maxPollutionPct < this.maxPollutionGoalPct,\n        progress: this.goalProgress(1 - this.maxPollutionPct, 1 - this.maxPollutionGoalPct),\n      },\n    ];\n  }\n}\n\nPollutionData.MinValue = 0;\nPollutionData.MaxValue = 1;\n\nmodule.exports = PollutionData;\n","const DataSource = require('../data-source');\nconst { getTileTypeId } = require('../lib/config-helpers');\nconst Array2D = require('../lib/array-2d');\n\nclass RoadSafetyData extends DataSource {\n  constructor(city, config) {\n    super();\n    this.city = city;\n    this.config = config;\n\n    this.roadId = getTileTypeId(this.config, 'road');\n    this.tripleIntersectionsCount = 0;\n    this.quadIntersectionsCount = 0;\n    this.roadCount = 0;\n    this.intersectionPercentage = 0;\n\n    this.tripleIntersectionFactor = config.goals.safety['triple-intersection-factor'] || 1;\n    this.quadIntersectionFactor = config.goals.safety['quad-intersection-factor'] || 1;\n    this.intersectionPercHigh = config.goals.safety['intersection-percentage-high'] || 0.2;\n    this.intersectionPercMed = config.goals.safety['intersection-percentage-med'] || 0.1;\n  }\n\n  getVariables() {\n    return {\n      'road-triple-intersections-count': () => this.tripleIntersectionsCount,\n      'road-quad-intersections-count': () => this.quadIntersectionsCount,\n      'road-safety-index': () => this.getRoadSafetyIndex(),\n    };\n  }\n\n  calculate() {\n    this.roadCount = 0;\n    this.tripleIntersectionsCount = 0;\n    this.quadIntersectionsCount = 0;\n    Array2D.forEach(this.city.map.cells, (tile, x, y) => {\n      if (tile === this.roadId) {\n        this.roadCount += 1;\n        const adjacentRoadCount = this.city.map.adjacentCells(x, y)\n          .filter(([, , v]) => v === this.roadId).length;\n\n        if (adjacentRoadCount === 3) {\n          this.tripleIntersectionsCount += 1;\n        }\n\n        if (adjacentRoadCount === 4) {\n          this.quadIntersectionsCount += 1;\n        }\n      }\n    });\n\n    this.intersectionPercentage = (this.tripleIntersectionsCount * this.tripleIntersectionFactor\n        + this.quadIntersectionsCount * this.quadIntersectionFactor) / this.roadCount;\n  }\n\n  getRoadSafetyIndex() {\n    const base = 1\n      + (this.intersectionPercentage < this.intersectionPercHigh ? 1 : 0)\n      + (this.intersectionPercentage < this.intersectionPercMed ? 1 : 0);\n\n    return Math.max(1, Math.min(5,\n      this.dataManager.getModifiers('road-safety-index')\n        .reduce((acc, modifier) => acc + modifier, base)));\n  }\n\n  getGoals() {\n    return [\n      {\n        id: 'accidents-intersections',\n        category: 'roads',\n        priority: 2,\n        condition: this.intersectionPercentage < this.intersectionPercMed,\n        progress: this.goalProgress(1 - this.intersectionPercentage, 1 - this.intersectionPercMed),\n      },\n    ];\n  }\n}\n\nmodule.exports = RoadSafetyData;\n","const DataSource = require('../data-source');\n\nclass TrafficData extends DataSource {\n  constructor(city, config) {\n    super();\n    this.city = city;\n    this.config = config;\n\n    this.zoneCount = 0;\n    this.roadCount = 0;\n\n    this.goodDelta = config.goals['traffic-density']['road-zone-ratio-delta-good'] || 0.1;\n    this.fairDelta = config.goals['traffic-density']['road-zone-ratio-delta-fair'] || 0.35;\n  }\n\n  getVariables() {\n    return {\n      'traffic-density-index': () => this.getTrafficDensityIndex(),\n    };\n  }\n\n  calculate() {\n    this.zoneCount = this.dataManager.get('zones-residential-count')\n      + this.dataManager.get('zones-commercial-count')\n      + this.dataManager.get('zones-industrial-count');\n    this.roadCount = this.dataManager.get('zones-road-count');\n  }\n\n  getTrafficDensityIndex() {\n    const base = 1\n      + (this.zoneCount === 0\n        || (Math.abs(1 - (this.roadCount / this.zoneCount)) <= this.goodDelta) ? 1 : 0)\n      + (this.zoneCount === 0\n        || (Math.abs(1 - (this.roadCount / this.zoneCount)) <= this.fairDelta) ? 1 : 0);\n\n    return Math.max(1, Math.min(5,\n      this.dataManager.getModifiers('traffic-density-index')\n        .reduce((acc, modifier) => acc + modifier, base)));\n  }\n\n  getGoals() {\n    return [\n      {\n        id: 'road-count-high',\n        category: 'roads',\n        priority: 1,\n        condition: this.zoneCount === 0\n          || this.roadCount / this.zoneCount < 1 + this.goodDelta,\n        progress: this.goalProgress(this.zoneCount / this.roadCount, 1 - this.goodDelta),\n      },\n      {\n        id: 'road-count-low',\n        category: 'roads',\n        priority: 1,\n        condition: this.zoneCount === 0\n          || this.roadCount / this.zoneCount > 1 - this.goodDelta,\n        progress: this.goalProgress(this.roadCount / this.zoneCount, 1 - this.goodDelta),\n      },\n    ];\n  }\n}\n\nmodule.exports = TrafficData;\n","const DataSource = require('../data-source');\nconst { getTileTypeId } = require('../lib/config-helpers');\nconst Array2D = require('../lib/array-2d');\nconst TravelTimeCalculator = require('../lib/travel-times');\nconst { percentageOverValue } = require('../lib/statistics');\n\nclass TravelTimesData extends DataSource {\n  constructor(city, config) {\n    super();\n    this.city = city;\n    this.config = config;\n    this.data = [];\n    this.longTravelPercentage = 0;\n\n    this.residentialId = getTileTypeId(this.config, 'residential');\n    this.commercialId = getTileTypeId(this.config, 'commercial');\n    this.industrialId = getTileTypeId(this.config, 'industrial');\n\n    this.longTravelTime = this.config.goals['travel-times']['travel-time-long'] || 27;\n    this.levels = this.config.goals['travel-times']['travel-time-levels'] || [0.75, 0.55, 0.40, 0.25];\n\n    this.travelTimeCalculator = new TravelTimeCalculator(this.config);\n  }\n\n  getVariables() {\n    return {\n      'travel-times': () => this.data,\n      'travel-times-index': () => this.getTravelTimesIndex(),\n    };\n  }\n\n  timesFrom(startX, startY) {\n    const answer = [];\n    const data = this.travelTimeCalculator.travelTimes(this.city.map, [startX, startY]);\n\n    Array2D.zip(data, this.city.map.cells, (value, tile) => {\n      if (value !== 0 && (\n        tile === this.residentialId || tile === this.commercialId || tile === this.industrialId)) {\n        answer.push(value);\n      }\n    });\n\n    return answer;\n  }\n\n  calculate() {\n    this.data = [];\n    this.city.map.allCells().forEach(([x, y, tile]) => {\n      if (tile === this.residentialId || tile === this.commercialId || tile === this.industrialId) {\n        this.data.push(...this.timesFrom(x, y));\n      }\n    });\n\n    this.longTravelPercentage = percentageOverValue(this.data, this.longTravelTime);\n  }\n\n  getTravelTimesIndex() {\n    const base = 1\n      + (this.longTravelPercentage <= this.levels[0] ? 1 : 0)\n      + (this.longTravelPercentage <= this.levels[1] ? 1 : 0)\n      + (this.longTravelPercentage <= this.levels[2] ? 1 : 0)\n      + (this.longTravelPercentage <= this.levels[3] ? 1 : 0);\n\n    return Math.max(1, Math.min(5,\n      this.dataManager.getModifiers('travel-times-index')\n        .reduce((acc, modifier) => acc + modifier, base)));\n  }\n\n  getGoals() {\n    return [\n      {\n        id: 'travel-times-slow',\n        category: 'roads',\n        priority: 2,\n        condition: this.longTravelPercentage < this.levels[3],\n        progress: this.goalProgress(1 - this.longTravelPercentage, 1 - this.levels[3]),\n      },\n    ];\n  }\n}\n\nmodule.exports = TravelTimesData;\n","const DataSource = require('../data-source');\nconst { getTileTypeId } = require('../lib/config-helpers');\n\nclass ZoneBalanceData extends DataSource {\n  constructor(city, config) {\n    super();\n    this.city = city;\n    this.config = config;\n\n    this.tileTypeIds = {\n      residential: getTileTypeId(this.config, 'residential'),\n      commercial: getTileTypeId(this.config, 'commercial'),\n      industrial: getTileTypeId(this.config, 'industrial'),\n    };\n\n    this.idealPct = {\n      residential: this.config.goals['zone-balance']['ideal-residential-percentage'] || 0.5,\n      commercial: this.config.goals['zone-balance']['ideal-commercial-percentage'] || 0.25,\n      industrial: this.config.goals['zone-balance']['ideal-industrial-percentage'] || 0.25,\n    };\n\n    this.undervelopedPct = this.config.goals['zone-balance']['underdeveloped-percentage'] || 0.35;\n    this.overdevelopedPct = this.config.goals['zone-balance']['overdeveloped-percentage'] || 0.47;\n    this.acceptablePctDiff = this.config.goals['zone-balance']['acceptable-percentage-difference'] || 0.25;\n\n    this.amount = {\n      residential: 0,\n      commercial: 0,\n      industrial: 0,\n    };\n    this.underDevThreshold = {};\n    this.overDevThreshold = {};\n    const tileCount = this.city.map.width * this.city.map.height;\n\n    Object.keys(this.tileTypeIds).forEach((type) => {\n      this.underDevThreshold[type] = Math.round(\n        this.idealPct[type] * this.undervelopedPct * tileCount\n      );\n      this.overDevThreshold[type] = Math.round(\n        this.idealPct[type] * this.overdevelopedPct * tileCount\n      );\n    });\n\n    this.percentage = {\n      residential: 0,\n      commercial: 0,\n      industrial: 0,\n    };\n\n    this.difference = {\n      residential: 0,\n      commercial: 0,\n      industrial: 0,\n    };\n  }\n\n  getVariables() {\n    return {\n      'residential-percentage': () => this.percentage.residential,\n      'commercial-percentage': () => this.percentage.commercial,\n      'industrial-percentage': () => this.percentage.industrial,\n      'residential-difference': () => this.difference.residential,\n      'commercial-difference': () => this.difference.commercial,\n      'industrial-difference': () => this.difference.industrial,\n    };\n  }\n\n  calculate() {\n    Object.keys(this.tileTypeIds).forEach((type) => {\n      this.amount[type] = this.dataManager.get(`zones-${type}-count`);\n    });\n\n    const total = Object.values(this.amount)\n      .reduce((value, sum) => sum + value, 0);\n\n    Object.keys(this.tileTypeIds).forEach((type) => {\n      this.percentage[type] = total === 0 ? this.idealPct[type]\n        : (this.dataManager.get(`zones-${type}-count`) / total);\n\n      this.difference[type] = Math.min(\n        (this.percentage[type] - this.idealPct[type]) / this.idealPct[type],\n        1\n      );\n    });\n  }\n\n  getGoals() {\n    return [\n      {\n        id: 'zone-balance-r-low',\n        category: 'zone-balance',\n        priority: 1,\n        condition: this.amount.residential >= this.underDevThreshold.residential,\n        progress: this.goalProgress(1 + this.difference.residential, 1 - this.acceptablePctDiff),\n      },\n      {\n        id: 'zone-balance-i-low',\n        category: 'zone-balance',\n        priority: 1,\n        condition: this.amount.industrial >= this.underDevThreshold.industrial,\n        progress: this.goalProgress(1 + this.difference.industrial, 1 - this.acceptablePctDiff),\n      },\n      {\n        id: 'zone-balance-c-low',\n        category: 'zone-balance',\n        priority: 1,\n        condition: this.amount.commercial >= this.underDevThreshold.commercial,\n        progress: this.goalProgress(1 + this.difference.commercial, 1 - this.acceptablePctDiff),\n      },\n      {\n        id: 'zone-balance-r-high',\n        category: 'zone-balance',\n        priority: 2,\n        condition: this.amount.residential <= this.overDevThreshold.residential,\n        progress: this.goalProgress(1 - this.difference.residential, 1 - this.acceptablePctDiff),\n      },\n      {\n        id: 'zone-balance-i-high',\n        category: 'zone-balance',\n        priority: 2,\n        condition: this.amount.industrial <= this.overDevThreshold.industrial,\n        progress: this.goalProgress(1 - this.difference.industrial, 1 - this.acceptablePctDiff),\n      },\n      {\n        id: 'zone-balance-c-high',\n        category: 'zone-balance',\n        priority: 2,\n        condition: this.amount.commercial <= this.overDevThreshold.commercial,\n        progress: this.goalProgress(1 - this.difference.commercial, 1 - this.acceptablePctDiff),\n      },\n    ];\n  }\n}\n\nmodule.exports = ZoneBalanceData;\n","const DataSource = require('../data-source');\nconst Array2D = require('../lib/array-2d');\n\nclass ZoningData extends DataSource {\n  constructor(city, config) {\n    super();\n    this.city = city;\n    this.config = config;\n\n    this.numPerType = Object.fromEntries(\n      Object.keys(config.tileTypes).map(cellType => [cellType, 0])\n    );\n\n    this.total = this.city.map.width * this.city.map.height;\n  }\n\n  getVariables() {\n    const variables = {};\n\n    Object.keys(this.config.tileTypes).forEach((id) => {\n      const { type } = this.config.tileTypes[id];\n      variables[`zones-${type}-count`] = () => this.numPerType[id];\n    });\n\n    return Object.assign(variables, {\n      'zones-total': () => this.total,\n    });\n  }\n\n  calculate() {\n    Object.keys(this.numPerType).forEach((cellType) => { this.numPerType[cellType] = 0; });\n    Array2D.forEach(this.city.map.cells, (cellType) => {\n      this.numPerType[cellType] += 1;\n    });\n  }\n}\n\nmodule.exports = ZoningData;\n","const City = require('../city');\n\nclass CityBrowser {\n  constructor($element, config, cityStore, saveMode = false) {\n    this.$element = $element;\n    this.config = config;\n    this.$selectedButton = null;\n    this.selectedData = null;\n\n    this.$element.addClass('city-browser');\n\n    const setSelection = (button) => {\n      if (this.$selectedButton) {\n        this.$selectedButton.removeClass('selected');\n      }\n      this.$selectedButton = $(button);\n      this.$selectedButton.addClass('selected');\n    };\n\n    const buttons = Object.entries(\n      saveMode ? cityStore.getAllUserObjects() : cityStore.getAllObjects()\n    ).map(([id, cityJSON]) => $('<div></div>')\n      .addClass(['col-6', 'col-md-2', 'mb-3'])\n      .append(\n        $('<button></button>')\n          .addClass('city-browser-item')\n          .append(this.createPreviewImage(cityJSON))\n          .on('click', (ev) => {\n            setSelection(ev.currentTarget);\n            this.selectedData = id;\n          })\n      ));\n\n    if (saveMode) {\n      buttons.unshift($('<div></div>')\n        .addClass(['col-6', 'col-md-2', 'mb-3'])\n        .append($('<button></button>')\n          .addClass('city-browser-item-new')\n          .on('click', (ev) => {\n            setSelection(ev.currentTarget);\n            this.selectedData = 'new';\n          })));\n    }\n\n    this.$element.append($('<div class=\"row\"></div>').append(buttons));\n  }\n\n  createPreviewImage(cityJSON) {\n    const $canvas = $('<canvas class=\"city-browser-item-preview\"></canvas>')\n      .attr({\n        width: this.config.cityWidth,\n        height: this.config.cityHeight,\n      });\n    const city = City.fromJSON(cityJSON);\n    const ctx = $canvas[0].getContext('2d');\n    city.map.allCells().forEach(([i, j, value]) => {\n      ctx.fillStyle = (this.config.tileTypes && this.config.tileTypes[value].color) || '#000000';\n      ctx.fillRect(i, j, 1, 1);\n    });\n\n    return $canvas;\n  }\n}\n\nmodule.exports = CityBrowser;\n","const EventEmitter = require('events');\n\nclass MapEditorPalette {\n  constructor($element, config) {\n    this.$element = $element;\n    this.config = config;\n    this.activeButton = null;\n    this.tileId = null;\n    this.events = new EventEmitter();\n\n    this.$element.addClass('map-editor-palette');\n\n    this.buttons = Object.entries(config.tileTypes).map(([id, typeCfg]) => $('<button></button>')\n      .attr({\n        type: 'button',\n        title: typeCfg.name,\n      })\n      .addClass([\n        'editor-palette-button',\n        'editor-palette-button-tile',\n        `editor-palette-button-tile-${id}`,\n      ])\n      .css({\n        backgroundColor: typeCfg.color,\n        backgroundImage: `url(${typeCfg.editorIcon})`,\n      })\n      .on('click', (ev) => {\n        if (this.activeButton) {\n          this.activeButton.removeClass('active');\n        }\n        this.activeButton = $(ev.target);\n        this.activeButton.addClass('active');\n        this.tileId = Number(id);\n        this.events.emit('change', 'tile', Number(id));\n      }));\n\n    this.buttons.push($('<div class=\"separator\"></div>'));\n\n    this.toolButtons = MapEditorPalette.Tools.map(tool => $('<button></button>')\n      .attr({\n        type: 'button',\n        title: tool.title,\n      })\n      .addClass([\n        'editor-palette-button',\n        'editor-palette-button-tool',\n        `editor-palette-button-tool-${tool.id}`,\n      ])\n      .css({\n        backgroundImage: `url(${tool.icon})`,\n      })\n      .on('click', (ev) => {\n        if (this.activeButton) {\n          this.activeButton.removeClass('active');\n        }\n        this.activeButton = $(ev.target);\n        this.activeButton.addClass('active');\n        this.events.emit('change', tool.id);\n      }));\n\n    this.buttons.push(...this.toolButtons);\n\n    this.buttons.push($('<div class=\"separator\"></div>'));\n\n    const actionButtons = MapEditorPalette.Actions.map(action => $('<button></button>')\n      .attr({\n        type: 'button',\n        title: action.title,\n      })\n      .addClass([\n        'editor-palette-button',\n        'editor-palette-button-action',\n        `editor-palette-button-action-${action.id}`,\n      ])\n      .css({\n        backgroundImage: `url(${action.icon})`,\n      })\n      .on('click', () => {\n        this.events.emit('action', action.id);\n      }));\n\n    this.buttons.push(...actionButtons);\n\n    this.$element.append(this.buttons);\n    if (this.buttons.length) {\n      this.buttons[0].click();\n    }\n  }\n}\n\nMapEditorPalette.Actions = [\n  {\n    id: 'load',\n    title: 'Load map',\n    icon: 'static/fa/folder-open-solid.svg',\n  },\n  {\n    id: 'save',\n    title: 'Save map',\n    icon: 'static/fa/save-solid.svg',\n  },\n  {\n    id: 'import',\n    title: 'Import map',\n    icon: 'static/fa/file-import-solid.svg',\n  },\n  {\n    id: 'export',\n    title: 'Export map',\n    icon: 'static/fa/file-export-solid.svg',\n  },\n];\n\nMapEditorPalette.Tools = [\n  {\n    id: 'measureDistance',\n    title: 'Measure distance',\n    icon: 'static/fa/ruler-horizontal-solid.svg',\n  },\n  {\n    id: 'showPollution',\n    title: 'Show pollution',\n    icon: 'static/fa/smog-solid.svg',\n  },\n  {\n    id: 'showNoise',\n    title: 'Show noise',\n    icon: 'static/fa/drum-solid.svg',\n  },\n];\n\nmodule.exports = MapEditorPalette;\n","const EventEmitter = require('events');\nconst City = require('../city');\nconst MapView = require('../map-view');\nconst MapEditorPalette = require('./map-editor-palette');\nconst ModalLoad = require('./modal-load');\nconst ModalSave = require('./modal-save');\nconst ModalExport = require('./modal-export');\nconst ModalImport = require('./modal-import');\nconst ObjectStore = require('./object-store');\nconst MapTextOverlay = require('../map-text-overlay');\nconst { getTileTypeId } = require('../lib/config-helpers');\nconst Array2D = require('../lib/array-2d');\nconst VariableMapOverlay = require('../variable-map-overlay');\nconst TravelTimeCalculator = require('../lib/travel-times');\n\nclass MapEditor {\n  constructor($element, city, config, textures, dataManager) {\n    this.$element = $element;\n    this.city = city;\n    this.config = config;\n    this.dataManager = dataManager;\n\n    this.events = new EventEmitter();\n    this.mapView = new MapView(city, config, textures);\n    this.mapView.enableTileInteractivity();\n    this.displayObject = this.mapView.displayObject;\n    this.textOverlay = new MapTextOverlay(this.mapView);\n\n    this.variableMapOverlay = new VariableMapOverlay(this.mapView, this.config);\n    this.travelTimeCalculator = new TravelTimeCalculator(this.config);\n\n    this.palette = new MapEditorPalette($('<div></div>').appendTo(this.$element), config);\n\n    this.tool = 'nullTool';\n    this.tileType = this.palette.tileId;\n    this.palette.events.on('change', (tool, toolType) => {\n      if (this.tool) {\n        this.tools[this.tool].end();\n      }\n      this.tool = tool;\n      this.tileType = toolType;\n      this.tools[this.tool].start();\n    });\n\n    this.palette.events.on('action', (id) => {\n      if (this.actionHandlers[id]) {\n        this.actionHandlers[id]();\n      }\n    });\n\n    let lastEdit = null;\n    this.mapView.events.on('action',\n      (...args) => this.tools[this.tool].action(...args));\n\n    this.objectStore = new ObjectStore('./cities.json');\n    this.actionHandlers = {\n      load: () => {\n        const modal = new ModalLoad(this.config, this.objectStore);\n        modal.show().then((id) => {\n          const jsonCity = id && this.objectStore.get(id);\n          if (jsonCity) {\n            this.city.copy(City.fromJSON(jsonCity));\n          }\n        });\n      },\n      save: () => {\n        const modal = new ModalSave(this.config, this.objectStore);\n        modal.show().then((id) => {\n          if (id) {\n            this.objectStore.set(id === 'new' ? null : id, this.city.toJSON());\n          }\n        });\n      },\n      import: () => {\n        const modal = new ModalImport();\n        modal.show().then((importedData) => {\n          if (importedData) {\n            this.city.copy(City.fromJSON(importedData));\n          }\n        });\n      },\n      export: () => {\n        const modal = new ModalExport(JSON.stringify(this.city));\n        modal.show();\n      },\n    };\n\n    this.tools = {\n      nullTool: {\n        start: () => {},\n        end: () => {},\n        action: () => {},\n      },\n      tile: {\n        start: () => {\n          this.mapView.setEditCursor();\n        },\n        end: () => {\n\n        },\n        action: ([x, y], props) => {\n          if (this.tileType !== null) {\n            if (lastEdit && props.shiftKey) {\n              const [lastX, lastY] = lastEdit;\n              for (let i = Math.min(lastX, x); i <= Math.max(lastX, x); i += 1) {\n                for (let j = Math.min(lastY, y); j <= Math.max(lastY, y); j += 1) {\n                  this.city.map.set(i, j, this.tileType);\n                }\n              }\n            } else {\n              this.city.map.set(x, y, this.tileType);\n            }\n            lastEdit = [x, y];\n          }\n        },\n      },\n      measureDistance: {\n        start: () => {\n          this.mapView.setInspectCursor();\n          this.textOverlay.clear();\n          this.textOverlay.show();\n        },\n        end: () => {\n          this.textOverlay.hide();\n        },\n        action: ([startX, startY]) => {\n          const data = this.travelTimeCalculator\n            .travelTimes(this.mapView.city.map, [startX, startY]);\n          this.textOverlay.display(data);\n\n          const residentalId = getTileTypeId(config, 'residential');\n          const commercialId = getTileTypeId(config, 'commercial');\n          const industrialId = getTileTypeId(config, 'industrial');\n          Array2D.zip(data, city.map.cells, (value, tile, x, y) => {\n            data[y][x] = (\n              (tile === residentalId || tile === commercialId || tile === industrialId)\n                ? value : null\n            );\n          });\n\n          this.events.emit('inspect', {\n            title: `Trip len from (${startX}, ${startY}) to RCI`,\n            values: Array2D.flatten(data).filter(v => v !== null),\n          });\n        },\n      },\n      showPollution: {\n        start: () => {\n          this.mapView.setInspectCursor();\n          this.variableMapOverlay.show(\n            this.dataManager.get('pollution-map'),\n            this.config.variableMapOverlay.colors.pollution,\n          );\n        },\n        end: () => {\n          this.variableMapOverlay.hide();\n        },\n        action: () => {},\n      },\n      showNoise: {\n        start: () => {\n          this.mapView.setInspectCursor();\n          this.variableMapOverlay.show(\n            this.dataManager.get('noise-map'),\n            this.config.variableMapOverlay.colors.noise,\n          );\n        },\n        end: () => {\n          this.variableMapOverlay.hide();\n        },\n        action: () => {},\n      },\n    };\n  }\n\n  animate(time) {\n    this.variableMapOverlay.animate(time);\n  }\n}\n\nmodule.exports = MapEditor;\n","const Modal = require('../modal');\n\nclass ModalExport extends Modal {\n  constructor(exportData) {\n    super({\n      title: 'Export map',\n    });\n\n    this.$dataContainer = $('<textarea class=\"form-control\"></textarea>')\n      .attr({\n        rows: 10,\n      })\n      .text(exportData)\n      .appendTo(this.$body);\n\n    this.$copyButton = $('<button></button>')\n      .addClass(['btn', 'btn-outline-dark', 'btn-copy', 'mt-2'])\n      .text('Copy to clipboard')\n      .on('click', () => {\n        this.$dataContainer[0].select();\n        document.execCommand('copy');\n        this.hide();\n      })\n      .appendTo(this.$footer);\n  }\n}\n\nmodule.exports = ModalExport;\n","const Modal = require('../modal');\n\nclass ModalImport extends Modal {\n  constructor() {\n    super({\n      title: 'Import map',\n    });\n\n    this.$dataContainer = $('<textarea class=\"form-control\"></textarea>')\n      .attr({\n        rows: 10,\n        placeholder: 'Paste the JSON object here.',\n      })\n      .appendTo(this.$body);\n\n    // noinspection JSUnusedGlobalSymbols\n    this.$errorText = $('<p class=\"text-danger\"></p>')\n      .appendTo(this.$footer)\n      .hide();\n\n    // noinspection JSUnusedGlobalSymbols\n    this.$copyButton = $('<button></button>')\n      .addClass(['btn', 'btn-primary'])\n      .text('Import')\n      .on('click', () => {\n        try {\n          const imported = JSON.parse(this.$dataContainer.val());\n          this.hide(imported);\n        } catch (err) {\n          this.showError(err.message);\n        }\n      })\n      .appendTo(this.$footer);\n  }\n\n  showError(errorText) {\n    this.$errorText.html(errorText);\n    this.$errorText.show();\n  }\n}\n\nmodule.exports = ModalImport;\n","const Modal = require('../modal');\nconst CityBrowser = require('./city-browser');\n\nclass ModalLoad extends Modal {\n  constructor(config, cityStore) {\n    super({\n      title: 'Load map',\n      size: 'lg',\n    });\n\n    this.$browserContainer = $('<div></div>')\n      .appendTo(this.$body);\n    this.browser = new CityBrowser(this.$browserContainer, config, cityStore);\n\n    // noinspection JSUnusedGlobalSymbols\n    this.$cancelButton = $('<button></button>')\n      .addClass(['btn', 'btn-secondary'])\n      .text('Cancel')\n      .on('click', () => {\n        this.hide(null);\n      })\n      .appendTo(this.$footer);\n\n    // noinspection JSUnusedGlobalSymbols\n    this.$loadButton = $('<button></button>')\n      .addClass(['btn', 'btn-primary'])\n      .text('Load')\n      .on('click', () => {\n        try {\n          this.hide(this.browser.selectedData);\n        } catch (err) {\n          this.showError(err.message);\n        }\n      })\n      .appendTo(this.$footer);\n  }\n\n  showError(errorText) {\n    this.$errorText.html(errorText);\n    this.$errorText.show();\n  }\n}\n\nmodule.exports = ModalLoad;\n","const Modal = require('../modal');\nconst CityBrowser = require('./city-browser');\n\nclass ModalSave extends Modal {\n  constructor(config, cityStore) {\n    super({\n      title: 'Save map',\n      size: 'lg',\n    });\n\n    this.$browserContainer = $('<div></div>')\n      .appendTo(this.$body);\n    this.browser = new CityBrowser(this.$browserContainer, config, cityStore, true);\n\n    // noinspection JSUnusedGlobalSymbols\n    this.$cancelButton = $('<button></button>')\n      .addClass(['btn', 'btn-secondary'])\n      .text('Cancel')\n      .on('click', () => {\n        this.hide(null);\n      })\n      .appendTo(this.$footer);\n\n    // noinspection JSUnusedGlobalSymbols\n    this.$saveButton = $('<button></button>')\n      .addClass(['btn', 'btn-primary'])\n      .text('Save')\n      .on('click', () => {\n        try {\n          this.hide(this.browser.selectedData);\n        } catch (err) {\n          this.showError(err.message);\n        }\n      })\n      .appendTo(this.$footer);\n  }\n\n  showError(errorText) {\n    this.$errorText.html(errorText);\n    this.$errorText.show();\n  }\n}\n\nmodule.exports = ModalSave;\n","class ObjectStore {\n  constructor(fixedObjectsPath = null) {\n    this.fixedObjects = [];\n    this.userObjects = [];\n\n    this.loadUserObjects();\n    if (fixedObjectsPath) {\n      this.loadFixedObjects(fixedObjectsPath);\n    }\n  }\n\n  async loadFixedObjects(path) {\n    fetch(path, { cache: 'no-store' })\n      .then(response => response.json())\n      .then((data) => {\n        this.fixedObjects = data.cities;\n      });\n  }\n\n  loadUserObjects() {\n    const userObjects = JSON.parse(localStorage.getItem('futureMobility.cityStore.cities'));\n    if (userObjects) {\n      this.userObjects = userObjects;\n    }\n  }\n\n  saveLocal() {\n    localStorage.setItem('futureMobility.cityStore.cities', JSON.stringify(this.userObjects));\n  }\n\n  getAllObjects() {\n    return Object.assign(\n      {},\n      this.getAllUserObjects(),\n      this.getAllFixedObjects(),\n    );\n  }\n\n  getAllFixedObjects() {\n    return Object.fromEntries(this.fixedObjects.map((obj, i) => [\n      `F${i}`,\n      obj,\n    ]));\n  }\n\n  getAllUserObjects() {\n    return Object.fromEntries(this.userObjects.map((obj, i) => [\n      `L${i}`,\n      obj,\n    ]).reverse());\n  }\n\n  get(id) {\n    if (id[0] === 'F') {\n      return this.fixedObjects[id.substr(1)];\n    }\n    return this.userObjects[id.substr(1)];\n  }\n\n  set(id, obj) {\n    if (id === null || this.userObjects[id.substr(1)] === undefined) {\n      this.userObjects.push(obj);\n    } else {\n      this.userObjects[id.substr(1)] = obj;\n    }\n    this.saveLocal();\n  }\n}\n\nmodule.exports = ObjectStore;\n","class GoalDebugView {\n  constructor(goals) {\n    this.$element = $('<div></div>')\n      .addClass('goal-debug');\n\n    this.progress = Object.fromEntries(\n      goals.map(goal => [goal.id, $('<span></span>')\n        .addClass('goal-progress')])\n    );\n\n    this.items = Object.fromEntries(\n      goals.map(goal => [goal.id, $('<div></div>')\n        .append($('<span></span>').addClass('id').text(goal.id))\n        .append(this.progress[goal.id])\n        .appendTo(this.$element)])\n    );\n\n    this.values = Object.fromEntries(\n      goals.map(goal => [goal.id, {\n        met: null,\n        progress: null,\n      }])\n    );\n  }\n\n  setValues(goals) {\n    goals.forEach((goal) => {\n      if (this.values[goal.id].met !== goal.condition) {\n        this.values[goal.id].met = goal.condition;\n        this.items[goal.id].removeClass();\n        this.items[goal.id].addClass(goal.condition ? 'text-success' : 'text-danger');\n      }\n      if (this.values[goal.id].progress !== goal.progress) {\n        this.values[goal.id].progress = goal.progress;\n        this.progress[goal.id].text(` (${Math.round(goal.progress * 100)}%)`);\n      }\n    });\n  }\n}\n\nmodule.exports = GoalDebugView;\n","const EventEmitter = require('events');\nconst Array2D = require('./lib/array-2d');\n\n/**\n * Represents a 2D grid map that stores a single Number per cell\n */\nclass Grid {\n  /**\n   * Create a new grid\n   *\n   * @param {number} width\n   * @param {number} height\n   * @param {number[][]} cells\n   */\n  constructor(width, height, cells = null) {\n    this.width = width;\n    this.height = height;\n    this.cells = cells || Array2D.create(width, height, 0);\n    this.events = new EventEmitter();\n  }\n\n  /**\n   * Create a new Grid from a JSON string\n   *\n   * @param jsonObject {object} JSON object\n   * @return {Grid}\n   */\n  static fromJSON(jsonObject) {\n    const { width, height, cells } = jsonObject;\n    return new Grid(width, height, cells);\n  }\n\n  /**\n   * Serializes to a JSON object\n   * @return {{cells: number[][], width: number, height: number}}\n   */\n  toJSON() {\n    return {\n      width: this.width,\n      height: this.height,\n      cells: Array2D.clone(this.cells),\n    };\n  }\n\n  copy(grid) {\n    this.width = grid.width;\n    this.height = grid.height;\n    this.replace(grid.cells);\n  }\n\n  /**\n   * Retrieves the value at (x,y)\n   *\n   * @param {number} x\n   * @param {number} y\n   * @return {number}\n   */\n  get(x, y) {\n    return this.cells[y][x];\n  }\n\n  /**\n   * Set the value at (x, y)\n   *\n   * @fires Grid.events#update\n   *\n   * @param {number} x\n   * @param {number} y\n   * @param {number} value\n   */\n  set(x, y, value) {\n    this.cells[y][x] = value;\n\n    /**\n     * Update event.\n     *\n     * Argument is an array of updated cells. Each updated cell is represented\n     * by an array with three elements: [x, y, value]\n     *\n     * @event Grid.events#update\n     * @type {[[number, number, number]]}\n     */\n    this.events.emit('update', [[x, y, value]]);\n  }\n\n  /**\n   * Backwards compatibility function that maps (x, y) to a single index in a flat array\n   * @deprecated\n   * @param x {number}\n   * @param y {number}\n   * @return {number}\n   */\n  offset(x, y) {\n    return y * this.width + x;\n  }\n\n  replace(cells) {\n    Array2D.copy(cells, this.cells);\n    this.events.emit('update', this.allCells());\n  }\n\n  /**\n   * Returns true if (x, y) are valid coordinates within the grid's bounds.\n   *\n   * @param {number} x\n   * @param {number} y\n   * @return {boolean}\n   */\n  isValidCoords(x, y) {\n    return x >= 0 && y >= 0 && x < this.width && y < this.height;\n  }\n\n  /**\n   * Returns all cells, represented as [x, y, value] arrays.\n   *\n   * @return {[[number, number, number]]}\n   */\n  allCells() {\n    return Array2D.items(this.cells);\n  }\n\n  /**\n   * Get cells adjacent to the cell at (i, j).\n   *\n   * Each cell is represented by an array of the form [i, j, value]\n   * A cell has at most four adjacent cells, which share one side\n   * (diagonals are not adjacent).\n   *\n   * @param {number} i\n   * @param {number} j\n   * @return {[[number, number, number]]}\n   */\n  adjacentCells(i, j) {\n    return [[i, j - 1], [i + 1, j], [i, j + 1], [i - 1, j]]\n      .filter(([x, y]) => this.isValidCoords(x, y))\n      .map(([x, y]) => [x, y, this.get(x, y)]);\n  }\n\n  /**\n   * Returns the coordinates of cells around the cell at (x, y).\n   *\n   * Each cells returned is represented as an array [x, y].\n   * Cells \"around\" are those reachable by no less than <distance> steps in\n   * any direction, including diagonals.\n   *\n   * @param {number} x\n   * @param {number} y\n   * @param {number} distance\n   * @return {[[number, number]]}\n   */\n  nearbyCoords(x, y, distance) {\n    const coords = [];\n    // Top\n    for (let i = x - distance; i < x + distance; i += 1) {\n      coords.push([i, y - distance]);\n    }\n    // Right\n    for (let i = y - distance; i < y + distance; i += 1) {\n      coords.push([x + distance, i]);\n    }\n    // Bottom\n    for (let i = x + distance; i > x - distance; i -= 1) {\n      coords.push([i, y + distance]);\n    }\n    // Left\n    for (let i = y + distance; i > y - distance; i -= 1) {\n      coords.push([x - distance, i]);\n    }\n\n    return coords\n      .filter(([eachX, eachY]) => this.isValidCoords(eachX, eachY));\n  }\n\n  /**\n   * Returns the cells around the cell at (x, y).\n   *\n   * Each cells returned is represented as an array [x, y, value].\n   * Cells \"around\" are those reachable by no less than <distance> steps in\n   * any direction, including diagonals.\n   *\n   * @param {number} x\n   * @param {number} y\n   * @param {number} distance\n   * @return {[[number, number, number]]}\n   */\n  nearbyCells(x, y, distance = 1) {\n    return this.nearbyCoords(x, y, distance)\n      .map(([nx, ny]) => [nx, ny, this.get(nx, ny)]);\n  }\n\n  /**\n   * Returns the frequency distribution of the values\n   * stored in the cells.\n   *\n   * @return {Object.<string, number>}\n   */\n  frequencyDistribution() {\n    const answer = {};\n    Array2D.forEach(this.cells, (v) => {\n      answer[v] = answer[v] === undefined ? 0 : answer[v] + 1;\n    });\n\n    return answer;\n  }\n}\n\nmodule.exports = Grid;\n","const IndexView = require('./index-view');\n\nclass IndexListView {\n  constructor(config) {\n    this.config = config;\n    this.$element = $('<div></div>')\n      .addClass('index-list');\n\n    this.variableRankViews = Object.fromEntries(\n      Object.entries(config.variables)\n        .map(([id, def]) => [id, new IndexView(this.config, id, def)])\n    );\n\n    this.$element.append(\n      $('<div></div>').addClass('variables')\n        .append(...Object.values(this.variableRankViews).map(view => view.$element))\n    );\n  }\n\n  setValues(varValues) {\n    Object.entries(varValues).forEach(([id, value]) => {\n      if (this.variableRankViews[id] !== undefined) {\n        this.variableRankViews[id].setValue(value);\n      }\n    });\n  }\n}\n\nmodule.exports = IndexListView;\n","class IndexView {\n  constructor(config, id, definition) {\n    this.config = config;\n    this.id = id;\n    this.definition = definition;\n    this.languages = this.config.dashboard.languages;\n    this.mainLanguage = this.languages[0];\n    this.value = null;\n    this.$valueElement = $('<div></div>').addClass('value');\n    this.$element = $('<div></div>')\n      .addClass(['index', `index-${this.id}`])\n      .append([\n        $('<div></div>').addClass('description')\n          .append(\n            this.languages.map(lang => (\n              $('<div></div>')\n                .addClass(`name name-${lang}`)\n                .addClass(lang === this.mainLanguage ? 'name-main' : 'name-translation')\n                .text(this.definition.name[lang])\n            ))\n          ),\n        this.$valueElement,\n      ]);\n  }\n\n  setValue(value) {\n    if (value !== this.value) {\n      if (this.value !== null) {\n        this.$element.removeClass(`value-${this.value}`);\n      }\n      this.value = value;\n      this.$element.addClass(`value-${this.value}`);\n    }\n  }\n}\n\nmodule.exports = IndexView;\n","/**\n * This class provides helper functions to work with 2D arrays.\n * (arrays of arrays)\n */\nclass Array2D {\n  /**\n   * Create and initialize a 2D Array\n   *\n   * @param width {number} Number of columns (inner arrays size)\n   * @param height {number} Number of rows (outer array size)\n   * @param initValue {any} Initial value for inner array items\n   * @return {any[][]}\n   */\n  static create(width, height, initValue = 0) {\n    const rows = [];\n    for (let i = 0; i < height; i += 1) {\n      const row = [];\n      for (let j = 0; j < width; j += 1) {\n        row[j] = initValue;\n      }\n      rows.push(row);\n    }\n    return rows;\n  }\n\n  /**\n   * Creates a 2D array from a 1D array in cells[y * width + x] format\n   *\n   * @param width {number}\n   * @param height {number}\n   * @param cells {any[]}\n   */\n  static fromFlat(width, height, cells) {\n    const answer = Array2D.create(width, height);\n    for (let x = 0; x < width; x += 1) {\n      for (let y = 0; y < height; y += 1) {\n        answer[y][x] = cells[y * width + x];\n      }\n    }\n    return answer;\n  }\n\n  /**\n   * Returns a 1D array with the flattened contents of the 2D array\n   * @return {*[]}\n   */\n  static flatten(a) {\n    const items = [];\n    for (let y = 0; y < a.length; y += 1) {\n      for (let x = 0; x < a[y].length; x += 1) {\n        items.push(a[y][x]);\n      }\n    }\n    return items;\n  }\n\n  /**\n   * Returns true if the argument is an array of arrays and every inner\n   * array has the same length.\n   *\n   * @param a {any[][]}\n   * @return {boolean}\n   */\n  static isValid(a) {\n    return Array.isArray(a) && a.length > 0\n      && Array.isArray(a[0]) && a[0].length > 0\n      && a.every(row => row.length === a[0].length);\n  }\n\n  /**\n   * Returns the size of a 2D array as [width, height]\n   *\n   * Assumes the argument is a valid 2D Array.\n   *\n   * @param a {any[][]}\n   * @return {number[]}\n   */\n  static size(a) {\n    return [a[0].length, a.length];\n  }\n\n  /**\n   * Clones the 2D Array.\n   *\n   * Assumes the argument is a valid 2D Array. The items in the 2D\n   * array are not deep copied, only the outer and inner arrays.\n   *\n   * @param a {any[][]}\n   * @return {any[][]}\n   */\n  static clone(a) {\n    return a.map(row => Array.from(row));\n  }\n\n  /**\n   * Copies the contents of a 2D array into another.\n   *\n   * Assumes the arguments are valid 2D arrays with the same size.\n   *\n   * @param src {any[][]}\n   * @param dest {any[][]}\n   */\n  static copy(src, dest) {\n    for (let i = 0; i < src.length; i += 1) {\n      for (let j = 0; j < src[i].length; j += 1) {\n        // eslint-disable-next-line no-param-reassign\n        dest[i][j] = src[i][j];\n      }\n    }\n  }\n\n  /**\n   * Sets all cells to a fixed value\n   *\n   * @param a {any[][]}\n   * @param value {any}\n   */\n  static setAll(a, value) {\n    for (let y = 0; y < a.length; y += 1) {\n      for (let x = 0; x < a[y].length; x += 1) {\n        a[y][x] = value;\n      }\n    }\n  }\n\n  /**\n   * Returns all items as a flat array of [x, y, value] arrays.\n   *\n   * @param a {any[][]}\n   * @return {[number, number, any][]}\n   */\n  static items(a) {\n    const items = [];\n    for (let y = 0; y < a.length; y += 1) {\n      for (let x = 0; x < a[y].length; x += 1) {\n        items.push([x, y, a[y][x]]);\n      }\n    }\n    return items;\n  }\n\n  /**\n   * @callback coordinateCallback\n   * @param x {number}\n   * @param y {number}\n   * @return {any}\n   */\n  /**\n   * Fills the items in the array with the result of a callback\n   *\n   * @param a {any[][]}\n   * @param callback {coordinateCallback}\n   */\n  static fill(a, callback) {\n    for (let y = 0; y < a.length; y += 1) {\n      for (let x = 0; x < a[y].length; x += 1) {\n        a[y][x] = callback(x, y);\n      }\n    }\n  }\n\n  /**\n   * @callback reduceCallback\n   * @param accumulator {any}\n   * @param currentValue {any}\n   * @param x {number}\n   * @param y {number}\n   */\n  /**\n   *\n   * @param a {any[][]}\n   * @param callback {reduceCallback}\n   * @param initialValue {any}\n   * @return {any}\n   */\n  static reduce(a, callback, initialValue) {\n    let accumulator = initialValue;\n    for (let y = 0; y < a.length; y += 1) {\n      for (let x = 0; x < a[y].length; x += 1) {\n        accumulator = callback(accumulator, a[y][x], x, y);\n      }\n    }\n    return accumulator;\n  }\n\n  static forEach(a, callback) {\n    for (let y = 0; y < a.length; y += 1) {\n      for (let x = 0; x < a[y].length; x += 1) {\n        callback(a[y][x], x, y);\n      }\n    }\n  }\n\n  static zip(a, b, callback) {\n    const yMax = Math.min(a.length, b.length);\n    for (let y = 0; y < yMax; y += 1) {\n      const xMax = Math.min(a[y].length, b[y].length);\n      for (let x = 0; x < xMax; x += 1) {\n        callback(a[y][x], b[y][x], x, y);\n      }\n    }\n  }\n}\n\nmodule.exports = Array2D;\n","const all = ['N', 'E', 'S', 'W'];\n\nfunction opposite(direction) {\n  return {\n    N: 'S', E: 'W', S: 'N', W: 'E',\n  }[direction];\n}\n\nfunction ccw(direction) {\n  return {\n    N: 'W', E: 'N', S: 'E', W: 'S',\n  }[direction];\n}\n\nfunction cw(direction) {\n  return {\n    N: 'E', E: 'S', S: 'W', W: 'N',\n  }[direction];\n}\n\nfunction asVector(direction) {\n  return {\n    N: [0, -1], E: [1, 0], S: [0, 1], W: [-1, 0],\n  }[direction];\n}\n\nfunction asAngle(direction) {\n  return {\n    N: Math.PI, E: Math.PI * 1.5, S: 0, W: Math.PI * 0.5,\n  }[direction];\n}\n\nfunction adjCoords(x, y, direction) {\n  const [dx, dy] = asVector(direction);\n  return [x + dx, y + dy];\n}\n\nmodule.exports = {\n  all,\n  opposite,\n  ccw,\n  cw,\n  asVector,\n  asAngle,\n  adjCoords,\n};\n","function getTileTypeId(config, type) {\n  const entry = Object.entries(config.tileTypes).find(([, props]) => props.type === type);\n  return entry ? Number(entry[0]) : null;\n}\n\nfunction getTileType(config, type) {\n  const entry = Object.entries(config.tileTypes).find(([, props]) => props.type === type);\n  return entry ? entry[1] : null;\n}\n\nmodule.exports = { getTileTypeId, getTileType };\n","const Array2D = require('./array-2d');\n\nfunction allDistancesToTileType(map, tileTypeIds) {\n  const distances = Array2D.create(map.width, map.height, Infinity);\n  let distFromLast = Infinity;\n  // Forward pass\n  for (let y = 0; y !== map.cells.length; y += 1) {\n    distFromLast = Infinity;\n    for (let x = 0; x !== map.cells[y].length; x += 1) {\n      distFromLast = (tileTypeIds.includes(map.cells[y][x])) ? 0 : distFromLast + 1;\n      distances[y][x] = (y === 0) ? distFromLast : Math.min(distFromLast, distances[y - 1][x] + 1);\n    }\n  }\n\n  // Reverse pass\n  for (let y = map.cells.length - 1; y >= 0; y -= 1) {\n    for (let x = map.cells[y].length - 1; x >= 0; x -= 1) {\n      distances[y][x] = Math.min(\n        distances[y][x],\n        (y < map.cells.length - 1) ? distances[y + 1][x] + 1 : Infinity,\n        (x < map.cells[y].length - 1) ? distances[y][x + 1] + 1 : Infinity,\n      );\n    }\n  }\n\n  return distances;\n}\n\nmodule.exports = {\n  allDistancesToTileType,\n};\n","// https://github.com/mourner/flatqueue\n\n/**\n ISC License\n\n Copyright (c) 2021, Vladimir Agafonkin\n\n Permission to use, copy, modify, and/or distribute this software for any purpose\n with or without fee is hereby granted, provided that the above copyright notice\n and this permission notice appear in all copies.\n\n THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n THIS SOFTWARE.\n © 2021 GitHub, Inc.\n Terms\n Privacy\n\n */\nclass FlatQueue {\n\n  constructor() {\n    this.ids = [];\n    this.values = [];\n    this.length = 0;\n  }\n\n  clear() {\n    this.length = 0;\n  }\n\n  push(id, value) {\n    let pos = this.length++;\n    this.ids[pos] = id;\n    this.values[pos] = value;\n\n    while (pos > 0) {\n      const parent = (pos - 1) >> 1;\n      const parentValue = this.values[parent];\n      if (value >= parentValue) break;\n      this.ids[pos] = this.ids[parent];\n      this.values[pos] = parentValue;\n      pos = parent;\n    }\n\n    this.ids[pos] = id;\n    this.values[pos] = value;\n  }\n\n  pop() {\n    if (this.length === 0) return undefined;\n\n    const top = this.ids[0];\n    this.length--;\n\n    if (this.length > 0) {\n      const id = this.ids[0] = this.ids[this.length];\n      const value = this.values[0] = this.values[this.length];\n      const halfLength = this.length >> 1;\n      let pos = 0;\n\n      while (pos < halfLength) {\n        let left = (pos << 1) + 1;\n        const right = left + 1;\n        let bestIndex = this.ids[left];\n        let bestValue = this.values[left];\n        const rightValue = this.values[right];\n\n        if (right < this.length && rightValue < bestValue) {\n          left = right;\n          bestIndex = this.ids[right];\n          bestValue = rightValue;\n        }\n        if (bestValue >= value) break;\n\n        this.ids[pos] = bestIndex;\n        this.values[pos] = bestValue;\n        pos = left;\n      }\n\n      this.ids[pos] = id;\n      this.values[pos] = value;\n    }\n\n    return top;\n  }\n\n  peek() {\n    if (this.length === 0) return undefined;\n    return this.ids[0];\n  }\n\n  peekValue() {\n    if (this.length === 0) return undefined;\n    return this.values[0];\n  }\n\n  shrink() {\n    this.ids.length = this.values.length = this.length;\n  }\n}\n\nmodule.exports = FlatQueue;\n","/**\n * Create a function that picks an element from a set where each has a probability weight.\n *\n * The returned function can be called repeatedly to pick random elements.\n *\n * @param {[any, number]} weightedOptions\n *  An array of options. Each option is an array where the first\n *  item is the element, and the second is the weight.\n * @return {function(): any}\n *  Returns a function that returns a random element.\n */\nfunction weightedRandomizer(weightedOptions) {\n  let last = 0;\n  const ranges = new Array(weightedOptions.length);\n  // ranges = [from, to, value]\n  weightedOptions.forEach(([value, weight], i) => {\n    ranges[i] = [last, last + weight, value];\n    last += weight;\n  });\n\n  return () => {\n    const rndP = Math.random() * last;\n    return ranges.find(([min, max]) => rndP > min && rndP < max)[2];\n  };\n}\n\nfunction randomItem(items) {\n  return items[Math.floor(Math.random() * items.length)];\n}\n\nmodule.exports = {\n  weightedRandomizer,\n  randomItem,\n};\n","const Array2D = require('./array-2d');\n\nfunction regionAreas(map, tileTypeIds) {\n  const answer = [];\n  const seen = Array2D.create(map.width, map.height, false);\n\n  map.allCells().forEach(([x, y, value]) => {\n    if (seen[y][x] === false && tileTypeIds.includes(value)) {\n      const frontier = [[x, y]];\n      seen[y][x] = true;\n      let area = 0;\n      while (frontier.length > 0) {\n        const [currX, currY] = frontier.pop();\n        area += 1;\n        map.adjacentCells(currX, currY).forEach(([adjX, adjY, adjValue]) => {\n          if (seen[adjY][adjX] === false && tileTypeIds.includes(adjValue)) {\n            seen[adjY][adjX] = true;\n            frontier.push([adjX, adjY]);\n          }\n        });\n      }\n      answer.push(area);\n    }\n  });\n\n  return answer;\n}\n\nmodule.exports = {\n  regionAreas,\n};\n","function showFatalError(text, error) {\n  $('<div></div>')\n    .addClass('fatal-error')\n    .append($('<div></div>')\n      .addClass('fatal-error-text')\n      .html(text))\n    .append($('<div></div>')\n      .addClass('fatal-error-details')\n      .html(error.message))\n    .appendTo('body');\n\n  $('html').addClass('with-fatal-error');\n}\n\nmodule.exports = showFatalError;\n","class SpriteFader {\n  constructor(sprite) {\n    this.sprite = sprite;\n    this.callback = null;\n    this.duration = null;\n    this.startAlpha = null;\n    this.endAlpha = null;\n\n    this.visible = this.sprite.alpha !== 0;\n    this.isFading = false;\n  }\n\n  fadeIn(callback = null, duration = SpriteFader.DEFAULT_DURATION) {\n    if (!this.visible) {\n      this.visible = true;\n      this.startFade(0, 1, duration, callback);\n    }\n    if (callback) {\n      this.setCallback(callback);\n    }\n  }\n\n  fadeOut(callback = null, duration = SpriteFader.DEFAULT_DURATION) {\n    if (this.visible) {\n      this.visible = false;\n      this.startFade(1, 0, duration, callback);\n    }\n    if (callback) {\n      this.setCallback(callback);\n    }\n  }\n\n  setCallback(callback) {\n    if (this.isFading) {\n      this.callback = callback;\n    } else {\n      setTimeout(() => { callback(); }, 0);\n    }\n  }\n\n  startFade(startAlpha, endAlpha, duration = SpriteFader.DEFAULT_DURATION, callback = null) {\n    this.callback = callback;\n    this.startAlpha = startAlpha;\n    this.endAlpha = endAlpha;\n    this.duration = duration;\n    this.isFading = true;\n    this.timer = 0;\n  }\n\n  onFadeEnd() {\n    if (this.callback) {\n      setTimeout(() => {\n        this.callback();\n        this.callback = null;\n      }, 0);\n    }\n    this.isFading = false;\n    this.startAlpha = null;\n    this.endAlpha = null;\n    this.duration = null;\n    this.timer = 0;\n  }\n\n  animate(time) {\n    if (this.isFading) {\n      this.timer = Math.min(this.duration, this.timer + time);\n      this.sprite.alpha = this.startAlpha\n        + (this.endAlpha - this.startAlpha) * (this.timer / this.duration);\n      if (this.timer === this.duration) {\n        this.onFadeEnd();\n      }\n    }\n  }\n}\n\nSpriteFader.DEFAULT_DURATION = 20;\n\nmodule.exports = SpriteFader;\n","function average(data) {\n  return data.length > 0 ? data.reduce((a, b) => a + b, 0) / data.length : undefined;\n}\n\nfunction sortedQuantile(sortedData, q) {\n  if (sortedData.length === 0) {\n    return undefined;\n  }\n  const pos = (sortedData.length - 1) * q;\n  const base = Math.floor(pos);\n  const rest = pos - base;\n  if (sortedData[base + 1] !== undefined) {\n    return sortedData[base] + rest * (sortedData[base + 1] - sortedData[base]);\n  }\n  return sortedData[base];\n}\n\nfunction quantile(data, q) {\n  return sortedQuantile(data.sort((a, b) => a - b), q);\n}\n\nfunction median(data) {\n  return quantile(data, 0.5);\n}\n\nfunction sortedMedian(data) {\n  return sortedQuantile(data, 0.5);\n}\n\nfunction firstQuartile(data) {\n  return quantile(data, 0.25);\n}\n\nfunction sortedFirstQuartile(data) {\n  return sortedQuantile(data, 0.25);\n}\n\nfunction thirdQuartile(data) {\n  return quantile(data, 0.75);\n}\n\nfunction sortedThirdQuartile(data) {\n  return sortedQuantile(data, 0.75);\n}\n\nfunction numberUnderValue(data, k) {\n  let count = 0;\n  for (let i = 0; i < data.length; i += 1) {\n    if (data[i] < k) {\n      count += 1;\n    }\n  }\n\n  return count;\n}\n\nfunction percentageUnderValue(data, k) {\n  return data.length > 0 ? numberUnderValue(data, k) / data.length : 1;\n}\n\nfunction numberOverValue(data, k) {\n  let count = 0;\n  for (let i = 0; i < data.length; i += 1) {\n    if (data[i] > k) {\n      count += 1;\n    }\n  }\n\n  return count;\n}\n\nfunction percentageOverValue(data, k) {\n  return data.length > 0 ? numberOverValue(data, k) / data.length : 1;\n}\n\nfunction numberOverEqValue(data, k) {\n  let count = 0;\n  for (let i = 0; i < data.length; i += 1) {\n    if (data[i] >= k) {\n      count += 1;\n    }\n  }\n\n  return count;\n}\n\nfunction percentageOverEqValue(data, k) {\n  return data.length > 0 ? numberOverEqValue(data, k) / data.length : 1;\n}\n\nfunction numberEqualValue(data, k) {\n  let count = 0;\n  for (let i = 0; i < data.length; i += 1) {\n    if (data[i] === k) {\n      count += 1;\n    }\n  }\n\n  return count;\n}\n\nfunction percentageEqualValue(data, k) {\n  return data.length > 0 ? numberEqualValue(data, k) / data.length : 1;\n}\n\nmodule.exports = {\n  average,\n  quantile,\n  sortedQuantile,\n  median,\n  sortedMedian,\n  firstQuartile,\n  sortedFirstQuartile,\n  thirdQuartile,\n  sortedThirdQuartile,\n  numberUnderValue,\n  percentageUnderValue,\n  numberOverValue,\n  percentageOverValue,\n  numberOverEqValue,\n  percentageOverEqValue,\n  numberEqualValue,\n  percentageEqualValue,\n};\n","const FlatQueue = require('./flatqueue');\nconst Array2D = require('./array-2d');\nconst { getTileTypeId } = require('.//config-helpers');\n\nclass TravelTimeCalculator {\n  constructor(config) {\n    this.config = config;\n\n    this.roadTileTime = this.config.goals['travel-times']['road-travel-time'];\n    this.defaultTileTime = this.config.goals['travel-times']['default-travel-time'];\n    this.slowTileTime = this.config.goals['travel-times']['slow-travel-time'];\n\n    this.emptyId = getTileTypeId(this.config, 'empty');\n    this.roadId = getTileTypeId(this.config, 'road');\n    this.waterId = getTileTypeId(this.config, 'water');\n  }\n\n  /**\n   * Given a city map and a starting point it returns the travel time to all other cells.\n   *\n   * Uses [Uniform Cost Search](https://www.redblobgames.com/pathfinding/a-star/introduction.html),\n   * a variation on Dijkstra's algorithm.\n   *\n   * @param {Grid} map\n   * @param {number} startX\n   * @param {number} startY\n   * @return {number[][]}\n   */\n  travelTimes(map, [startX, startY]) {\n    const answer = Array2D.create(map.width, map.height, null);\n    const frontier = new FlatQueue();\n    frontier.push([startX, startY, map.get(startX, startY)], 0);\n    answer[startY][startX] = 0;\n\n    while (frontier.length > 0) {\n      const [currX, currY, currTile] = frontier.pop();\n      map.adjacentCells(currX, currY)\n        .forEach(([nextX, nextY, nextTile]) => {\n          const newCost = answer[currY][currX] + this.timeBetweenTiles(currTile, nextTile);\n          const nextCost = answer[nextY][nextX];\n          if (nextCost === null || newCost < nextCost) {\n            answer[nextY][nextX] = newCost;\n            frontier.push([nextX, nextY, nextTile], newCost);\n          }\n        });\n    }\n\n    return answer;\n  }\n\n  /**\n   * Returns the travel time between two tiles based on their types.\n   *\n   * @param tileTypeFrom\n   * @param tileTypeTo\n   * @return {Number}\n   */\n  timeBetweenTiles(tileTypeFrom, tileTypeTo) {\n    if (tileTypeFrom === this.roadId && tileTypeTo === this.roadId) {\n      return this.roadTileTime;\n    }\n    if (tileTypeFrom === this.waterId || tileTypeTo === this.waterId\n      || tileTypeFrom === this.emptyId || tileTypeTo === this.emptyId) {\n      return this.slowTileTime;\n    }\n    return this.defaultTileTime;\n  }\n}\n\nmodule.exports = TravelTimeCalculator;\n","/* globals PIXI */\n\nconst MapView = require('./map-view');\nconst Array2D = require('./lib/array-2d');\n\nclass MapTextOverlay {\n  constructor(mapView) {\n    this.mapView = mapView;\n    this.visible = false;\n    this.fontSize = (18 / 72) * MapView.TILE_SIZE;\n    this.texts = Array2D.create(\n      this.mapView.city.map.width,\n      this.mapView.city.map.height,\n      null\n    );\n\n    this.displayObject = new PIXI.Container();\n    this.displayObject.visible = this.visible;\n    this.displayObject.zIndex = 1000;\n    this.mapView.addOverlay(this.displayObject);\n    this.createBackground();\n    this.createTexts();\n  }\n\n  createBackground() {\n    const background = new PIXI.Graphics();\n    background.beginFill(0, 0.75)\n      .drawRect(0, 0, this.mapView.displayObject.width, this.mapView.displayObject.height)\n      .endFill();\n    this.displayObject.addChild(background);\n  }\n\n  createTexts() {\n    Array2D.fill(this.texts, (x, y) => {\n      const text = new PIXI.Text('', {\n        fontFamily: 'Arial',\n        fontSize: this.fontSize,\n        fill: 'white',\n        align: 'center',\n      });\n      text.anchor.set(0.5, 0.5);\n      text.position.set(\n        MapView.TILE_SIZE * (x + 0.5),\n        MapView.TILE_SIZE * (y + 0.5)\n      );\n      this.displayObject.addChild(text);\n      return text;\n    });\n  }\n\n  clear() {\n    Array2D.forEach(this.texts, (each) => { each.text = ''; });\n  }\n\n  display(data) {\n    Array2D.zip(this.texts, data, (eachText, eachDataItem) => {\n      eachText.text = typeof eachDataItem === 'number' ? eachDataItem.toFixed(2) : eachDataItem;\n    });\n  }\n\n  show() {\n    this.visible = true;\n    this.displayObject.visible = true;\n  }\n\n  hide() {\n    this.visible = false;\n    this.displayObject.visible = false;\n  }\n}\n\nmodule.exports = MapTextOverlay;\n","/* globals PIXI */\nconst EventEmitter = require('events');\nconst Array2D = require('./lib/array-2d');\nconst { getTileTypeId } = require('./lib/config-helpers');\nconst PencilCursor = require('../../static/fa/pencil-alt-solid.svg');\n\nclass MapView {\n  constructor(city, config, textures) {\n    this.city = city;\n    this.config = config;\n    this.textures = textures;\n    this.events = new EventEmitter();\n    this.roadTileId = getTileTypeId(config, 'road');\n    this.parkTileId = getTileTypeId(config, 'park');\n    this.waterTileId = getTileTypeId(config, 'water');\n    this.roadTextureKey = 'roads';\n    this.roadTexturePrefix = 'road';\n    this.basicTileRenderers = {};\n\n    this.randomizedTerrain = Array2D.create(this.city.map.width, this.city.map.height);\n    Array2D.fill(this.randomizedTerrain, () => Math.random());\n\n    this.displayObject = new PIXI.Container();\n\n    this.bgTiles = Array2D.create(this.city.map.width, this.city.map.height, null);\n    this.textureTiles = Array2D.create(this.city.map.width, this.city.map.height, null);\n\n    this.city.map.allCells().forEach(([x, y]) => {\n      const bgTile = new PIXI.Graphics();\n      bgTile.x = x * MapView.TILE_SIZE;\n      bgTile.y = y * MapView.TILE_SIZE;\n      this.bgTiles[y][x] = bgTile;\n\n      const textureTile = new PIXI.Sprite();\n      textureTile.x = x * MapView.TILE_SIZE;\n      textureTile.y = y * MapView.TILE_SIZE;\n      textureTile.width = MapView.TILE_SIZE;\n      textureTile.height = MapView.TILE_SIZE;\n      textureTile.roundPixels = true;\n      this.textureTiles[y][x] = textureTile;\n      this.renderTile(x, y);\n    });\n\n    this.zoningLayer = new PIXI.Container();\n    this.zoningLayer.addChild(...Array2D.flatten(this.bgTiles));\n    this.displayObject.addChild(this.zoningLayer);\n    this.tileTextureLayer = new PIXI.Container();\n    this.tileTextureLayer.addChild(...Array2D.flatten(this.textureTiles));\n    this.displayObject.addChild(this.tileTextureLayer);\n    this.overlayContainer = new PIXI.Container();\n    this.displayObject.addChild(this.overlayContainer);\n    this.gridOverlay = this.createGridOverlay();\n    this.displayObject.addChild(this.gridOverlay);\n    if (this.config.mapView && this.config.mapView.gridOverlay) {\n      this.renderGrid(this.config.mapView.gridOverlay);\n    }\n\n    this.city.map.events.on('update', this.handleCityUpdate.bind(this));\n    this.handleCityUpdate(this.city.map.allCells());\n  }\n\n  addOverlay(displayObject) {\n    this.overlayContainer.addChild(displayObject);\n    this.overlayContainer.sortChildren();\n  }\n\n  createGridOverlay() {\n    const overlay = new PIXI.Graphics();\n    overlay.x = 0;\n    overlay.y = 0;\n    overlay.width = this.city.map.width * MapView.TILE_SIZE;\n    overlay.height = this.city.map.height * MapView.TILE_SIZE;\n\n    return overlay;\n  }\n\n  setEditCursor() {\n    Array2D.items(this.bgTiles).forEach(([,, bgTile]) => {\n      bgTile.cursor = `url(${PencilCursor}) 0 20, auto`;\n    });\n  }\n\n  setInspectCursor() {\n    Array2D.items(this.bgTiles).forEach(([,, bgTile]) => {\n      bgTile.cursor = 'crosshair';\n    });\n  }\n\n  getCoordsAtPosition(globalPoint) {\n    if (this.origin === undefined) {\n      this.origin = new PIXI.Point();\n    }\n    this.origin = this.displayObject.getGlobalPosition(this.origin, false);\n\n    const x = Math.floor((globalPoint.x - this.origin.x)\n      / this.displayObject.scale.x / MapView.TILE_SIZE);\n    const y = Math.floor((globalPoint.y - this.origin.y)\n      / this.displayObject.scale.y / MapView.TILE_SIZE);\n\n    return (x >= 0 && x < this.city.map.width && y >= 0 && y < this.city.map.height)\n      ? { x, y } : null;\n  }\n\n  enableTileInteractivity() {\n    const pointers = {};\n\n    Array2D.items(this.bgTiles).forEach(([x, y, bgTile]) => {\n      bgTile.interactive = true;\n      bgTile.cursor = `url(${PencilCursor}) 0 20, auto`;\n      bgTile.on('pointerdown', (ev) => {\n        // this.pointerActive = true;\n        pointers[ev.data.pointerId] = { lastTile: { x, y } };\n        this.events.emit('action', [x, y], {\n          shiftKey: ev.data.originalEvent.shiftKey,\n        });\n      });\n    });\n\n    this.zoningLayer.interactive = true;\n    this.zoningLayer.on('pointermove', (ev) => {\n      if (pointers[ev.data.pointerId] !== undefined) {\n        const tileCoords = this.getCoordsAtPosition(ev.data.global);\n        if (pointers[ev.data.pointerId].lastTile !== tileCoords) {\n          if (tileCoords) {\n            this.events.emit('action', [tileCoords.x, tileCoords.y], {\n              shiftKey: ev.data.originalEvent.shiftKey,\n            });\n          }\n          pointers[ev.data.pointerId].lastTile = tileCoords;\n        }\n      }\n    });\n\n    const onEndPointer = (ev) => {\n      delete pointers[ev.data.pointerId];\n    };\n\n    this.zoningLayer.on('pointerup', onEndPointer);\n    this.zoningLayer.on('pointerupoutside', onEndPointer);\n    this.zoningLayer.on('pointercancel', onEndPointer);\n  }\n\n  getBgTile(x, y) {\n    return this.bgTiles[y][x];\n  }\n\n  getTextureTile(x, y) {\n    return this.textureTiles[y][x];\n  }\n\n  renderTile(x, y) {\n    this.renderBasicTile(x, y);\n    if (this.city.map.get(x, y) === this.parkTileId) {\n      this.renderParkTile(x, y);\n    }\n    if (this.city.map.get(x, y) === this.waterTileId) {\n      this.renderWaterTile(x, y);\n    }\n    if (this.city.map.get(x, y) === this.roadTileId) {\n      this.renderRoadTile(x, y);\n    }\n  }\n\n  renderParkTile(x, y) {\n    const textureNumber = 1 + Math.round(this.randomizedTerrain[y][x] * 8);\n    this.getTextureTile(x, y).texture = this.textures.parks[`park-0${textureNumber}`];\n    this.getTextureTile(x, y).visible = true;\n  }\n\n  renderWaterTile(x, y) {\n    const textureNumber = 1 + Math.round(this.randomizedTerrain[y][x] * 8);\n    this.getTextureTile(x, y).texture = this.textures.water[`water-0${textureNumber}`];\n    this.getTextureTile(x, y).visible = true;\n  }\n\n  renderRoadTile(i, j) {\n    const connMask = [[i, j - 1], [i + 1, j], [i, j + 1], [i - 1, j]]\n      .map(([x, y]) => (!this.city.map.isValidCoords(x, y)\n      || this.city.map.get(x, y) === this.roadTileId\n        ? '1' : '0')).join('');\n    this.getTextureTile(i, j).texture = this.textures[this.roadTextureKey][`${this.roadTexturePrefix}${connMask}`];\n    this.getTextureTile(i, j).visible = true;\n  }\n\n  renderBasicTile(i, j) {\n    const tileType = this.config.tileTypes[this.city.map.get(i, j)] || null;\n    if (this.basicTileRenderers[tileType.type]) {\n      this.basicTileRenderers[tileType.type](i, j);\n    } else {\n      this.getBgTile(i, j)\n        .clear()\n        .beginFill(tileType ? Number(`0x${tileType.color.substr(1)}`) : 0, 1)\n        .drawRect(0, 0, MapView.TILE_SIZE, MapView.TILE_SIZE)\n        .endFill();\n    }\n    this.getTextureTile(i, j).visible = false;\n  }\n\n  renderGrid(strokeWidth) {\n    const viewWidth = this.city.map.width * MapView.TILE_SIZE;\n    const viewHeight = this.city.map.height * MapView.TILE_SIZE;\n    this.gridOverlay.clear();\n    this.gridOverlay\n      .lineStyle(strokeWidth / 2, 0, 1, 1)\n      .moveTo(strokeWidth / 2, viewHeight - strokeWidth / 2)\n      .lineTo(strokeWidth / 2, strokeWidth / 2)\n      .lineTo(viewWidth - strokeWidth / 2, strokeWidth / 2)\n      .lineTo(viewWidth - strokeWidth / 2, viewHeight - strokeWidth / 2)\n      .lineTo(strokeWidth / 2, viewHeight - strokeWidth / 2)\n      .lineTo(strokeWidth / 2, viewHeight - strokeWidth);\n\n    this.gridOverlay.lineStyle(strokeWidth, 0, 1);\n    for (let i = 1; i < this.city.map.width; i += 1) {\n      this.gridOverlay.moveTo(i * MapView.TILE_SIZE, strokeWidth / 2)\n        .lineTo(i * MapView.TILE_SIZE, viewHeight - strokeWidth / 2);\n    }\n    for (let i = 1; i < this.city.map.height; i += 1) {\n      this.gridOverlay.moveTo(strokeWidth / 2, i * MapView.TILE_SIZE)\n        .lineTo(viewWidth - strokeWidth / 2, i * MapView.TILE_SIZE);\n    }\n  }\n\n  handleCityUpdate(updates) {\n    updates.forEach(([i, j]) => {\n      this.renderTile(i, j);\n      // Todo: This should be optimized so it's not called twice per frame for the same tile.\n      this.city.map.adjacentCells(i, j)\n        .filter(([x, y]) => this.city.map.get(x, y) === this.roadTileId)\n        .forEach(([x, y]) => this.renderRoadTile(x, y));\n    });\n  }\n\n  showGrid() {\n    this.gridOverlay.visible = true;\n  }\n\n  hideGrid() {\n    this.gridOverlay.visible = false;\n  }\n}\n\nMapView.TILE_SIZE = 72;\n\nmodule.exports = MapView;\n","class Modal {\n  /**\n   * @param {object} options\n   *  Modal dialog options\n   * @param {string} options.title\n   *  Dialog title.\n   * @param {string} options.size\n   *  Modal size (lg or sm).\n   * @param {boolean} options.showCloseButton\n   *  Shows a close button in the dialog if true.\n   * @param {boolean} options.showFooter\n   *  Adds a footer area to the dialog if true.\n   */\n  constructor(options) {\n    this.returnValue = null;\n\n    this.$element = $('<div class=\"modal fade\"></div>');\n    this.$dialog = $('<div class=\"modal-dialog\"></div>').appendTo(this.$element);\n    this.$content = $('<div class=\"modal-content\"></div>').appendTo(this.$dialog);\n    this.$header = $('<div class=\"modal-header\"></div>').appendTo(this.$content);\n    this.$body = $('<div class=\"modal-body\"></div>').appendTo(this.$content);\n    this.$footer = $('<div class=\"modal-footer\"></div>').appendTo(this.$content);\n\n    this.$closeButton = $('<button type=\"button\" class=\"close\" data-dismiss=\"modal\">')\n      .append($('<span>&times;</span>'))\n      .appendTo(this.$header);\n\n    if (options.title) {\n      $('<h5 class=\"modal-title\"></h5>')\n        .html(options.title)\n        .prependTo(this.$header);\n    }\n    if (options.size) {\n      this.$dialog.addClass(`modal-${options.size}`);\n    }\n\n    if (options.showCloseButton === false) {\n      this.$closeButton.remove();\n    }\n    if (options.showFooter === false) {\n      this.$footer.remove();\n    }\n  }\n\n  async show() {\n    return new Promise((resolve) => {\n      $('body').append(this.$element);\n      this.$element.modal();\n      this.$element.on('hidden.bs.modal', () => {\n        this.$element.remove();\n        resolve(this.returnValue);\n      });\n    });\n  }\n\n  hide(returnValue) {\n    this.returnValue = returnValue;\n    this.$element.modal('hide');\n  }\n}\n\nmodule.exports = Modal;\n","/* eslint-disable no-underscore-dangle */\nclass PowerUpDataModifier {\n  constructor(config, powerUpManager) {\n    this.config = config;\n    this.manager = powerUpManager;\n  }\n\n  getModifiers(variableId) {\n    const modifiers = [];\n\n    this.manager.activePowerUps().forEach((powerUp) => {\n      if (this.config.powerUps[powerUp] && this.config.powerUps[powerUp].modifiers\n        && this.config.powerUps[powerUp].modifiers[variableId]) {\n        modifiers.push(this.config.powerUps[powerUp].modifiers[variableId]);\n      }\n\n      if (this.config.powerUps[powerUp] && this.config.powerUps[powerUp].modifiers\n        && this.config.powerUps[powerUp].modifiers._synergy) {\n        Object.keys(this.config.powerUps[powerUp].modifiers._synergy)\n          .forEach((synergyPowerUp) => {\n            if (this.manager.powerUps[synergyPowerUp]\n              && this.config.powerUps[powerUp].modifiers\n              && this.config.powerUps[powerUp].modifiers._synergy\n              && this.config.powerUps[powerUp].modifiers._synergy[synergyPowerUp]\n              && this.config.powerUps[powerUp].modifiers._synergy[synergyPowerUp][variableId]) {\n              modifiers.push(\n                this.config.powerUps[powerUp].modifiers._synergy[synergyPowerUp][variableId]\n              );\n            }\n          });\n      }\n    });\n\n    return modifiers;\n  }\n}\n\nmodule.exports = PowerUpDataModifier;\n","const EventEmitter = require('events');\n\nclass PowerUpInspector {\n  constructor(config) {\n    this.config = config;\n    this.events = new EventEmitter();\n    this.values = Object.fromEntries(Object.keys(config.powerUps).map(id => [id, false]));\n\n    this.$element = $('<div></div>')\n      .addClass('power-up-switcher');\n\n    Object.entries(config.powerUps).forEach(([id, def]) => {\n      const switchId = `power-up-switch-${id}`;\n      $('<div></div>').addClass('form-group form-check')\n        .append(\n          $('<input type=\"checkbox\">')\n            .addClass('form-check-input')\n            .attr('id', switchId)\n            .on('change', () => {\n              this.handleChange(id, $(`#${switchId}`).prop('checked'));\n            }),\n        )\n        .append(\n          $('<label></label>').addClass('form-check-label')\n            .attr('for', switchId)\n            .text(def.title.en)\n        )\n        .appendTo(this.$element);\n    });\n  }\n\n  handleChange(id, enabled) {\n    this.values[id] = enabled;\n    this.events.emit('power-up-change', id, enabled);\n  }\n\n  getEnabled() {\n    return Object.entries(this.values).filter(([, enabled]) => enabled).map(([id]) => id);\n  }\n}\n\nmodule.exports = PowerUpInspector;\n","const EventEmitter = require('events');\n\nclass PowerUpManager {\n  constructor(config) {\n    this.config = config;\n    this.powerUps = Object.fromEntries(\n      Object.entries(config.powerUps).map(([id]) => [id, false])\n    );\n    this.events = new EventEmitter();\n  }\n\n  setState(id, enabled) {\n    if (enabled) {\n      this.enable(id);\n    } else {\n      this.disable(id);\n    }\n  }\n\n  enable(id) {\n    if (this.powerUps[id] !== undefined) {\n      this.powerUps[id] = true;\n      this.events.emit('update', id, true);\n    }\n  }\n\n  disable(id) {\n    if (this.powerUps[id] !== undefined) {\n      this.powerUps[id] = false;\n      this.events.emit('update', id, false);\n    }\n  }\n\n  activePowerUps() {\n    return Object.entries(this.powerUps)\n      .filter(([, enabled]) => enabled)\n      .map(([id]) => id);\n  }\n}\n\nmodule.exports = PowerUpManager;\n","/* eslint-disable no-unused-vars,class-methods-use-this */\n\nclass PowerUpViewHandler {\n  onEnable(powerUp, activePowerUps) {\n\n  }\n\n  onDisable(powerUp, activePowerUps) {\n\n  }\n\n  onChange(activePowerUps) {\n\n  }\n}\n\nmodule.exports = PowerUpViewHandler;\n","class PowerUpViewMgr {\n  constructor() {\n    this.activePowerUps = [];\n    this.handlers = [];\n    this.animatedHandlers = [];\n  }\n\n  registerHandler(handler, animation = false) {\n    this.handlers.push(handler);\n    if (animation) {\n      this.animatedHandlers.push(handler);\n    }\n  }\n\n  update(activePowerUps) {\n    let changes = false;\n    activePowerUps.forEach((powerUp) => {\n      if (!this.activePowerUps.includes(powerUp)) {\n        this.handleEnable(powerUp, activePowerUps);\n        changes = true;\n      }\n    });\n    this.activePowerUps.forEach((powerUp) => {\n      if (!activePowerUps.includes(powerUp)) {\n        this.handleDisable(powerUp, activePowerUps);\n        changes = true;\n      }\n    });\n\n    if (changes) {\n      this.activePowerUps = activePowerUps;\n      this.handlePowerUpChanges(activePowerUps);\n    }\n  }\n\n  handleEnable(powerUp, activePowerUps) {\n    this.handlers.forEach((handler) => {\n      handler.onEnable(powerUp, activePowerUps);\n    });\n  }\n\n  handleDisable(powerUp, activePowerUps) {\n    this.handlers.forEach((handler) => {\n      handler.onDisable(powerUp, activePowerUps);\n    });\n  }\n\n  handlePowerUpChanges(activePowerUps) {\n    this.handlers.forEach((handler) => {\n      handler.onChange(activePowerUps);\n    });\n  }\n\n  animate(time) {\n    this.animatedHandlers.forEach((handler) => {\n      handler.animate(time);\n    });\n  }\n}\n\nmodule.exports = PowerUpViewMgr;\n","const PowerUpViewHandler = require('../power-up-view-handler');\nconst AiCarDriver = require('../cars/ai-car-driver');\n\nclass AutonomousVehicleHandler extends PowerUpViewHandler {\n  constructor(config, carSpawner) {\n    super();\n    this.config = config;\n    this.carSpawner = carSpawner;\n  }\n\n  onEnable(powerUp) {\n    if (powerUp === 'autonomous-vehicles') {\n      this.previousDefaultDriver = this.carSpawner.DefaultDriver;\n      this.carSpawner.DefaultDriver = AiCarDriver;\n    }\n  }\n\n  onDisable(powerUp) {\n    if (powerUp === 'autonomous-vehicles') {\n      if (this.previousDefaultDriver) {\n        this.carSpawner.DefaultDriver = this.previousDefaultDriver;\n      }\n    }\n  }\n}\n\nmodule.exports = AutonomousVehicleHandler;\n","/* globals PIXI */\nconst PowerUpViewHandler = require('../power-up-view-handler');\nconst { randomItem } = require('../lib/random');\n// const AiCarDriver = require('../cars/ai-car-driver');\n\nconst PULSING_INTERVAL = 120;\n\nconst PULSE_DURATION = 100;\nconst PULSE_COLOR = 0xffff00;\nconst PULSE_RADIUS = 36;\n\nconst BOUNDING_DURATION = 180;\nconst BOUNDING_COLOR = 0xffff00;\nconst BOUNDING_PADDING = 2;\n\nclass AutonomousVehicleLidarHandler extends PowerUpViewHandler {\n  constructor(config, carOverlay) {\n    super();\n    this.config = config;\n    this.carOverlay = carOverlay;\n    this.enabled = false;\n    this.counter = 0;\n    this.target = 0;\n\n    this.displayObject = this.createOverlay();\n\n    this.pulsingCars = [];\n    this.pulses = [];\n\n    this.boundedCars = [];\n    this.boundingBoxes = [];\n  }\n\n  createOverlay() {\n    const overlay = new PIXI.Container();\n    overlay.width = this.carOverlay.displayObject.width;\n    overlay.height = this.carOverlay.displayObject.height;\n    overlay.x = 0;\n    overlay.y = 0;\n    overlay.zIndex = this.carOverlay.displayObject.zIndex - 20;\n    this.carOverlay.mapView.addOverlay(overlay);\n\n    return overlay;\n  }\n\n  onEnable(powerUp) {\n    if (powerUp === 'autonomous-vehicles') {\n      this.enabled = true;\n    }\n  }\n\n  onDisable(powerUp) {\n    if (powerUp === 'autonomous-vehicles') {\n      this.enabled = false;\n    }\n  }\n\n  startPulsing() {\n    const loop = () => {\n      this.pulsingTimer = setTimeout(() => {\n        this.firePulse();\n        loop();\n      }, PULSING_INTERVAL);\n    };\n    loop();\n  }\n\n  endPulsing() {\n    if (this.pulsingTimer !== null) {\n      clearTimeout(this.pulsingTimer);\n      this.pulsingTimer = null;\n    }\n  }\n\n  firePulse() {\n    const elegibleCars = this.carOverlay.cars.filter(car => (\n      car.driver.isAutonomous\n      && !car.isSpawning\n      && !car.isDespawning\n      && !this.pulsingCars.includes(car)\n    ));\n    if (elegibleCars.length > 0) {\n      const car = randomItem(elegibleCars);\n      this.pulsingCars.push(car);\n      this.pulses.push(this.createPulse(car));\n    }\n  }\n\n  createPulse(car) {\n    const graphics = new PIXI.Graphics();\n    graphics.lineStyle(1, PULSE_COLOR, 0.8);\n    graphics.beginFill(PULSE_COLOR, 0.3);\n    graphics.drawCircle(0, 0, PULSE_RADIUS);\n    graphics.endFill();\n    graphics.x = car.sprite.x;\n    graphics.y = car.sprite.y;\n    graphics.scale.x = 0;\n    graphics.scale.y = 0;\n    graphics.alpha = 1;\n    this.displayObject.addChild(graphics);\n\n    return {\n      graphics,\n      car,\n      duration: PULSE_DURATION,\n      elapsed: 0,\n    };\n  }\n\n  hitCar(car) {\n    if (!this.boundedCars.includes(car)\n      && !car.isSpawning\n      && !car.isDespawning\n      && car.isVisible()) {\n      this.boundedCars.push(car);\n      this.boundingBoxes.push(this.createBoundingBox(car));\n    }\n  }\n\n  createBoundingBox(car) {\n    const graphics = new PIXI.Graphics();\n    graphics.lineStyle(1, BOUNDING_COLOR, 0.8);\n    graphics.drawRect(\n      (car.sprite.width / -2) - BOUNDING_PADDING,\n      (car.sprite.height * -car.sprite.anchor.y) - BOUNDING_PADDING,\n      car.sprite.width + 2 * BOUNDING_PADDING,\n      car.sprite.height + 2 * BOUNDING_PADDING\n    );\n    graphics.endFill();\n    graphics.x = car.sprite.x;\n    graphics.y = car.sprite.y;\n    // graphics.anchor.set(car.sprite.anchor.x, car.sprite.anchor.y);\n    graphics.rotation = car.sprite.rotation;\n    graphics.alpha = 1;\n    this.displayObject.addChild(graphics);\n\n    return {\n      graphics,\n      car,\n      duration: BOUNDING_DURATION,\n      elapsed: 0,\n    };\n  }\n\n  onPulseEnd(pulse) {\n    this.pulsingCars = this.pulsingCars.filter(car => car !== pulse.car);\n    this.displayObject.removeChild(pulse.graphics);\n    pulse.graphics.destroy();\n    this.pulses = this.pulses.filter(p => p !== pulse);\n  }\n\n  onBoundingBoxEnd(boundingBox) {\n    this.boundedCars = this.boundedCars.filter(car => car !== boundingBox.car);\n    this.displayObject.removeChild(boundingBox.graphics);\n    boundingBox.graphics.destroy();\n    this.boundingBoxes = this.boundingBoxes.filter(b => b !== boundingBox);\n  }\n\n  animate(time) {\n    this.pulses.forEach((pulse) => {\n      if (pulse.car.sprite) {\n        pulse.graphics.x = pulse.car.sprite.x;\n        pulse.graphics.y = pulse.car.sprite.y;\n      }\n      pulse.elapsed += time;\n\n      const progress = Math.min(1, pulse.elapsed / pulse.duration);\n      pulse.graphics.alpha = progress <= 0.8 ? 1 : 1 - ((progress - 0.8) / 0.2);\n      const scale = Math.min(progress, 1);\n      pulse.graphics.scale.x = scale;\n      pulse.graphics.scale.y = scale;\n\n      if (progress >= 1) {\n        this.onPulseEnd(pulse);\n        this.carOverlay.getCarsAround(pulse.car).forEach((carAround) => {\n          const cheapDistance = (v1, v2) => Math.max(Math.abs(v1.x - v2.x), Math.abs(v1.y - v2.y));\n          if (pulse.car.sprite && carAround.sprite &&\n            cheapDistance(pulse.car.getSpritePosition(), carAround.getSpritePosition()) < PULSE_RADIUS * 1.5) {\n            this.hitCar(carAround);\n          }\n        });\n      }\n    });\n\n    this.boundingBoxes.forEach((boundingBox) => {\n      if (boundingBox.car.sprite) {\n        boundingBox.graphics.x = boundingBox.car.sprite.x;\n        boundingBox.graphics.y = boundingBox.car.sprite.y;\n        boundingBox.graphics.rotation = boundingBox.car.sprite.rotation;\n        boundingBox.elapsed += time;\n        if (boundingBox.elapsed > boundingBox.duration) {\n          this.onBoundingBoxEnd(boundingBox);\n        }\n      } else {\n        this.onBoundingBoxEnd(boundingBox);\n      }\n    });\n\n    if (this.enabled) {\n      this.counter += time;\n      if (this.counter > this.target) {\n        this.firePulse();\n        this.counter = 0;\n        this.target = Math.random() * PULSING_INTERVAL;\n      }\n    }\n  }\n}\n\nmodule.exports = AutonomousVehicleLidarHandler;\n","const PowerUpViewHandler = require('../power-up-view-handler');\nconst MapView = require('../map-view');\nconst { getTileTypeId } = require('../lib/config-helpers');\n\nclass DenseCityHandler extends PowerUpViewHandler {\n  constructor(config, mapView) {\n    super();\n    this.config = config;\n    this.mapView = mapView;\n\n    const residentialId = getTileTypeId(this.config, 'residential');\n    const commercialId = getTileTypeId(this.config, 'commercial');\n\n    this.colors = {\n      residential: this.config.tileTypes[residentialId].color,\n      commercial: this.config.tileTypes[commercialId].color,\n    };\n  }\n\n  onEnable(powerUp) {\n    if (powerUp === 'dense-city') {\n      this.mapView.basicTileRenderers.residential = this.renderResidential.bind(this);\n      this.mapView.basicTileRenderers.commercial = this.renderCommercial.bind(this);\n      this.mapView.handleCityUpdate(this.mapView.city.map.allCells());\n    }\n  }\n\n  onDisable(powerUp) {\n    if (powerUp === 'dense-city') {\n      this.mapView.basicTileRenderers.residential = null;\n      this.mapView.basicTileRenderers.commercial = null;\n      this.mapView.handleCityUpdate(this.mapView.city.map.allCells());\n    }\n  }\n\n  renderResidential(i, j) {\n    this.mapView.getBgTile(i, j)\n      .clear()\n      .beginFill(Number(`0x${this.colors.residential.substr(1)}`), 1)\n      .drawRect(0, 0, MapView.TILE_SIZE, MapView.TILE_SIZE)\n      .beginFill(Number(`0x${this.colors.commercial.substr(1)}`), 1)\n      .drawRect(MapView.TILE_SIZE / 2, MapView.TILE_SIZE / 2,\n        MapView.TILE_SIZE / 2, MapView.TILE_SIZE / 2)\n      .endFill();\n  }\n\n  renderCommercial(i, j) {\n    this.mapView.getBgTile(i, j)\n      .clear()\n      .beginFill(Number(`0x${this.colors.commercial.substr(1)}`), 1)\n      .drawRect(0, 0, MapView.TILE_SIZE, MapView.TILE_SIZE)\n      .beginFill(Number(`0x${this.colors.residential.substr(1)}`), 1)\n      .drawRect(MapView.TILE_SIZE / 2, MapView.TILE_SIZE / 2,\n        MapView.TILE_SIZE / 2, MapView.TILE_SIZE / 2)\n      .endFill();\n  }\n}\n\nmodule.exports = DenseCityHandler;\n","const PowerUpViewHandler = require('../power-up-view-handler');\n\nclass MaxSpeedHandler extends PowerUpViewHandler {\n  constructor(config, carOverlay) {\n    super();\n    this.config = config;\n    this.carOverlay = carOverlay;\n  }\n\n  onEnable(powerUp) {\n    if (powerUp === 'reduced-speed-limit') {\n      this.previousMaxSpeed = this.carOverlay.cityMaxSpeed;\n      this.carOverlay.cityMaxSpeed = 0.4;\n    }\n  }\n\n  onDisable(powerUp) {\n    if (powerUp === 'reduced-speed-limit') {\n      this.carOverlay.cityMaxSpeed = (this.previousMaxSpeed || 0.7);\n    }\n  }\n}\n\nmodule.exports = MaxSpeedHandler;\n","const PowerUpViewHandler = require('../power-up-view-handler');\n\nclass SpawnTramHandler extends PowerUpViewHandler {\n  constructor(config, carSpawner) {\n    super();\n    this.config = config;\n    this.carSpawner = carSpawner;\n  }\n\n  onEnable(powerUp) {\n    if (powerUp === 'improved-mass-transit') {\n      this.carSpawner.spawn('tram');\n      this.carSpawner.spawn('tram');\n    }\n  }\n}\n\nmodule.exports = SpawnTramHandler;\n","const PowerUpViewHandler = require('../power-up-view-handler');\n\nclass TrafficHandler extends PowerUpViewHandler {\n  constructor(config, carSpawner) {\n    super();\n    this.config = config;\n    this.carSpawner = carSpawner;\n  }\n\n  onChange(activePowerUps) {\n    const distribution = Object.assign({}, this.config.traffic['traffic-mode-rates']);\n\n    activePowerUps.forEach((powerUp) => {\n      if (this.config.powerUps[powerUp]['traffic-mode-change']) {\n        Object.entries(this.config.powerUps[powerUp]['traffic-mode-change'])\n          .forEach(([mode, delta]) => {\n            if (distribution[mode] !== undefined) {\n              distribution[mode] += delta;\n            }\n          });\n      }\n    });\n\n    this.carSpawner.setModeDistribution(distribution, activePowerUps);\n  }\n}\n\nmodule.exports = TrafficHandler;\n","const PowerUpViewHandler = require('../power-up-view-handler');\n\nclass WalkableCityHandler extends PowerUpViewHandler {\n  constructor(config, mapView) {\n    super();\n    this.config = config;\n    this.mapView = mapView;\n  }\n\n  onEnable(powerUp) {\n    if (powerUp === 'walkable-city') {\n      this.mapView.roadTextureKey = 'roads-walkable';\n      this.mapView.roadTexturePrefix = 'road-walkable';\n      this.mapView.handleCityUpdate(this.mapView.city.map.allCells());\n    }\n  }\n\n  onDisable(powerUp) {\n    if (powerUp === 'walkable-city') {\n      this.mapView.roadTextureKey = 'roads';\n      this.mapView.roadTexturePrefix = 'road';\n      this.mapView.handleCityUpdate(this.mapView.city.map.allCells());\n    }\n  }\n}\n\nmodule.exports = WalkableCityHandler;\n","/* eslint-disable prefer-destructuring */\nconst Car = require('../cars/car');\nconst RoadTile = require('../cars/road-tile');\nconst Cities = require('./cities.json');\n\nfunction fiveCars(city, carOverlay) {\n  carOverlay.addCar(new Car(carOverlay, carOverlay.textures['car-white'], 2, 0, 'N', RoadTile.INNER_LANE));\n  carOverlay.addCar(new Car(carOverlay, carOverlay.textures['car-red'], 5, 0, 'N', RoadTile.OUTER_LANE));\n  carOverlay.addCar(new Car(carOverlay, carOverlay.textures['car-blue'], 8, 0, 'N', RoadTile.INNER_LANE));\n  carOverlay.addCar(new Car(carOverlay, carOverlay.textures['van-white'], 11, 0, 'N', RoadTile.OUTER_LANE));\n  carOverlay.addCar(new Car(carOverlay, carOverlay.textures['bus-yellow'], 14, 0, 'N', RoadTile.INNER_LANE));\n}\n\nfiveCars.city = Cities.cities[0];\n\nfunction carInFront(city, carOverlay) {\n  carOverlay.addCar(new Car(carOverlay, carOverlay.textures['car-white'], 8, 0, 'N', RoadTile.OUTER_LANE));\n  const obstacle = new Car(carOverlay, carOverlay.textures['car-red'], 8, 2, 'N', RoadTile.OUTER_LANE);\n  window.car = obstacle;\n  obstacle.maxSpeed = 0;\n  obstacle.speed = 0;\n  carOverlay.addCar(obstacle);\n\n  carOverlay.addCar(new Car(carOverlay, carOverlay.textures['car-white'], 11, 0, 'N', RoadTile.OUTER_LANE));\n  const obstacle2 = new Car(carOverlay, carOverlay.textures['car-red'], 11, 2, 'N', RoadTile.OUTER_LANE);\n  obstacle2.onExitTile = () => {\n    obstacle2.maxSpeed = 0;\n    obstacle2.speed = 0;\n  };\n  carOverlay.addCar(obstacle2);\n}\n\ncarInFront.city = Cities.cities[1];\n\nfunction trafficLight(city, carOverlay) {\n  const carNorth = new Car(carOverlay, carOverlay.textures['car-white'], 6, 4, 'N', RoadTile.OUTER_LANE);\n  carOverlay.addCar(carNorth);\n  const carWest = new Car(carOverlay, carOverlay.textures['car-red'], 4, 6, 'W', RoadTile.OUTER_LANE, 0.85);\n  carOverlay.addCar(carWest);\n}\n\ntrafficLight.city = Cities.cities[2];\n\nfunction trafficLightTimeout(city, carOverlay) {\n  for (let i = 0; i !== 10; i += 1) {\n    const carNorth = new Car(carOverlay, carOverlay.textures['car-white'], 6, 4, 'N', RoadTile.OUTER_LANE);\n    carOverlay.addCar(carNorth);\n    const carWest = new Car(carOverlay, carOverlay.textures['car-red'], 4, 6, 'W', RoadTile.OUTER_LANE, 0.85);\n    carOverlay.addCar(carWest);\n  }\n}\n\ntrafficLightTimeout.city = Cities.cities[2];\n\nmodule.exports = {\n  fiveCars,\n  carInFront,\n  trafficLight,\n  trafficLightTimeout,\n};\n","/* globals PIXI */\n\nclass TextureLoader {\n  constructor(app) {\n    this.app = app;\n    this.errors = [];\n    this.textures = {};\n\n    // Add a pre-load middleware that does cache-busting\n    app.loader.pre((resource, next) => { resource.url += `?t=${Date.now()}`; next(); });\n\n    // Add a post-load middleware that sets the scale mode\n    app.loader.use((resource, next) => {\n      if (resource.texture !== undefined) {\n        resource.texture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;\n      }\n      if (resource.textures !== undefined) {\n        Object.keys(resource.textures).forEach((id) => {\n          resource.textures[id].baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;\n        });\n      }\n      next();\n    });\n\n    app.loader.onError.add((err, loader, resource) => {\n      this.errors.push(`${err.message} (${resource.url})`);\n    });\n  }\n\n  addSpritesheet(name) {\n    this.app.loader.add(`./textures/${name}.json`, (resource) => {\n      this.textures[name] = resource.textures;\n    });\n  }\n\n  addFolder(name, keys) {\n    keys.forEach((key) => {\n      this.app.loader.add(key, `./textures/${name}/${key}.png`, (resource) => {\n        if (this.textures[name] === undefined) {\n          this.textures[name] = {};\n        }\n        this.textures[name][key] = resource.texture;\n      });\n    });\n  }\n\n  load() {\n    this.errors = [];\n    return new Promise((resolve, reject) => {\n      this.app.loader.load(() => {\n        if (this.errors.length > 0) {\n          reject(new Error(this.errors.join('<br>')));\n        } else {\n          resolve(this.textures);\n        }\n      });\n    });\n  }\n}\n\nmodule.exports = TextureLoader;\n","class TileCounterView {\n  constructor(stats, config) {\n    this.stats = stats;\n    this.config = config;\n\n    this.stats.events.on('update', this.handleUpdate.bind(this));\n\n    this.$element = $('<div></div>')\n      .addClass('tile-counter');\n\n    this.computedFieldDefs = [\n      {\n        id: 'road-density',\n        label: 'Road:Zone ratio',\n        calculate: () => {\n          const zones = this.stats.get('zones-residential-count')\n            + this.stats.get('zones-commercial-count')\n            + this.stats.get('zones-industrial-count');\n\n          return (this.stats.get('zones-road-count') / zones).toFixed(2);\n        },\n      },\n      {\n        id: 'road-intersection-type',\n        label: 'Intersections (3x/4x)',\n        calculate: () => {\n          const tri = this.stats.get('road-triple-intersections-count');\n          const quad = this.stats.get('road-quad-intersections-count');\n          const total = this.stats.get('zones-road-count');\n          return `${tri}(${(tri / total * 100).toFixed(1)}%) / ${quad}(${(quad / total * 100).toFixed(1)}%)`;\n        },\n      },\n    ];\n\n    this.fields = Object.assign(\n      Object.fromEntries(\n        Object.keys(config.tileTypes).map(id => [id, $('<span></span>').addClass('field')])\n      ),\n      Object.fromEntries(\n        this.computedFieldDefs.map(field => [field.id, $('<span></span>').addClass('field')])\n      ),\n    );\n\n    this.$element.append(\n      $('<ul></ul>')\n        .addClass('tile-counter-counts')\n        .append(\n          Object.keys(config.tileTypes).map(id => $('<li></li>')\n            .append($('<span></span>')\n              .addClass('label')\n              .html(`${config.tileTypes[id].name || config.tileTypes[id].type || id}: `))\n            .append(this.fields[id]))\n        )\n        .append(\n          this.computedFieldDefs.map(field => $('<li></li>')\n            .append($('<span></span>')\n              .addClass('label')\n              .html(`${field.label}: `))\n            .append(this.fields[field.id]))\n        )\n    );\n\n    this.total = this.stats.get('zones-total');\n\n    this.handleUpdate();\n  }\n\n  handleUpdate() {\n    Object.keys(this.config.tileTypes).forEach((id) => {\n      const { type } = this.config.tileTypes[id];\n      const count = this.stats.get(`zones-${type}-count`);\n      this.fields[id].text(`${count} (${((count / this.total) * 100).toFixed(1)}%)`);\n    });\n\n    this.computedFieldDefs.forEach(({ id, calculate }) => {\n      this.fields[id].text(calculate());\n    });\n  }\n\n  extraFieldDefs() {\n    return [\n      {\n        id: 'road-density',\n        label: 'Road density',\n        calculate: () => {\n          const zones = this.stats.get('zones-residential-count')\n            + this.stats.get('zones-commercial-count')\n            + this.stats.get('zones-industrial-count');\n\n          return this.stats.get('zones-road-count') / zones;\n        },\n      }\n    ];\n  }\n}\n\nmodule.exports = TileCounterView;\n","const VariableMapView = require('./variable-map-view');\n\nclass VariableMapOverlayTransition {\n  constructor(duration, inView, outView, onCompleteCallback) {\n    this.duration = duration;\n    this.elapsed = 0;\n    this.inView = inView;\n    this.outView = outView;\n    this.onCompletCallback = onCompleteCallback;\n    this.finished = false;\n  }\n\n  animate(time) {\n    if (!this.finished) {\n      this.elapsed += time;\n\n      this.outView.alpha = 1 - Math.min(this.elapsed / this.duration, 1);\n      this.inView.alpha = Math.min(this.elapsed / this.duration, 1);\n      if (this.elapsed > this.duration) {\n        this.finished = true;\n        this.onCompletCallback();\n      }\n    }\n  }\n\n  finish() {\n    if (!this.finished) {\n      this.elapsed = this.duration;\n      this.outView.alpha = 0;\n      this.inView.alpha = 1;\n      this.finished = true;\n      this.onCompletCallback();\n    }\n  }\n}\n\nclass VariableMapOverlay {\n  constructor(mapView, config) {\n    this.mapView = mapView;\n    this.config = config;\n\n    this.transition = null;\n    const parentBounds = mapView.displayObject.getLocalBounds();\n    this.view = new VariableMapView(\n      mapView.city.map.width,\n      mapView.city.map.height\n    );\n    this.view.displayObject.width = parentBounds.width;\n    this.view.displayObject.height = parentBounds.height;\n    this.view.displayObject.zIndex = 200;\n    this.view.displayObject.alpha = 0;\n\n    this.mapView.addOverlay(this.view.displayObject);\n  }\n\n  show(data, color) {\n    if (this.transition !== null) {\n      this.transition.finish();\n    }\n    this.view.update(data, color);\n    this.transition = new VariableMapOverlayTransition(\n      this.config.variableMapOverlay.transitionDuration * 60,\n      this.view.displayObject,\n      this.mapView.zoningLayer,\n      () => {\n        this.transition = null;\n      }\n    );\n  }\n\n  hide() {\n    if (this.transition) {\n      this.transition.finish();\n    }\n    this.transition = new VariableMapOverlayTransition(\n      this.config.variableMapOverlay.transitionDuration * 60,\n      this.mapView.zoningLayer,\n      this.view.displayObject,\n      () => {\n        this.transition = null;\n      }\n    );\n  }\n\n  animate(time) {\n    if (this.transition !== null) {\n      this.transition.animate(time);\n    }\n  }\n}\n\nmodule.exports = VariableMapOverlay;\n","/* globals PIXI */\nconst Array2D = require('./lib/array-2d');\n\nconst TILE_SIZE = 10;\n\nclass VariableMapView {\n  constructor(width, height, defaultColor = 0xff0000) {\n    this.displayObject = new PIXI.Container();\n    this.defaultColor = defaultColor;\n    this.tiles = Array2D.create(width, height, null);\n    this.values = Array2D.create(width, height, 0);\n    this.lastColor = null;\n\n    Array2D.fill(this.tiles, (x, y) => {\n      const newTile = new PIXI.Graphics();\n      newTile.x = x * TILE_SIZE;\n      newTile.y = y * TILE_SIZE;\n      return newTile;\n    });\n\n    this.displayObject.addChild(...Array2D.flatten(this.tiles));\n    Array2D.forEach(this.values, (value, x, y) => {\n      this.renderTile(x, y);\n    });\n  }\n\n  renderTile(x, y, color) {\n    this.tiles[y][x]\n      .clear()\n      .beginFill(color, this.values[y][x] * 0.95)\n      .drawRect(0, 0, TILE_SIZE, TILE_SIZE)\n      .endFill();\n  }\n\n  update(data, color = null) {\n    Array2D.zip(this.values, data, (value, newValue, x, y) => {\n      if (value !== newValue || color !== this.lastColor) {\n        this.values[y][x] = newValue;\n        this.renderTile(x, y, color || this.defaultColor);\n      }\n    });\n    this.lastColor = color;\n  }\n}\n\nmodule.exports = VariableMapView;\n","class ZoneBalanceView {\n  constructor(stats, config) {\n    this.stats = stats;\n    this.config = config;\n    this.stats.events.on('update', this.handleUpdate.bind(this));\n\n    this.$element = $('<div></div>')\n      .addClass('zone-balance');\n\n    this.levels = {\n      residential: 0,\n      commercial: 0,\n      industrial: 0,\n    };\n\n    const tileTypes = Object.keys(this.levels);\n\n    this.ui = Object.fromEntries(tileTypes.map(type => [type,\n      $('<div></div>').addClass(['bar', `bar-${type}`]).append([\n        $('<div></div>').addClass('label').text(type[0].toUpperCase()),\n        $('<div></div>').addClass('over')\n          .append($('<div></div><div></div><div></div>')),\n        $('<div></div>').addClass('status'),\n        $('<div></div>').addClass('under')\n          .append($('<div></div><div></div><div></div>')),\n      ])]));\n\n    this.$element.append(Object.values(this.ui));\n    this.handleUpdate();\n  }\n\n  static levelAsClass(level) {\n    return `${Math.sign(level) >= 0 ? 'p' : 'm'}${Math.abs(level)}`;\n  }\n\n  handleUpdate() {\n    Object.entries(this.levels).forEach(([type, level]) => {\n      const diff = this.stats.get(`${type}-difference`);\n      const currLevel = Math.sign(diff) * (Math.ceil(Math.abs(diff) / 0.25) - 1);\n      if (currLevel !== level) {\n        const oldClass = ZoneBalanceView.levelAsClass(level);\n        const newClass = ZoneBalanceView.levelAsClass(currLevel);\n        this.ui[type]\n          .removeClass(oldClass)\n          .addClass(newClass);\n\n        this.levels[type] = currLevel;\n      }\n    });\n  }\n}\n\nmodule.exports = ZoneBalanceView;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","/* globals PIXI */\nconst yaml = require('js-yaml');\nconst CfgReaderFetch = require('./cfg-reader-fetch');\nconst CfgLoader = require('./cfg-loader');\nconst City = require('./city');\nconst MapEditor = require('./editor/map-editor');\nconst VariableMapView = require('./variable-map-view');\nconst CarOverlay = require('./cars/car-overlay');\nconst TileCounterView = require('./tile-counter-view');\nconst TestScenarios = require('./test/scenarios');\nconst showFatalError = require('./lib/show-fatal-error');\nrequire('../sass/default.scss');\nconst ZoneBalanceView = require('./zone-balance-view');\nconst DataInspectorView = require('./data-inspector-view');\nconst IndexListView = require('./index-list-view');\nconst PollutionData = require('./data-sources/pollution-data');\nconst NoiseData = require('./data-sources/noise-data');\nconst GreenSpacesData = require('./data-sources/green-spaces-data');\nconst TravelTimesData = require('./data-sources/travel-times-data');\nconst ZoningData = require('./data-sources/zoning-data');\nconst ZoneBalanceData = require('./data-sources/zone-balance-data');\nconst GoalDebugView = require('./goal-debug-view');\nconst DataManager = require('./data-manager');\nconst CitizenRequestView = require('./citizen-request-view');\nconst CitizenRequestViewMgr = require('./citizen-request-view-mgr');\nconst TextureLoader = require('./texture-loader');\nconst CarSpawner = require('./cars/car-spawner');\nconst TrafficData = require('./data-sources/traffic-data');\nconst RoadSafetyData = require('./data-sources/road-safety-data');\nconst PowerUpInspector = require('./power-up-inspector');\nconst PowerUpManager = require('./power-up-manager');\nconst PowerUpDataModifier = require('./power-up-data-modifier');\nconst PowerUpViewMgr = require('./power-up-view-mgr');\nconst TrafficHandler = require('./power-ups/traffic-handler');\nconst AutonomousVehicleHandler = require('./power-ups/autonomous-vehicle-handler');\nconst MaxSpeedHandler = require('./power-ups/max-speed-handler');\nconst SpawnTramHandler = require('./power-ups/spawn-tram');\nconst WalkableCityHandler = require('./power-ups/walkable-city-handler');\nconst DenseCityHandler = require('./power-ups/dense-city-handler');\nconst AutonomousVehicleLidarHandler = require('./power-ups/autonomous-vehicle-lidar-handler');\n\nconst qs = new URLSearchParams(window.location.search);\nconst testScenario = qs.get('test') ? TestScenarios[qs.get('test')] : null;\n\nconst cfgLoader = new CfgLoader(CfgReaderFetch, yaml.load);\ncfgLoader.load([\n  'config/city.yml',\n  'config/tiles.yml',\n  'config/variables.yml',\n  'config/goals.yml',\n  'config/citizen-requests.yml',\n  'config/dashboard.yml',\n  'config/traffic.yml',\n  'config/cars.yml',\n  'config/power-ups.yml',\n  'config/default-settings.yml',\n  './settings.yml',\n])\n  .catch((err) => {\n    showFatalError('Error loading configuration', err);\n    console.error('Error loading configuration');\n    console.error(err);\n  })\n  .then((config) => {\n    const city = (testScenario && testScenario.city)\n      ? City.fromJSON(testScenario.city)\n      : new City(config.cityWidth, config.cityHeight);\n\n    const stats = new DataManager();\n    stats.registerSource(new ZoningData(city, config));\n    stats.registerSource(new ZoneBalanceData(city, config));\n    stats.registerSource(new PollutionData(city, config));\n    stats.registerSource(new NoiseData(city, config));\n    stats.registerSource(new GreenSpacesData(city, config));\n    stats.registerSource(new TravelTimesData(city, config));\n    stats.registerSource(new TrafficData(city, config));\n    stats.registerSource(new RoadSafetyData(city, config));\n    city.map.events.on('update', () => {\n      stats.calculateAll();\n    });\n    const powerUpMgr = new PowerUpManager(config);\n    stats.registerModifier(new PowerUpDataModifier(config, powerUpMgr));\n\n    const app = new PIXI.Application({\n      width: 3840,\n      height: 1920,\n      backgroundColor: 0xf2f2f2,\n    });\n\n    const textureLoader = new TextureLoader(app);\n    textureLoader.addSpritesheet('roads');\n    textureLoader.addSpritesheet('roads-walkable');\n    textureLoader.addSpritesheet('parks');\n    textureLoader.addSpritesheet('water');\n    textureLoader.addFolder('cars', CarSpawner.allTextureIds(config));\n    textureLoader.load()\n      .then((textures) => {\n        $('[data-component=\"app-container\"]').append(app.view);\n\n        const mapEditor = new MapEditor($('body'), city, config, textures, stats);\n        app.stage.addChild(mapEditor.displayObject);\n        mapEditor.displayObject.width = 1920;\n        mapEditor.displayObject.height = 1920;\n        mapEditor.displayObject.x = 0;\n        mapEditor.displayObject.y = 0;\n        app.ticker.add(time => mapEditor.animate(time));\n\n        const carOverlay = new CarOverlay(mapEditor.mapView, config, textures, {\n          spawn: !testScenario,\n          maxLifetime: !testScenario,\n        });\n        app.ticker.add(time => carOverlay.animate(time));\n        const carSpawner = new CarSpawner(carOverlay, config);\n        if (!testScenario) {\n          app.ticker.add(time => carSpawner.animate(time));\n        }\n\n        const powerUpViewMgr = new PowerUpViewMgr();\n        app.ticker.add(time => powerUpViewMgr.animate(time));\n        powerUpViewMgr.registerHandler(new TrafficHandler(config, carSpawner));\n        powerUpViewMgr.registerHandler(new AutonomousVehicleHandler(config, carSpawner));\n        powerUpViewMgr.registerHandler(new MaxSpeedHandler(config, carOverlay));\n        powerUpViewMgr.registerHandler(new SpawnTramHandler(config, carSpawner));\n        powerUpViewMgr.registerHandler(new WalkableCityHandler(config, mapEditor.mapView));\n        powerUpViewMgr.registerHandler(new DenseCityHandler(config, mapEditor.mapView));\n        powerUpViewMgr.registerHandler(new AutonomousVehicleLidarHandler(config, carOverlay), true);\n\n        const emissionsVarViewer = new VariableMapView(city.map.width, city.map.height, 0x8f2500);\n        app.stage.addChild(emissionsVarViewer.displayObject);\n        emissionsVarViewer.displayObject.width = 960;\n        emissionsVarViewer.displayObject.height = 960;\n        emissionsVarViewer.displayObject.x = 1920 + 40;\n        emissionsVarViewer.displayObject.y = 0;\n\n        const noiseVarViewer = new VariableMapView(city.map.width, city.map.height, 0x20e95ff);\n        app.stage.addChild(noiseVarViewer.displayObject);\n        noiseVarViewer.displayObject.width = 960;\n        noiseVarViewer.displayObject.height = 960;\n        noiseVarViewer.displayObject.x = 1920 + 40;\n        noiseVarViewer.displayObject.y = 960;\n\n        stats.events.on('update', () => {\n          emissionsVarViewer.update(stats.get('pollution-map'));\n          noiseVarViewer.update(stats.get('noise-map'));\n        });\n\n        const counterView = new TileCounterView(stats, config);\n        const zoneBalanceView = new ZoneBalanceView(stats, config);\n        $('[data-component=counters]').append([\n          counterView.$element,\n          zoneBalanceView.$element,\n        ]);\n\n        const dataInspectorView = new DataInspectorView();\n        $('[data-component=dataInspector]').append(dataInspectorView.$element);\n        mapEditor.events.on('inspect', data => dataInspectorView.display(data));\n\n        const variables = {\n          'Travel times': 'travel-times',\n          'Green space prox.': 'green-spaces-proximity',\n          'Green space areas': 'green-spaces-areas',\n          'Pollution (all)': 'pollution',\n          'Pollution (resid.)': 'pollution-residential',\n          'Noise (all)': 'noise',\n          'Noise (resid.)': 'noise-residential',\n        };\n\n        const varSelector = $('<select></select>')\n          .addClass(['form-control', 'mr-2'])\n          .append(Object.keys(variables).map(name => (\n            $('<option></option>').text(name).attr('value', name)\n          )));\n\n        $('<div></div>').addClass(['form-inline', 'mt-2'])\n          .append(varSelector)\n          .append($('<button></button>')\n            .attr('type', 'button')\n            .addClass(['btn', 'btn-primary', 'btn-sm'])\n            .text('Calculate')\n            .on('click', () => {\n              const varName = varSelector.val();\n              const varData = typeof variables[varName] === 'string'\n                ? stats.get(variables[varName]) : variables[varName].calculate();\n              dataInspectorView.display({\n                title: varName,\n                values: varData,\n                fractional: (Math.max(...varData) <= 1),\n              });\n            }))\n          .appendTo($('[data-component=dataInspector]'));\n\n        const powerUpInspector = new PowerUpInspector(config);\n        $('[data-component=powerUpInspector]').append(powerUpInspector.$element);\n        powerUpInspector.events.on('power-up-change', (id, enabled) => {\n          powerUpMgr.setState(id, enabled);\n          stats.calculateAll();\n          powerUpViewMgr.update(powerUpInspector.getEnabled());\n        });\n\n        const indexListView = new IndexListView(config);\n        // Todo: Remove the lines below\n        $('[data-component=\"status\"]').append(indexListView.$element);\n        indexListView.setValues({\n          'traffic-density': 0,\n          'travel-times': 0,\n          safety: 0,\n          pollution: 0,\n          noise: 0,\n          'green-spaces': 0,\n        });\n        window.variableRankListView = indexListView;\n\n        const goalDebugView = new GoalDebugView(stats.getGoals());\n        $('[data-component=\"goal-debug-container\"]').append(goalDebugView.$element);\n\n        let indexesDirty = true;\n        let indexesCooldownTimer = null;\n        const indexesCooldownTime = 1000;\n\n        function recalculateIndexes() {\n          indexesDirty = true;\n          if (indexesCooldownTimer === null) {\n            indexListView.setValues({\n              'green-spaces': stats.get('green-spaces-index'),\n              pollution: stats.get('pollution-index'),\n              noise: stats.get('noise-index'),\n              'travel-times': stats.get('travel-times-index'),\n              'traffic-density': stats.get('traffic-density-index'),\n              safety: stats.get('road-safety-index'),\n            });\n            goalDebugView.setValues(stats.getGoals());\n            indexesDirty = false;\n            indexesCooldownTimer = setTimeout(() => {\n              indexesCooldownTimer = null;\n              if (indexesDirty) {\n                recalculateIndexes();\n              }\n            }, indexesCooldownTime);\n          }\n        }\n\n        stats.events.on('update', () => {\n          recalculateIndexes();\n        });\n        recalculateIndexes();\n\n        const citizenRequestView = new CitizenRequestView(config);\n        $('[data-component=citizen-request-container]').append(citizenRequestView.$element);\n        const citizenRequestViewMgr = new CitizenRequestViewMgr(citizenRequestView);\n        citizenRequestViewMgr.handleUpdate(stats.getGoals());\n        stats.events.on('update', () => {\n          citizenRequestViewMgr.handleUpdate(stats.getGoals());\n        });\n\n        if (testScenario) {\n          testScenario(city, carOverlay);\n          if (!window.test) {\n            window.test = {};\n          }\n          window.test.city = city;\n          window.test.carOverlay = carOverlay;\n          window.test.cars = carOverlay.cars;\n        }\n      })\n      .catch((err) => {\n        showFatalError('Error loading textures', err);\n        console.error(err);\n      });\n  });\n"],"sourceRoot":""}